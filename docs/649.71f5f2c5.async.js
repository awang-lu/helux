!(function(){"use strict";var Il=Object.defineProperty,Ml=Object.defineProperties;var Fl=Object.getOwnPropertyDescriptors;var mt=Object.getOwnPropertySymbols;var so=Object.prototype.hasOwnProperty,oo=Object.prototype.propertyIsEnumerable;var ro=(L,P,O)=>P in L?Il(L,P,{enumerable:!0,configurable:!0,writable:!0,value:O}):L[P]=O,I=(L,P)=>{for(var O in P||(P={}))so.call(P,O)&&ro(L,O,P[O]);if(mt)for(var O of mt(P))oo.call(P,O)&&ro(L,O,P[O]);return L},U=(L,P)=>Ml(L,Fl(P));var co=(L,P)=>{var O={};for(var R in L)so.call(L,R)&&P.indexOf(R)<0&&(O[R]=L[R]);if(L!=null&&mt)for(var R of mt(L))P.indexOf(R)<0&&oo.call(L,R)&&(O[R]=L[R]);return O};var ao=(L,P,O)=>new Promise((R,W)=>{var ye=Y=>{try{he(O.next(Y))}catch(X){W(X)}},Ve=Y=>{try{he(O.throw(Y))}catch(X){W(X)}},he=Y=>Y.done?R(Y.value):Promise.resolve(Y.value).then(ye,Ve);he((O=O.apply(L,P)).next())});(self.webpackChunkhelux_docs=self.webpackChunkhelux_docs||[]).push([[649],{73649:function(L,P,O){O.r(P),O.d(P,{$:function(){return Ji},EVENT_NAME:function(){return Dl},LIMU_VER:function(){return Rl},RECORD_LOADING:function(){return _l},VER:function(){return Tl},action:function(){return $i},addMiddleware:function(){return Al},addPlugin:function(){return Kl},atom:function(){return Ei},atomx:function(){return vi},block:function(){return Xi},createShared:function(){return mi},defineDeriveFnItem:function(){return Ti},defineDeriveTask:function(){return _i},derive:function(){return Ki},deriveDict:function(){return Di},dynamicBlock:function(){return zi},emit:function(){return ol},flush:function(){return ul},getActionLoading:function(){return gl},getAtom:function(){return Sl},getDeriveLoading:function(){return ml},getMutateLoading:function(){return hl},getRawState:function(){return El},getSnap:function(){return vl},isAtom:function(){return il},isDerivedAtom:function(){return ll},isDiff:function(){return pl},model:function(){return rl},modelFactory:function(){return sl},mutate:function(){return Zi},mutateDict:function(){return Qi},on:function(){return cl},produce:function(){return yl},reactiveDesc:function(){return al},runDerive:function(){return Ri},runDeriveTask:function(){return bi},runMutate:function(){return qi},runMutateTask:function(){return el},shallowCompare:function(){return dl},share:function(){return Si},sharex:function(){return Ai},signal:function(){return Wi},storeSrv:function(){return fl},sync:function(){return tl},syncer:function(){return nl},useActionLoading:function(){return Ui},useAtom:function(){return Mi},useAtomX:function(){return Fi},useDerived:function(){return ki},useEffect:function(){return Vi},useGlobalForceUpdate:function(){return ji},useGlobalId:function(){return Oi},useLayoutEffect:function(){return Yi},useLocalForceUpdate:function(){return Hi},useMutable:function(){return Ni},useMutateLoading:function(){return xi},useObject:function(){return Bi},useOnEvent:function(){return Pi},useReactive:function(){return wi},useService:function(){return Li},useStable:function(){return Gi},useWatch:function(){return Ci},watch:function(){return Ii}});function R(e,t){e.includes(t)||e.push(t)}function W(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function ye(e){return Array.from(new Set(e))}function Ve(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function he(e,t){let n="";const r=e.length;for(let s=0;s<r;s++){const o=e[s];if(t.startsWith(o)){n=o;break}}return n}function Y(e,t){if(!e)return[];const n=e(t);return Array.isArray(n)?n:[n]}var X=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),bn=!1;function F(...e){}var uo=F;function io(...e){return e}function ge(...e){return[]}function wl(...e){}var lo=Object.prototype.toString,fo="[object Map]";function Et(e){return lo.call(e)===fo}function In(e){return e===Number.MAX_SAFE_INTEGER}function se(){return!(!bn&&X.name!=="previewFrame"&&!X.BrowserFS)}function H(e){return e&&typeof e=="object"&&!Array.isArray(e)}function Mn(e){return e&&typeof e=="object"}function w(e){return typeof e=="function"}function kl(e){return bn?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function vt(e){return typeof e=="symbol"}function St(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&w(e.then)}function Cl(e){try{return e.test,!1}catch(t){return!0}}function Ke(){return typeof Proxy=="function"}function oe(e,t){var i;const{throwErr:n=!1,prefixLabel:r="",suffixLabel:s=", see details in console.",logErr:o=!0,alertErr:a}=t||{};let c=e,u=!1;if(e instanceof Error&&(u=!0,c=e.message),(a!=null?a:se())&&e&&((i=X.alert)==null||i.call(X,`${r}${c}${s}`)),o&&console.error(e),n)throw u?e:new Error(String(e))}function me(e,t=0){t===0?(console.error(e),se()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function De(e){return In(e)?1:e+1}var po=!!Reflect,yo=Object.prototype.hasOwnProperty;function ho(e,t){return po?Reflect.has(e,t):yo.call(e,t)}function _e(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function Ye(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function Fn(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function wn(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function ce(e,t){let n,r=e;return t.forEach(s=>{n=Et(r)?wn(r,s):r[s],r=n}),n}function kn(e,t,n){let r=e;const s=t.length-1;t.forEach((o,a)=>{const c=Et(r);if(a===s)return void(c?r.set(o,n):r[o]=n);r=c?wn(r,o):r[o]})}function go(){return me("changing shared state is invalid"),!0}function Ol(e){return e}function At(e,t){return`${t}/${e}`}function Kt(e){return e&&Ke()}var mo=Object.defineProperty,Dt={};((e,t)=>{for(var n in t)mo(e,n,{get:t[n],enumerable:!0})})(Dt,{useEffect:()=>Ao,useEffectLogic:()=>Tt,useForceUpdate:()=>Cn,useLayoutEffect:()=>So,useObject:()=>Do,useObjectLogic:()=>Ln,useStable:()=>On});var Eo=0,Ge=new Map,_t=0;function vo(e,t){const n=()=>{const r=t();return()=>{Ge.delete(e),r&&r()}};if(function(r){_t||(_t=r)}(e),function(r){const s=Ge.get(r);s?s.count+=1:Ge.set(r,{count:1})}(e),_t%2!=0)return n();{const r=function(s){return Ge.get(s)}(e);if(r&&r.count>1)return n()}}function Tt(e,t,n){const{useState:r,useLayoutEffect:s,useEffect:o}=e.react,{isLayout:a,deps:c}=n,[u]=r(()=>++Eo);(a?s:o)(()=>vo(u,t),c)}function So(e,t,n){Tt(e,t,{isLayout:!0,deps:n})}function Ao(e,t,n){Tt(e,t,{deps:n})}function Cn(e){const[,t]=e.react.useState({});return()=>t({})}function Ko(e){const{data:t}=e.current;w(t)?e.current.wrap=(...n)=>e.current.data(...n):H(t)?e.current.wrap=function(n,r){if(!Ke()){const o={};return Object.keys(n).forEach(a=>{const c=n[a];w(c)?o[a]=(...u)=>r.current.data[a](...u):Object.defineProperty(o,a,{get:()=>r.current.data[a],set(u){r.current.data[a]=u}})}),o}const s={};return new Proxy(n,{get(o,a){const c=o[a];return w(c)?_e(s,a,(...u)=>r.current.data[a](...u)):c}})}(t,e):e.current.wrap=t}function On(e,t){const{useRef:n,useMemo:r}=e.react,s=n({data:t,wrap:{},inited:!1});return s.current.data=r(()=>t,[t]),s.current.inited||(Ko(s),s.current.inited=!0),s.current.wrap}function Ln(e,t,n,r){const{useState:s,useRef:o,useEffect:a}=e.react,[c]=s(t),u=Cn(e),i=o({state:null,unmount:!1,shouldCopy:!0}),f=On(e,{setState(l){const d=i.current;if(d.unmount)return;let y;const{state:m}=d;n?(y=n(l,d.state||c),r&&y?(d.state=y,d.shouldCopy=!1):d.shouldCopy=!0):(y=(w(l)?l(m):l)||{},d.shouldCopy=!0),Object.assign(c,y||{}),u()},getLatestState(){const l=i.current;return l.shouldCopy&&(l.state=I({},c),l.shouldCopy=!1),l.state}});return a(()=>{const l=i.current;return l.unmount=!1,()=>{l.unmount=!0}},[i]),[c,f.setState,f]}function Do(e,t){return Ln(e,t)}function _o(e){const t={},n={react:e},r=Dt;return Object.keys(Dt).forEach(s=>{t[s]=r[s].bind(null,n)}),t}var j=O(18636),To=Object.defineProperty,Ro=(e,t)=>{for(var n in t)To(e,n,{get:t[n],enumerable:!0})},Pn={};Ro(Pn,{$:()=>ui,EVENT_NAME:()=>Rt,LIMU_VER:()=>bo,RECORD_LOADING:()=>bt,VER:()=>Nn,action:()=>us,addMiddleware:()=>$o,addPlugin:()=>Jo,atom:()=>Vu,atomx:()=>Yu,block:()=>si,createShared:()=>ai,currentDraftRoot:()=>Tc,defineDeriveFnItem:()=>uu,defineDeriveTask:()=>au,derive:()=>ds,deriveDict:()=>cu,dynamicBlock:()=>zs,emit:()=>ec,flush:()=>rn,getActionLoading:()=>Du,getAtom:()=>jn,getDeriveLoading:()=>xa,getMutateLoading:()=>Au,getRawState:()=>ac,getSnap:()=>uc,isAtom:()=>be,isDerivedAtom:()=>ae,isDiff:()=>ci,mutate:()=>ms,mutateDict:()=>Es,on:()=>tc,produce:()=>j.Uy,reactiveDesc:()=>Mr,runDerive:()=>Oa,runDeriveTask:()=>La,runMutate:()=>hs,runMutateTask:()=>gs,shallowCompare:()=>oi,share:()=>Dn,sharex:()=>Uu,signal:()=>Js,storeSrv:()=>Iu,sync:()=>Gu,syncer:()=>Bu,useActionLoading:()=>_u,useAtom:()=>vs,useAtomX:()=>du,useDerived:()=>vn,useGlobalForceUpdate:()=>Ds,useGlobalId:()=>Su,useLocalForceUpdate:()=>bs,useMutable:()=>Is,useMutateLoading:()=>Ku,useOnEvent:()=>Tu,useReactive:()=>Ms,useService:()=>bu,useWatch:()=>Fu,watch:()=>Qa});var Nn="3.5.21",bo=j.TT,Rt={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},bt={NO:"no",PRIVATE:"private",GLOBAL:"global"},xn=0,Un=Symbol,Io=typeof Un=="function";function Q(e){return Io?Un(e):(xn+=1,`__HELUX_SYMBOL_${xn}__`)}var Mo="__proto__",Fo=Ke(),wo=Q("HeluxUndefined"),Vn=Q("HeluxMutateFnItem"),Be=Q("HeluxFnKey"),He=Q("HeluxSharedKey"),Yn=Q("HeluxReactiveMeta"),It=Q("HeluxIsBlock"),Te=Q("HeluxIsAtom"),je=Q("HeluxIsDerivedAtom"),$e=[He,Te,je,It],We="SingleMutate",ko="HeluxGlobalLoading",Co=6,Oo=!0,Gn=2e3,Lo=20,Re="1",Mt="2",Xe=1,ze=2,Bn=3,Ee="|",Je={TASK:"task",MAY_TRANSFER:"may_transfer"},q={STATIC:"static",HOOK:"hook"},J={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},Po="derive",Hn="watch",Ze="Object",No="Map",xo="Array",Uo="Other",G={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function be(e){var t;return e&&(t=e[Te])!=null?t:!1}function ae(e){return e&&e[je]||!1}function jn(e){return be(e)||ae(e)?e.val:e}function Vo(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function Yo(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function Go(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function Bo(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function $n(){const e={};return{on:(t,n)=>{_e(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(s=>s(...n))},off:(t,n)=>{const r=e[t]||[],s=r.findIndex(o=>o===n);s>=0&&r.splice(s,1)},canEmit:t=>e[t]}}function Wn(){const e={VER:Nn,LIMU_VER:j.TT,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:$n(),userBus:$n(),mod:{},middlewares:[],plugins:[],sharedScope:Bo(),fnScope:Vo(),insScope:Go(),blockScope:Yo(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null},legacyRoot:{}};return e}var Qe={},Xn=!1,zn=null;function V(){return Qe.ctx||{}}function Ho(){return Qe}function Jn(e){Qe=e.ROOT,zn=e.api,Xn=e.inited}function jo(){return{ROOT:Qe,inited:Xn,API:zn}}function $o(e){const{middlewares:t}=V();t.push(e)}function Wo(e,t,n,r){const{middlewares:s}=V();if(!s.length)return;const o={},{sharedKey:a,moduleName:c,forAtom:u}=e,f={forAtom:u,draftRoot:t,draft:n,sharedKey:a,moduleName:c,setData:(l,d)=>o[l]=d,data:o,idx:0,sn:r};s.forEach((l,d)=>{l(U(I({},f),{idx:d}))})}var{ON_DATA_CHANGED:Ft,ON_SHARE_CREATED:Zn,ON_ERROR_OCCURED:Xo}=Rt,zo=[J.GLOGAL_LOADING,J.PRIVATE_LOADING];function Jo(e){const{plugins:t,bus:n}=V();t.push(e);const r={on:(s,o)=>n.on(s,o),onStateChanged:s=>n.on(Ft,s)};e.install(r)}function Zo(e,t){const{bus:n}=V();if(n.canEmit(Ft)){const{from:r,desc:s}=t,{sharedKey:o,moduleName:a,snap:c,usefulName:u,stateType:i}=e;let f;zo.includes(i)?f=`${u}/setState`:f=`${u}@${r||"Api"}/${s}`,n.emit(Ft,{snap:c,sharedKey:o,moduleName:a,type:f})}}function Qo(e){const{bus:t}=V();if(t.canEmit(Zn)){const{snap:n,sharedKey:r,moduleName:s,usefulName:o}=e,a=`${o}@FactoryApi/createShared`;t.emit(Zn,{snap:n,sharedKey:r,moduleName:s,type:a})}}function Qn(e,t,n){const{bus:r}=V();if(!r.canEmit(t))return!1;const{sharedKey:s,moduleName:o}=e;return r.emit(t,{moduleName:o,sharedKey:s,data:n}),!0}function qn(e,t){Qn(e,Xo,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function qo(){const{userBus:e}=V();return e}function ec(e,...t){const{userBus:n}=V();n.emit(e,...t)}function tc(e,t){const{userBus:n}=V();return n.on(e,t),()=>n.off(e,t)}function nc(e,t){return e.__proto__=t,e}function rc(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var wt=Object.setPrototypeOf||({__proto__:[]}instanceof Array?nc:rc);function sc(e){const t=Object.create(null);return wt(t,I({},Object.prototype)),e&&Object.assign(t,e),t}function er(e){if(w(e))return;const t=Object.create(null);return wt(t,Object.prototype),wt(e,t),e}function tr(e,t,n){return e[t]=n,!0}function nr(e,t){return e[t]}function Ie(e,t){const{set:n=tr,get:r=nr,obj:s={}}=t||{};return Object.keys(e).forEach(o=>{Object.defineProperty(s,o,{enumerable:!0,configurable:!1,set:function(a){return n(e,o,a)},get:function(){return r(e,o)}})}),s}function ue(e,t){const{set:n=tr,get:r=nr}=t||{};if(Ke())return new Proxy(e,{set(a,c,u){return n(a,c,u)},get(a,c){return r(a,c)}});const s=sc();return Ie(s,{obj:s,set:n,get:r})}var Me=V();function qe(e){const n=V()[e];return Me[e]=n,n}function Z(){return Me.blockScope||qe("blockScope")}function N(){return Me.fnScope||qe("fnScope")}function ee(){return Me.sharedScope||qe("sharedScope")}function rr(){return Me.insScope||qe("insScope")}function sr(){const{INTERMAL_MAP:e}=ee();return e}function oc(e,t){if(!e||!se()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:s}=ee();let o=[],a=!1;if(n.forEach(c=>{c.moduleName===e&&c.loc===t&&c.stateType===J.USER_STATE&&o.push(c.sharedKey)}),o.length>1){const c=o[0],u=n.get(c);n.delete(c),u&&(r.delete(u.sharedKey),s.delete(u.rawState))}return a}function Fe(e){return sr().get(e)}function x(e){const t=te(e);return Fe(t)}function cc(e,t){const n=sr(),r=te(e);n.set(r,t)}function ac(e){return x(e).rawState}function uc(e,t=!0){const n=x(e);return t?n.prevSnap:n.snap}function te(e){return e&&(e[He]||ee().STATE_SHARED_KEY_MAP.get(e))||0}function ic(e){const t=ee(),{STATE_SHARED_KEY_MAP:n}=t,r=De(t.keySeed);return n.set(e,r),t.keySeed=r,r}function lc(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=ee();n.set(e,t),r.set(t,e)}function fc(e){return ee().SHARED_KEY_STATE_MAP.get(e)}function dc(e,t){const{rootState:n,ctx:r}=Ho(),{moduleName:s,usefulName:o}=t,a=n[o],c=x(a);if(s&&c&&c.loc!==t.loc){const u=`
loc1:${c.loc} 
loc2:${t.loc}`;return me(`only-dev-mode tip: moduleName ${s} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+u)}n[o]=e,r.mod[o]=x(e)}var pc={innerSetState:F};function or(e,t){const{rawState:n,forAtom:r}=e,s=new Map,o={},a={},c=[],u=I({},n);let i=u;return r&&(i=n.val),U(I(I({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:F,syncer:F,snap:u,prevSnap:u,rawStateVal:i},e),t),{insCtxMap:s,key2InsKeys:o,id2InsKeys:a,recordId(f,l){if(!f)return;const d=_e(a,f,[]);R(d,l)},delId(f,l){f&&W(a[f]||[],l)},recordDep(f,l){const d=_e(o,f,[]);R(d,l)},delDep(f,l){W(o[f]||[],l)},mapInsCtx(f,l){s.set(l,f)},delInsCtx(f){s.delete(f)},extra:{},loadingInternal:pc,level1ArrKeys:c})}var yc={Mutate:"",Reactive:"r",[q.STATIC]:"s",[q.HOOK]:"h"};function hc(){const e=rr(),t=De(e.keySeed);return e.keySeed=t,t}function gc(){const e=Z(),{keySeed:t,keyPrefix:n}=e,r=De(t);e.keySeed=r;let s=n;return In(t)&&(s=De(n),e.keyPrefix=s),`${s}_${r}`}function mc(){const e=V(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function kt(e){const t=yc[e],r=N().keySeed,s=De(r[e]);return r[e]=s,`${t}${s}`}function Ec(){return kt("Reactive")}var{MAY_TRANSFER:vc}=Je,{SET_STATE:Sc,REACTIVE:Ac}=G,Kc=()=>({isReplaced:!1,replacedValue:null}),Dc=()=>{},_c=Ot({isFake:!0});function cr(e,t,n=F){const{desc:r="",onRead:s,from:o=Ac,depKeys:a=[],isTop:c=!1,expired:u=!1}=t;return{draft:e,finish:n,modified:!1,expired:u,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:F,data:[],isTop:c,key:"",fnKey:"",depKeys:a,writeKeys:[],desc:r,onRead:s,from:o}}function Ct(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:s=Sc,enableDep:o=!1,handleCbReturn:a=!0,sn:c=mc(),isFirstCall:u=!1,desc:i=""}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:a,draftVal:null,from:s,isReactive:r,enableDep:o,sn:c,isFirstCall:u,desc:i}}function we(e,t,n){const{isChanged:r=!0,parentKeyPath:s=[],op:o="set",parentType:a="Object"}=n,c=s.slice();return c.push(e),{isChanged:r,isCustom:!1,op:o,immutBase:!1,key:e,value:t,proxyValue:t,parentType:a,keyPath:s,fullKeyPath:c,isBuiltInFnKey:!1,replaceValue:F,getReplaced:Kc}}function Ot(e){const l=e||{},{desc:t="",fn:n=F,task:r=Dc,depKeys:s=[],writeKeys:o=[],deps:a=ge,isFake:c=!1,onlyDeps:u=!1}=l,i=co(l,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return I({fn:n,task:r,deps:a,oriDesc:"",onlyDeps:u,desc:t,depKeys:s,writeKeys:o,checkDeadCycle:void 0,watchKey:"",isFake:c},i)}function ar(){const e={fnKey:"",fn:F,subFnInfo:_c,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:F,deps:ge,status:{loading:!1,err:null,ok:!0},forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:Xe,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:Re,proxyResult:{},updater:F,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:F},asyncType:vc,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var ur={val:null,isFake:!0},ir=Ct({}),Lt=cr(!0,{expired:!0}),Ll=Ot(),lr=or({rawState:{},forAtom:!1,usefulName:""},{}),fr=ar(),et=ur,Pt=ir,dr="",Nt=new Map,xt=new Map,Ut=new Map,Vt=F,Yt=[],Gt="";function Tc(){return et}var ke={current:()=>Gt,set:e=>Gt=e,del:()=>Gt=""},Bt={current:()=>Vt,set:e=>Vt=e,del:()=>Vt=F},Ce={current:e=>xt.get(e)||"SetState",set:(e,t)=>xt.set(e,t),del:e=>xt.delete(e)},Oe={current:()=>Yt,set:e=>Yt=e,del:()=>Yt=[]},ne={current:()=>Ut.get(dr)||Lt,markUsing:e=>dr=e,set:(e,t)=>Ut.set(e,t),del:e=>Ut.delete(e)},Ht={current:e=>Nt.get(e),set:(e,t)=>Nt.set(e,t),del:e=>Nt.delete(e)},tt={current:()=>et,set:e=>et=e,del:()=>et=ur},jt={current:()=>Pt,set:e=>Pt=e,del:()=>Pt=ir};function $t(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=N();return e[0]==="s"?t:n}function Rc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=N();Ye(n,e,[]).push(t)}function bc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=N(),r=n.get(e);r&&W(r,t)}function Ic(e){const{DEPKEY_FNKEYS_MAP:t}=N(),{depKeys:n,fnKey:r}=e;n.forEach(s=>{const o=t.get(s)||[];W(o,r)})}function pr(e,t){const{FNKEY_STATIC_CTX_MAP:n}=N(),{fnKey:r,prevLevelFnKeys:s}=e;s.forEach(o=>{var c;const a=(c=n.get(o))==null?void 0:c.nextLevelFnKeys;a&&(t?R(a,r):W(a,r))})}function Mc(){const{FNKEY_HOOK_CTX_MAP:e}=N();se()&&e.forEach(t=>{t.isExpired=!0})}function yr(e,t,n){const r=n||kt(t);return w(e)?e[Be]=r:(er(e),e.__proto__[Be]=r),r}function hr(e){return w(e)?e[Be]||"":H(e)&&e.__proto__[Be]||""}function ie(e){return $t(e).get(e)}function Wt(e){return $t(e).get(e)||fr}function Le(e){const t=hr(e);return ie(t)||null}function nt(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r}=N();return{fnCtx:e?ie(e):null,depKeys:t,isIgnore:r,runningSharedKey:n}}function Fc(){return N().runningFnKey}var{USER_STATE:wc}=J;function kc(e,t=8){let n="";if(se()&&e)try{throw new Error("loc")}catch(r){const s=r.stack.split(`
`),o=s[1]||"";o.includes("webpack-internal")||o.includes("/node_modules/")?n=s.slice(0,16).join(" -> "):n=s.map(c=>c.substring(0,c.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function gr(e){const[t,n]=e.split("/"),r=n.split(Ee);return{sharedKey:Number(t),keyPath:r,depKey:e}}function mr(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",s=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:s,sharedKey:t}}function B(e,t){try{return At(e.join(Ee),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Cc(e,t){const{snap:n,prevSnap:r,stateType:s}=e;if(wc!==s)return!0;const{keyPath:o}=gr(t);try{const a=ce(n,o),c=ce(r,o);return a!==c}catch(a){return!0}}function Oc(e,t){return Ke()?(0,j.OA)(e,{onOperate:t,compareVer:!0}):ue(e,{get(n,r){const s=n[r],o=we(r,s,{isChanged:!1,parentKeyPath:[]});return t(o),s}})}function Lc(e,t){if(t!==void 0){if(e)return{val:t};if(H(t))return t}}function Pc(e,t,n){const r=w(t)?t(n):t;return Lc(e,r)}function rt(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:s}=e.getReplaced();s&&(n=r)}return n}function Er(e){return[xo,No].includes(e)}function Nc(e){return Array.isArray(e)||Et(e)}var{isObject:le,getDataType:vr}=j.limuUtils;function Sr(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(Ee);return`${e}${Ee}${r[0]}`}function xc(e,t){he(e,t)||R(e,t)}var Xt=new Map;function Ar(e,t){let n=!1;const{depKey:r,keyPath:s,sharedKey:o}=e,{stopDepInfo:a,level1ArrKeys:c,recordCb:u}=t,i=Xt.get(r);if(i)return u(i),!0;const{keys:f,isArrDict:l,depth:d,arrKeyStopDcit:y,stopArrDep:m}=a,p=he(c,r),g=s.length>d;if(g||p){let v="",D=d;return p&&(D=d+1,y[p]===!1||m&&(g?v=B(s.slice(0,D),o):v=Sr(p,r))),v||(v=B(s.slice(0,D),o)),p||Xt.set(r,v),u(v),!0}const E=String(o);for(const v of f){if(!r.startsWith(v)||v===E)continue;const D=l[v],M=D?Sr(v,r):v;D||Xt.set(r,M),u(M),n=!0;break}return n}function zt(e,t){const n=Z(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:s,KEY_CTX_MAP:o,isDynamic:a}=n,u=(a?s:o).get(r);if(u){const{results:i,depKeys:f}=u;t?R(i,t):e.forEach(l=>R(f,l))}}}function st(e,t){const n=ee(),{COMPARE_MAP:r}=n;let s=r.get(t);return s!==void 0?s:e.sharedKeyStr===t?n.isStateChanged:(s=Cc(e,t),r.set(t,s),s&&(n.isStateChanged=!0),s)}function Kr(e,t,n){if(t.includes(n)&&st(e,n))return!0;let r=!1;for(const s of t)s.startsWith(n)&&st(e,s)&&(r=!0);return r}function Uc(){const e=ee();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function Jt(e=!0){const t=N();t.isIgnore=e}function ve(e,t){const{fnCtx:n,depKeys:r,isIgnore:s}=nt(),o=t.specificCtx||n;if(!o){Bt.current()(e);return}const{DEPKEY_FNKEYS_MAP:a}=N(),{belongCtx:c,sharedKey:u}=t;if(u&&R(o.depSharedKeys,u),n&&c){n.isFirstLevel=!1,c.isAsync&&(n.isAsync=!0);const f=c.fnKey;R(o.prevLevelFnKeys,f),R(c.nextLevelFnKeys,n.fnKey)}const{fnKey:i}=o;e.forEach(f=>{if(Mo===f||s)return;n&&R(r,f);const l=Ye(a,f,[]);R(l,i)})}function Zt(e){e&&e.depKeys.forEach(t=>ve([t],{specificCtx:e}))}function Dr(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=N(),{fnKey:r}=e;t.set(r,e),pr(e,!0);let s=n.get(r);s?s.c=2:(s={c:1,t:Date.now(),prev:0},n.set(r,s));const{c:o}=s;if(o===2){const a=ie(r);Zt(a)}}function _r(e){let t="";return e.depSharedKeys.forEach(n=>{var s;const r=((s=Fe(n))==null?void 0:s.ver)||0;t+=`${r}_`}),t}function Vc(e,t,n){const{DEPKEY_FNKEYS_MAP:r}=N(),s=r.get(t)||[],o=[],a=[];return s.forEach(c=>{const u=ie(c);if(u&&Kr(e,u.depKeys,t)){u.isFirstLevel&&o.push(c),u.isAsync&&a.push(c);const i=n[c];n[c]=i===void 0?1:i+1}}),{firstLevelFnKeys:o,asyncFnKeys:a}}function Qt(e){Ic(e),pr(e)}function Yc(){const{FNKEY_HOOK_CTX_MAP:e}=N();if(e.size>=Lo){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:s,fnKey:o}=n;[Xe,Bn].includes(r)&&t-s>Gn&&(Qt(n),e.delete(o))})}}function qt(e,t,n,r,s,o=!1,a=!1){const c=Z();c.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:s,isDerivedResult:o,isDerivedAtom:a}}function Gc(){return Z().latest}function Tr(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=Z();return e?t:n}function Rr(){return me("changing shared state is invalid"),!0}function ot(e,t,n,r,s){return r===Te?e?t:!1:r===He?n:s}function en(e,t,n){e.replaceValue(ot(e.keyPath.length===0,t,n,e.key,e.value))}function Bc(e){let t={};const{rawState:n,sharedKey:r,forAtom:s,onRead:o,isPrimitive:a,stopDepth:c}=e,u=(f,l)=>{const d=B(f,r);ve([d],{sharedKey:r}),zt([d]),qt(r,l,t,d,f)};if(Fo)t=(0,j.OA)(n,{customKeys:$e,onOperate:f=>{const{isBuiltInFnKey:l,isCustom:d}=f;if(d)return en(f,s,r);if(!l){const{fullKeyPath:y}=f,m=rt(f,o);u(y,m)}},compareVer:!0});else{const f=(l,d,y)=>Ie(l,{set:Rr,get:(m,p)=>{const g=m[p];if($e.includes(p))return ot(d===1,s,r,p,g);const E=we(p,g,{isChanged:!1,parentKeyPath:y});if(d<c&&le(g))return f(g,d+1,E.fullKeyPath);const v=rt(E,o);return u(E.fullKeyPath,v),v}});t=f(n,1,[])}let i=t;return s&&(a?i=n.val:i=ue(n,{set:Rr,get:(f,l)=>t.val[l]})),lc(r,t),{sharedRoot:t,sharedState:i}}var br=null;function tn(){return br}function Hc(e,t){const n=V();let r=n.globalEmpty;if(!r){const{state:s}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:J.GLOGAL_EMPTY}),o=x(s);n.globalEmpty=s,n.globalEmptyInternal=o}return br=r,r}function nn(e){const{GID_INSKEYS_MAP:t}=N();return Ye(t,e,[])}function jc(){return V().globalEmptyInternal}function Ir(e,t){if(!e)return;const n=nn(e);R(n,t)}function $c(e,t){if(!e)return;const n=nn(e);W(n,t)}var{REACTIVE:Wc}=G,Pe=new Map;function Xc(e){return!!(e&&!e.expired&&e.modified)}function zc(e){const{sharedKey:t}=e;e.expired=!0,ne.del(e.key);const n=Ce.current(t);return Ce.del(t),e.finish(null,{desc:n})}function Mr(e,t){const n=te(e);return t&&Ce.set(n,t),n}function rn(e,t){const n=te(e);Ne(n,t)}function Jc(){const e=ne.current();e.isTop&&Ne(e.sharedKey,e.desc)}function Ne(e,t){const n=Pe.get(e);Xc(n)&&(t&&Ce.set(e,t),zc(n))}function Zc(e){const t=Pe.get(e)||Lt;t.expired=!0}function Qc(e,t){const n=Pe.get(e)||Lt;n.modified=!0,n.nextTickFlush(t)}function Fr(e,t,n){const{sharedKey:r}=e;let s=Pe.get(r);if(!s||s.expired){const{from:a=Wc}=t,{finish:c,draftRoot:u}=e.setStateFactory({isReactive:!0,from:a,handleCbReturn:!1,enableDep:!0}),i=cr(u,t,c);i.key=Ec(),i.nextTickFlush=f=>{const{expired:l,hasFlushTask:d}=i;l||(i.data=[f]),d||(i.hasFlushTask=!0,Promise.resolve().then(()=>{const[y]=i.data;Ne(r,y)}))},s=i,Pe.set(r,s),ne.set(s.key,s)}ne.markUsing(s.key),s.fnKey=ke.current();const{draft:o}=s;return{val:n?o.val:o,meta:s}}function sn(e,t){let n={},r={};const{rawState:s,deep:o,forAtom:a,isPrimitive:c,sharedKey:u}=e;if(Kt(o)){const i={[He]:u,[Te]:a},f=(d,y,m)=>{const{val:p}=Fr(e,t,d);return p[y]=m,!0},l=(d,y,m)=>{const p=m[y];if(p!==void 0)return p;const{val:g,meta:E}=Fr(e,t,d);return Yn===y?E:g[y]};if(n=new Proxy(s,{set:(d,y,m)=>f(!1,y,m),get:(d,y)=>l(!1,y,i)}),r=n,a){const d=U(I({},i),{[Te]:!1});r=c?s.val:new Proxy(s.val,{set:(y,m,p)=>f(!0,m,p),get:(y,m)=>l(!0,m,d)})}}else n=s,r=s.val;return{draftRoot:n,draft:r}}function qc(e){const{UNMOUNT_INFO_MAP:t}=rr(),{insKey:n,readMap:r,internal:s}=e;s.mapInsCtx(e,n);let o=t.get(n);o?(o.c=2,o.prev=n-1):(o={c:1,t:Date.now(),prev:0},t.set(n,o));const{c:a}=o;a===2&&Object.keys(r).forEach(c=>{s.recordDep(c,n)})}function wr(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(s=>r.delDep(s,n)),r.delInsCtx(n)}function ea(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function ta(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function kr(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:s}=n,o=Nc(s);o&&xc(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,o)}function on(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:s}=e;return(t?r:n).concat(s)}function na(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===Xe){Date.now()-r>Gn?wr(e):e.needEFUpdate=!0;return}t()}function Cr(e){const{internal:t,isReactive:n}=e,{rawState:r,isDeep:s,sharedKey:o,onRead:a,forAtom:c}=t;if(s){const u=i=>{const{isBuiltInFnKey:f,key:l}=i;if(f)return;if(vt(l))return en(i,c,o);const{fullKeyPath:d,keyPath:y,parentType:m}=i,p=rt(i,a),E={depKey:B(d,o),keyPath:d,parentKeyPath:y,sharedKey:o};kr(e,E,{parentType:m,rawVal:p})};if(n){const{draft:i,draftRoot:f}=sn(t,{onRead:u});e.proxyState=f,e.proxyStateVal=i}else e.proxyState=(0,j.OA)(r,{onOperate:u,compareVer:!0})}else e.proxyState=ue(r,{set:()=>(me("changing shared state is invalid"),!0),get:(u,i)=>{const f=u[i];if(vt(i))return ot(!0,c,o,i,f);const l=rt(we(i,f,{isChanged:!1,parentKeyPath:[]}),a),d=At(i,o),y=le(u)?Ze:Uo;return kr(e,{depKey:d,keyPath:[i],sharedKey:o},{parentType:y,rawVal:l}),l}})}function ra(e){var k;const{updater:t,sharedState:n,id:r="",globalId:s="",collectType:o="every",deps:a,pure:c=!0,arrDep:u=!0,isReactive:i=!1}=e,f=u&&(k=e.arrIndexDep)!=null?k:!0,l=x(n);if(!l)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=hc(),{rawState:y,isDeep:m,ver:p,ruleConf:g,level1ArrKeys:E,forAtom:v,sharedKey:D,sharedKeyStr:M,snap:T}=l,{stopDepInfo:S}=g,_={readMap:{},delReadMap:{},pure:c,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:m,isReactive:i,insKey:d,internal:l,rawState:y,sharedState:n,proxyState:{},proxyStateVal:{},updater:t,mountStatus:Xe,renderStatus:Re,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:p,id:r,globalId:s,collectType:o,canCollect:o!=="no",isFirstRender:!0,subscribe:b=>{b()},extra:{},getDeps:()=>on(_,!0),renderInfo:{setDraft:l.insSetDraft,time:Date.now(),sn:0,snap:T,insKey:d,getDeps:()=>on(_,!0),getPrevDeps:()=>on(_,!1)},recordDep:(b,K,A)=>{let h=b.depKey;Ar(b,{stopDepInfo:S,level1ArrKeys:E,recordCb:Ue=>{h=Ue}});const{renderStatus:C,fixedDepKeys:$}=_;if(C===Mt)return;const{readMap:z,insKey:bl,currentDepKeys:Rn,delReadMap:eo}=_;ve([h],{}),Fc()&&(W(Rn,h),R(_.fixedDepKeys,h));const to=()=>{z[h]=1,l.recordDep(h,bl),$.includes(h)||R(Rn,h)};if(!z[h]&&!eo[h]){const{parentKeyPath:Ue}=b;if(c&&K===Ze&&Ue){const gt=Ue.length?B(Ue,D):M;z[gt]&&(delete z[gt],eo[gt]=1,W(Rn,gt))}const no=Er(K);if(no){f&&to();return}(!A||!no&&u)&&to()}}};if(s&&Ir(s,d),Cr(_),l.mapInsCtx(_,d),l.recordId(r,d),w(a)){const b=v?_.proxyState.val:_.proxyState,K=Y(a,b),A=_.getDeps().slice();K.includes(b)&&A.push(l.rootValKey),_.fixedDepKeys=A}return _}function Or(e){const{result:t,forAtom:n}=e;e.proxyResult=ue(t,{set:()=>(me("changing derived result is invalid"),!1),get:(r,s)=>je===s?n:(Re===e.renderStatus&&Zt(e),t[s])})}function sa(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:s,isReactive:o}=e,{sharedKey:a,sharedKeyStr:c,insSetState:u,forAtom:i}=n;r.snap=n.snap,r.time=Date.now();const f=i?t.val:t;return e.isFirstRender&&(e.rootVal=f,Ht.set(e.rootVal,e)),!i&&s&&e.recordDep({depKey:c,keyPath:[],sharedKey:a},Ze),[o?t:f,u,r]}function oa(e,t){if(t&&!be(e))throw new Error("useAtom only accept atom")}function ca(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,Cr(e))}function aa(e){e.mountStatus=ze;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Ir(n,r),qc(e)}function ua(e){e.mountStatus=Bn;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),$c(n,r),wr(e)}function ia(e,t){const n=x(t).sharedKey;return e.internal.sharedKey!==n}function ct(e,...t){try{e.react.useSyncExternalStore(...t)}catch(n){console.error(n)}}var la=null;function Lr(e,t,n){const{hookImpl:r,react:s}=e,o=r.useForceUpdate(),a=s.useRef({ctx:la});let c=a.current.ctx;return(!c||ia(c,t))&&(c=ra(I({updater:o,sharedState:t},n)),a.current.ctx=c),c}function Pr(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Ht.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),aa(t),()=>{ua(t)}),[t])}function fa(e,t,n,r){n.renderStatus=Re,ta(n),ct(e,n.subscribe,()=>x(t).snap),e.react.useEffect(()=>{n.renderStatus=Mt,n.isFirstRender=!1,ea(n)})}function cn(e,t,n={}){const r=Lr(e,t,n);return ct(e,r.subscribe,()=>x(t).snap),Pr(e,r),r}function at(e,t,n={}){const{forAtom:r}=n;oa(t,r);const s=Lr(e,t,n);return fa(e,t,s,n),Pr(e,s),ca(s),{tuple:sa(s),insCtx:s}}function Nr(e,t){const{forAtom:n,label:r,strict:s=!1}=t||{};let o;if(typeof e=="number"?o=Fe(e):o=x(e),!o&&e){const c=e[Yn];o=Fe(c==null?void 0:c.sharedKey)}let a=r?`[[${r}]] err:`:"err:";if(!o)if(s)oe(`${a} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!o.forAtom&&oe(`${a} expect a shared but recived a atom`,{throwErr:!0}),!n&&o.forAtom&&oe(`${a} expect a atom but recived a shared`,{throwErr:!0})),o}function fe(e,t){return Nr(e,U(I({},t||{}),{strict:!0}))}var{MUTATE:da,LOADING:pa}=G,{GLOGAL_LOADING:ya,PRIVATE_LOADING:ha}=J,{PRIVATE:ga,GLOBAL:ma}=bt,xr={},Ea={},va={time:0,sn:0,getDeps:ge,getPrevDeps:ge,insKey:0,setDraft:F},Sa=[de(xr,Ea,da),F,va];function Aa(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:s,moduleName:o}=n,a={};Object.keys(s).forEach(i=>{a[i]={loading:!1,err:null,ok:!0}});const c=o?`${o}@Loading`:"";return e({apiCtx:r,rawState:a,isLoading:!0,stateType:ha},{moduleName:c}).state}var Ur=null;function Ka(){return Ur}function Vr(){return V().globalLoadingInternal}function Da(e,t){const n=V();let r=n.globalLoading;if(!r){const{state:s}=t({apiCtx:e,rawState:{},stateType:ya},{moduleName:ko}),o=x(s);n.globalLoadingInternal=o,n.globalLoading=s}return Ur=r,r}function an(e,t){let n=t;return vt(t)&&(n=t.toString()),`${e}>${n}`}function Yr(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(s=>{s[t]=n},{from:pa}),n.err&&(Qn(e,Rt.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function de(e,t,n){let r=e[n];return r||(r=ue(t,{get(s,o){const a=an(n,o);return s[a]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function ut(e,t){const{internal:n,from:r}=t,{stateType:s,recordLoading:o}=n,a=J.USER_STATE===s;let c=de(xr,{},r),u={};if(a)if(ga===o)u=n.extra.loadingProxy,u||(u=Aa(e,t),n.extra.loadingProxy=u,n.loadingInternal=x(u)),c=de(n.extra,u,r);else if(ma===o){const i=Vr();u=Ka(),n.loadingInternal=i,c=de(i.extra,u,r)}else u=tn();else u=n.sharedState,c=de(n.extra,u,r);return{loadingState:c,loadingProxy:u}}function Gr(e,t){if(!le(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?U(I({},e),{internal:fe(r.__sharedKey)}):e}function Br(e,t){const{internal:n,from:r,apiCtx:s}=t,{stateType:o}=n,a=J.USER_STATE===o;let c=()=>Sa;return a&&(c=u=>{const i=Gr(t,u),f=ut(e,i).loadingProxy,{insCtx:{proxyState:l,internal:d,extra:y,renderInfo:m}}=at(s,f);return[de(y,l,r),d.setState,m]}),{useLoading:c,getLoading:u=>{const i=Gr(t,u);return ut(e,i).loadingState}}}function it(e){const t=ar();return Object.assign(t,e||{})}function Se(){const e=N(),{runningFnKey:t}=e;if(!t)return[];const n=ie(t);let r=[];if(n){const{depKeys:s}=e,{depKeys:o}=n,a={};s.forEach(u=>a[u]=1),s.forEach(u=>{const i=Fn(a,u);i&&i!==u&&delete a[i]}),Object.keys(a).forEach(u=>R(o,u)),r=o.slice()}return e.runningFnKey="",e.depKeys=[],e.runningSharedKey=0,r}function Hr(e,t){const n=N();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function jr(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:s}=n,o=yr(e,s),a=I({fn:e,fnKey:o},n),c=r?Object.assign(r,a):it(a);return $t(s).set(o,c),c}function un(e){var s;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=N(),{fnKey:r}=e;Qt(e),e.extra.deferedWatch=null,t.delete(r),((s=n.get(r))==null?void 0:s.c)===2&&n.delete(r),Yc()}function $r(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=N(),{prevLevelFnKeys:n,depKeys:r}=e;let s=!1;for(const o of r){const a=t.get(o)||[];if(Ve(a,n)){s=!0;break}}return s}function _a(e,t=!0,n=Ee){return e.map(r=>{const[s,o]=r.split("/"),a=o.split(Ee);return`${t?`${Fe(Number(s)).usefulName}/`:""}${a.join(n)}`})}var lt=new Map,ft={WATCH:"1",MUTATE:"2"},Ta={[ft.WATCH]:"watch",[ft.MUTATE]:"mutate fn or task"};function Ra(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function Wr(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function ba(e){lt.delete(e)}function Ia(e,t,n,r){const s=Ta[r],{desc:o,task:a,fn:c,isFake:u}=t.subFnInfo,i=o?`(${o})`:"",f=`DEAD_CYCLE: found reactive object in ${s}${i} cb is changing module(${e.usefulName})'s some of these dep keys(${_a(n,!1,".")}), it will cause a infinity loop call!`,l=u?t.fn:a||c;return{err:new Error(`[only-dev-mode alert] ${f}`),tipFn:()=>console.error(` ${f} open the stack to find the below fn: 
`,l)}}function Ma(e,t,n){if(e&&n){const{usefulName:r}=e,s=Ye(lt,r,Ra(t));s.sn!==t&&(s.descs=[],s.errs=[]);const{descs:o}=s;if(o.length>1&&o[0]===n){const a=o.slice();throw s.cycle=a,o.length=0,Wr(r,a,n)}R(o,n)}}function ln(e,t){t.tipFn(),oe(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function pe(e,t,n){const{depKeys:r,subFnInfo:s}=t;let o=t.depKeys,a=n;r.length>n.length&&(o=n,a=r);let c=!1;if(Ve(o,a)){const u=s.desc?ft.MUTATE:ft.WATCH,i=Ia(e,t,n,u);ln(e,i),t.dcErrorInfo=i,c=!0}return c}function Fa(e,t){const n=lt.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function wa(e,t,n=!0){const r=lt.get(e);if(!r)return;const{timer:s,errs:o}=r;o.push(t),s&&clearTimeout(s),r.timer=setTimeout(()=>{let a=null;for(const c of o)a?c.data.length>a.data.length&&(a=c):a=c;a&&oe(a,{alertErr:n}),o.length=0},0)}function fn(e,t=0){const n=ie(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:ka}=Je;function Ca(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:s=0,from:o,internal:a=lr,desc:c,fromFnKey:u}=t;if(e.dcErrorInfo.err){ln(a,e.dcErrorInfo);return}if(e.fnKey===u){pe(a,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:s});if(G.MUTATE===o&&Ma(a,s,c),e.isRunning&&pe(a,e,t.depKeys||[]))return;const i=ne.current();if(i.fnKey===e.fnKey&&pe(a,e,i.writeKeys)||(Ne(i.sharedKey,i.desc),e.isRunning===!0&&i.isTop&&pe(a,e,i.writeKeys)))return;e.isRunning=!0,ke.set(e.fnKey);const l=e.fn({isFirstCall:n,triggerReasons:r,sn:s});ke.del();const d=ne.current();if(!(d.isTop&&d.fnKey===e.fnKey&&pe(a,e,d.writeKeys))&&!(l&&l.task&&d.from===G.MUTATE&&pe(a,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,l}function xe(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:s=!1,throwErr:o=!1,triggerReasons:a=[],sn:c=0,err:u,unbox:i=!1,internal:f=lr}=t,l=ie(e),d=(A=null)=>{if(A&&o)throw A;const h=l||fr;return i?[h.result.val,A]:[h.result,A]};if(!l)return d(new Error(`not a valid watch or derive cb for key ${e}`));if(l.fnType===Hn)return Ca(l,t);const{isAsync:y,fn:m,task:p,isAsyncTransfer:g,forAtom:E,result:v,depKeys:D}=l;l.remainRunCount>0&&(l.remainRunCount-=1);const M=A=>{const h=E?{val:A}:A;!l.returnUpstreamResult&&h&&Object.assign(l.result,h),l.shouldReplaceResult=!0},T=()=>{l.renderInfo.sn=c,l.updater()},S=A=>{const{data:h,err:C=null}=A;C?l.setLoading(!1,C):(M(h),n?y&&l.status.loading&&!$r(l)&&l.setLoading(!1,C):l.remainRunCount===0&&l.setLoading(!1,C)),T(),l.nextLevelFnKeys.forEach($=>{xe($,{isFirstCall:n,sn:c,triggerReasons:a,err:C})})},_=E?v.val:v,k=Y(l.deps),b={isFirstCall:n,prevResult:_,triggerReasons:a,input:k,sn:c};if(!y||r||y&&!p){const A=m(b);return S({data:A}),d()}if(y&&n&&l.nextLevelFnKeys.forEach(A=>fn(A,0)),g)return S({err:u}),d();if(l.asyncType===ka){const A=m(b);return S({data:A}),d()}if(p){let A=uo;return n?(D.forEach(h=>Rc(h,e)),A=()=>D.forEach(h=>bc(h,e))):s&&l.nextLevelFnKeys.forEach(h=>fn(h)),Promise.resolve(()=>{const h=p(b);return St(h)?h:(oe("ERR_NON_FN: derive task arg should be async function!",{throwErr:o}),null)}).then(h=>h()).then(h=>(A(),S({data:h}),d())).catch(h=>{if(A(),S({err:h}),o)throw h;return qn(f,h),d(h)})}return d(u)}function dt(e,t){const n=Le(e);if(!n)throw new Error("[Helux]: not a derived result");return xe(n.fnKey,I({},t||{}))}function Oa(e,t){return dt(e,{forceFn:!0,throwErr:t})}function La(e,t){return Promise.resolve(dt(e,{forceTask:!0,throwErr:t}))}function Pa(e,t){return dt(e,{forceFn:!0,throwErr:t,unbox:!0})}function Na(e,t){return Promise.resolve(dt(e,{forceTask:!0,throwErr:t,unbox:!0}))}function xa(e){const t=Le(e);return t?t.status:{loading:!1,err:null,ok:!0}}function dn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,na(r))}function Ua(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:s,depKeys:o,triggerReasons:a,isFirstCall:c,from:u,sn:i,desc:f,fnKey:l}=t,{key2InsKeys:d,id2InsKeys:y,insCtxMap:m,rootValKey:p}=n;let g=[],E=[],v=[],D=[];const M={};if(c){const S=Se();Oe.set(S)}const T=S=>{if(!st(n,S))return;const _=d[S]||[],k=[];for(const A of _){if(g.includes(A))continue;const h=m.get(A);if(!h)continue;const C=h.getDeps();if(C[0]===p){st(n,p)&&k.push(A);continue}Kr(n,C,S)&&k.push(A)}g=g.concat(k);const{firstLevelFnKeys:b,asyncFnKeys:K}=Vc(n,S,M);v=v.concat(b),D=D.concat(K)};if(o.forEach(S=>T(S)),o.includes(p)||T(p),Uc(),r.forEach(S=>{g=g.concat(y[S]||[])}),s.forEach(S=>{nn(S).forEach(_=>R(E,_))}),g=ye(g),v=ye(v),D=ye(D),D.forEach(S=>fn(S,M[S])),v.forEach(S=>xe(S,{depKeys:o,sn:i,from:u,triggerReasons:a,internal:n,desc:f,isFirstCall:c,fromFnKey:l})),g.forEach(S=>dn(m,S,i)),E.length){const S=jc().insCtxMap;E.forEach(_=>dn(S,_,i))}}function Va(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:s,isDeep:o,ver:a,snap:c}=n;o?(n.prevSnap=a===0?I({},c):c,n.snap=t,Object.assign(s,t)):n.snap=I({},s),n.ver+=1,n.sn=r.sn,Ua(e)}var{MUTATE:Ya}=G;function Xr(e,t){const{writeKey:n,ids:r,internal:s,opParams:o}=t,{snap:a}=s,{fullKeyPath:c,value:u}=o;Object.keys(e).forEach(i=>{n.startsWith(i)&&ce(a,c)!==u&&e[i].forEach(f=>R(r,f))})}function zr(e,t){const{isChanged:n,fullKeyPath:r,keyPath:s,parentType:o,value:a}=e,{internal:c,mutateCtx:u}=t,{arrKeyDict:i,isReactive:f,readKeys:l}=u,{sharedKey:d}=c,y=Er(o),m=ne.current();if(e.op==="get"){y&&(i[B(s,d)]=1);const h=B(r,d);l[h]=1,u.enableDep&&(m.onRead?m.onRead(e):(nt().fnCtx&&ve([h],{sharedKey:d}),f&&(zt([h]),qt(d,a,c.sharedState,h,r))));return}if(!n)return;const{moduleName:p,ruleConf:g,level1ArrKeys:E}=c,{writeKeyPathInfo:v,ids:D,globalIds:M,writeKeys:T}=u,S=B(r,d);if(m.key&&(m.isTop?R(m.writeKeys,S):m.from===Ya&&R(Wt(m.fnKey).subFnInfo.writeKeys||[],S)),y){const h=B(s,d);v[h]={sharedKey:d,moduleName:p,keyPath:s},T[h]=1}const{hasIds:_,hasGlobalIds:k,stopDepInfo:b}=g;v[S]={sharedKey:d,moduleName:p,keyPath:r};const K=Fn(i,S);K&&(T[K]=1),Ar({sharedKey:d,keyPath:r,depKey:S},{stopDepInfo:b,level1ArrKeys:E,recordCb:h=>{T[h]=1}})||(T[S]=1),_&&Xr(g.idsDict,{ids:D,writeKey:S,internal:c,opParams:e}),k&&Xr(g.globalIdsDict,{ids:M,writeKey:S,internal:c,opParams:e}),f?Qc(d,m.desc):Zc(d)}function Jr(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function pt(e,t){if(!t)return e;Jt(!0);const n=e.val;return Jt(!1),n}function Zr(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:s}=e;if(!t)return;if(!n){le(t)&&Jr(s,t);return}const o=t.val;if(le(s)){le(o)?Jr(s,o):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=o}function Ga(e,t){const{internal:n,mutateCtx:r}=e,s=pt(t,n.forAtom),{from:o,sn:a,desc:c}=r;n.before({from:o,draftRoot:t,draft:s,desc:c,sn:a}),Wo(n,t,s,a)}function Qr(e,t,n,r){const{mutateCtx:s,internal:o}=e,{writeKeys:a,writeKeyPathInfo:c,handleCbReturn:u}=s,{forAtom:i}=o;u&&Zr({partial:r,forAtom:i,draftRoot:t,draftNode:n}),Ga(e,t),s.depKeys=Object.keys(a),tt.del(),jt.del(),e.state=(0,j._x)(t),e.state!==o.rawState&&(s.triggerReasons=Object.values(c),Va(e),Zo(o,s))}function qr(e,t){const{ids:n,globalIds:r,from:s,desc:o,fnKey:a}=t;n&&n.forEach(c=>R(e.ids,c)),r&&r.forEach(c=>R(e.globalIds,c)),s&&(e.from=s),o&&(e.desc=o),a&&(e.fnKey=a)}function Ba(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:s}=t,o=Ct(n),a=(0,j.P2)(s,{customKeys:$e,onOperate:u=>{if(u.isCustom)return en(u,r,t.sharedKey);zr(u,{internal:t,mutateCtx:o})}});tt.set(a),jt.set(o);const c=pt(a,r);return r&&(o.readKeys={}),{draftRoot:a,draftNode:c,finishMutate(u,i={}){qr(o,i),Qr({state:{},mutateCtx:o,internal:t},a,c,u)}}}function Ha(e){return er(e),ic(e)}function ja(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function $a(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=w(n);let s=!1;if(t)n=r?{val:n()}:{val:n},s=!n.val||!Mn(n.val);else{if(n=r?n():n,!H(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(te(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:s,rawState:n}}function es(e,t,n){let r=null,s=t||"";if(w(e)&&e!==F)r={[Vn]:1,fn:e,deps:ge,oriDesc:s,onlyDeps:!1,desc:s,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1};else if(H(e)){const{fn:o,desc:a,deps:c,task:u,immediate:i,checkDeadCycle:f,onlyDeps:l=!1}=e,d=t||a||"",y=w(o)?o:void 0,m=w(u)?u:void 0,p=w(c)?c:ge;(o||u)&&(r={[Vn]:1,checkDeadCycle:f,fn:y,watchKey:"",desc:d,oriDesc:d,deps:p,task:m,onlyDeps:l,immediate:i,depKeys:[],writeKeys:[],isFake:!1})}if(r&&n){const{oriDesc:o}=r;(!o||n[o])&&(r.desc=kt(G.MUTATE))}return r}function ts(e,t){const n={},r=t||{};if(!e)return n;const s=(o,a)=>{const c=es(o,a,r);c&&(n[c.desc]=c,r[c.desc]=c)};if(Array.isArray(e))if(e.length===1){const o=e[0],a=(H(o)?o.desc:"")||We;s(e[0],a)}else e.forEach(o=>s(o));else w(e)?s(e,We):H(e)&&Object.keys(e).forEach(o=>{s(e[o],o)});return n}function Wa(e,t={}){var _,k,b,K;const{forAtom:n=!1,forGlobal:r=!1,stateType:s=J.USER_STATE}=e,{rawState:o,isPrimitive:a}=$a(e),c=Ha(o),u=t.moduleName||"",i=(_=t.alertDeadCycleErr)!=null?_:se(),f=(k=t.deep)!=null?k:!0,l=(b=t.checkDeadCycle)!=null?b:!0,d=t.recordLoading||bt.PRIVATE,y=t.rules||[],m=t.before||F,p=t.mutate||F,g=(K=t.stopArrDep)!=null?K:!0,E=t.stopDepth||Co,v=`${c}`,D=n?`${c}/val`:v,M=u||v,T=kc(u),S=ts(p);return{isDestroyed:!1,alertDeadCycleErr:i,checkDeadCycle:l,rawState:o,sharedKey:c,sharedKeyStr:v,rootValKey:D,moduleName:u,usefulName:M,forAtom:n,forGlobal:r,loc:T,deep:f,rules:y,before:m,mutate:p,mutateFnDict:S,onRead:null,stateType:s,recordLoading:d,stopArrDep:g,stopDepth:E,isPrimitive:a}}function Xa(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:s,rules:o,stopDepth:a,stopArrDep:c,forAtom:u}=e,i={},f={},l={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:a,stopArrDep:c},d={},y=Kt(s);o.forEach(g=>{const E=[],{when:v,ids:D=[],globalIds:M=[],stopDep:T}=g;let S;if(y){let A="";S=(0,j.OA)(t,{onOperate:({fullKeyPath:h,value:C,isBuiltInFnKey:$})=>{if($)return;const z=B(h,n);A&&z.includes(A)&&E.pop(),E.push(z),d[z]=Array.isArray(C),A=z}})}else S=ue(t,{set:go,get:(A,h)=>{const C=B([h],n);E.push(C);const $=A[h];return d[C]=Array.isArray($),$}});const _=u?S.val:S,k=Y(v,_),b=(A,h,C)=>{const $=_e(A,C,[]);h.forEach(z=>R($,z))},K=A=>{b(i,D,A),b(f,M,A);let h;d[A]?(h=T!=null?T:Oo,l.arrKeyStopDcit[A]=h,l.isArrDict[A]=d[A]):h=T!=null?T:!1,h&&R(l.keys,A)};E.forEach(K),k.includes(_)&&K(r)});const m=Object.keys(i).length>0,p=Object.keys(f).length>0;return{hasIds:m,idsDict:i,hasGlobalIds:p,globalIdsDict:f,stopDepInfo:l}}function za(e){const{out:t=!0,desc:n=We,strict:r=!1}={};return typeof e=="string"?{out:t,desc:e,strict:r}:I({out:t,desc:n,strict:r},e)}function ns(e){var r;let t=F,n=!1;return w(e)?t=e:H(e)&&(t=e.deps||F,n=(r=e.immediate)!=null?r:!1),{immediate:n,deps:t}}function Ja(e){return e?typeof e=="boolean"?{enableStatus:e}:H(e)?e:{}:{}}function Za(e){Array.isArray(e)&&e.forEach(t=>{const n=Ht.current(t),r=x(t)||(n==null?void 0:n.internal);if(r){const{depKey:s,sharedKey:o}=mr(r);ve([s],{sharedKey:o})}n&&n.recordDep(mr(r))})}function yt(e,t){const{scopeType:n,fnCtxBase:r,immediate:s,deps:o=F,label:a="watch",sharedState:c,isSimpleWatch:u}=t;if(!w(e))throw new Error(`ERR_NON_FN: pass an non-function to ${a}!`);const i=jr(e,{specificProps:{scopeType:n,fnType:Hn,isSimpleWatch:u},fnCtxBase:r});Hr(i.fnKey,te(c));const f=o()||[];return Za(f),s&&e({isFirstCall:!0}),Se(),i}function Qa(e,t){const{deps:n,immediate:r}=ns(t),s=yt(e,{scopeType:q.STATIC,deps:n,immediate:r});return{run:o=>xe(s.fnKey,{throwErr:o}),unwatch:()=>Qt(s)}}var rs=()=>{},pn=new Map;function ss(e,t){const{forAtom:n,rawState:r}=e;return n?Y(t.deps,r.val):Y(t.deps,r)}function qa(e){var t;return(t=pn.get(e))!=null?t:!1}function yn(e,t){const{sn:n,getArgs:r=F,from:s,throwErr:o,isFirstCall:a,fnItem:c,mergeReturn:u}=t,{desc:i="",depKeys:f,task:l=rs}=c,d=x(e),{sharedKey:y}=d,m={desc:i,sn:n,from:s},p=an(s,i),{draft:g,draftRoot:E}=sn(d,{depKeys:f,desc:i,from:s}),v=h=>{Ne(y,h)},D=h=>{v(i);const{finish:C}=d.setStateFactory(m);return C(h)},M=G.MUTATE===s?ss(d,c):[],T={isFirstCall:a,desc:i,setState:D,input:M,draft:g,draftRoot:E,flush:v},S=r(T)||[T],_=pn.get(l),k=_===void 0,b=(h,C,$)=>{(k||_)&&Yr(d,p,{loading:h,err:C,ok:$})};b(!0,null,!1);const K=h=>{if(Oe.del(),b(!1,h,!1),o)throw h;return{snap:d.snap,err:h,result:null}},A=h=>(u&&h&&D(h),b(!1,null,!0),v(i),{snap:d.snap,err:null,result:h});try{const h=l(...S),C=St(h);return pn.set(l,C),C?Promise.resolve(h).then(A).catch(K):A(h)}catch(h){return K(h)}}function os(e,t){const{sn:n,getArgs:r=F,from:s,throwErr:o,isFirstCall:a=!1,fnItem:c}=t,{desc:u="",watchKey:i,fn:f=rs}=c,l=G.MUTATE===s;l&&ke.set(i);const d=x(e),{setStateFactory:y,forAtom:m,sharedState:p}=d,E={desc:u,sn:n,from:s,isFirstCall:a,enableDep:l&&a},v=b=>{const{finish:K}=y(E);return K(b)},D=pt(p,m),M=l?ss(d,c):[],{draftNode:T,draftRoot:S,finish:_}=y(E),k=r({isFirstCall:a,draft:T,draftRoot:S,setState:v,desc:u,input:M})||[T,{input:M,state:D,draftRoot:S,isFirstCall:a}];try{const b=Wt(c.watchKey);if(b.dcErrorInfo.err)return ln(d,b.dcErrorInfo),{snap:d.snap,err:null,result:null};const K=f(...k);return _(K,{fnKey:b.fnKey}),cs(d,c,a),{snap:d.snap,err:null,result:null}}catch(b){if(cs(d,c,a),o)throw b;return{snap:d.snap,err:b,result:null}}}function cs(e,t,n){n&&!t.onlyDeps&&(nt().fnCtx?t.depKeys=Se():t.depKeys=Oe.current(),Oe.del());const r=ne.current();r.isTop&&r.fnKey===t.watchKey&&pe(e,Wt(t.watchKey),r.writeKeys),ke.del()}function eu(e,t){var r;Jc(),Oe.del(),Jt(!1);const n=nt().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=Se())}function hn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const s=x(t),{mutateFnDict:o,usefulName:a,forAtom:c,sharedState:u}=s,i=f=>qn(s,f);r.forEach(f=>{const l=o[f];yt(({sn:d,isFirstCall:y})=>{y&&eu(s,l);const{desc:m,fn:p,task:g,immediate:E}=l,v=Fa(a,m);try{if(v.isIn)throw Wr(a,v.cycle,m);const D={sn:d,throwErr:!0,isFirstCall:y,fnItem:l,from:G.MUTATE};if(p&&(y||!g)&&os(t,D),g){y&&(l.depKeys=Se());const M=y&&(E!=null?E:!p);(!y||M)&&yn(t,D).catch(i)}return l}catch(D){D.cause==="DeadCycle"&&wa(a,D,s.alertDeadCycleErr),i(D)}},{deps:()=>l.deps?l.deps(pt(u,c))||[]:[],sharedState:t,scopeType:q.STATIC,immediate:!0})})}var{ACTION:as}=G;function tu(e,t){const{label:n,throwErr:r,desc:s="",task:o,mergeReturn:a=!0}=t,c=fe(e,{label:n}),{forAtom:u}=c,i=(f,l)=>{const d=l!=null?l:r,y=Ot({desc:s,task:o,depKeys:[]}),m=(p,g)=>p.__action?p.__action(g):p(g);return yn(e,{fnItem:y,from:as,mergeReturn:a,throwErr:d,getArgs:({draft:p,draftRoot:g,setState:E,desc:v,flush:D})=>[{draft:p,draftRoot:g,setState:E,desc:v,payload:f,flush:D,merge:T=>{Zr({partial:T,forAtom:u,draftRoot:g,draftNode:p})},dispatch:m}]})};return Yr(c,an(as,s),{loading:!1,ok:!0,err:null}),i.__sharedKey=c.sharedKey,i.__fnName=s,i.__task=o,o.__action=i,i}function us(e){return t=>(n,r="",s)=>tu(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:s})}var{TASK:is}=Je,{STATIC:nu,HOOK:ru}=q;function ls(e,t,n){if(!n&&(!H(t)||St(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:s}=e;if(r&&!s){const o=hr(t),a=te(t);if(o&&e.fnKey!==o||a)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function su(e,t){const n=ue(e.result,{set:()=>(me("changing derived result is invalid"),!1),get:(r,s)=>{if(s===je)return t;const o=r[s];return ve(e.depKeys,{belongCtx:e}),zt(e.depKeys,n),qt(0,o,n,"",[s],!0,t),o}});return e.proxyResult=n,n}function fs(e,t){var r;const n=Le(t.result);n&&(e.depKeys=ye(e.depKeys.concat(n.depKeys)),R(n.nextLevelFnKeys,e.fnKey),R(e.prevLevelFnKeys,n.fnKey),e.isFirstLevel=!1,(r=t.isUpstream)==null||r.call(t))}function ou(e){var M,T;const{scopeType:t=nu,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:s=is,returnUpstreamResult:o,runAsync:a=!0,forAtom:c=!1,immediate:u}=e;if(!w(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:i=F,deps:f=F,task:l}=e,d=S=>{const _=Y(f);return S.isFirstCall&&_.forEach(k=>fs(p,{result:k})),i(U(I({},S),{input:_}))},y=(M=e.isAsync)!=null?M:w(l),m=(T=e.showLoading)!=null?T:y,p=jr(d,{specificProps:{forAtom:c,scopeType:t,fnType:Po,task:l,deps:f,isAsync:y,asyncType:s,isAsyncTransfer:r,showLoading:m},fnCtxBase:n});Hr(p.fnKey,0);let g=d({isFirstCall:!0,prevResult:null,triggerReasons:[]});Se();const E=Le(g);c&&!E&&(g={val:g,z__is_atom_result__:!0});const v=p.fnKey;ls(p,g),fs(p,{result:g,isUpstream:()=>{p.returnUpstreamResult=o!=null?o:!y}}),Zt(p),p.returnUpstreamResult||yr(g,t,v);const D=a&&s===is&&(u!=null?u:!e.fn);return l&&D&&xe(v,{isFirstCall:!0,sn:p.renderInfo.sn+1}).then(S=>{ls(p,S[0],c)}).catch(S=>oe(S)),p.result=g,t===ru&&$r(p)&&p.setLoading(!0),p.returnUpstreamResult?p.proxyResult=g:su(p,c),p}function gn(e,t){const n=w(e)?{fn:e}:e||{};return ou(I(I({},t||{}),n))}function ds(e){return gn(e,{forAtom:!0}).proxyResult}function cu(e){return gn(e).proxyResult}function au(e){return t=>U(I({},t),{deps:e})}function uu(e){return e}var ht=e=>[e.snap,e.err];function mn(e){const{target:t,desc:n="",forTask:r=!1}=e,{mutateFnDict:s,snap:o}=x(t),a=n||We,c=s[a];if(!c)return{snap:o,err:new Error(`mutate fn ${a} not defined`),result:null};if(r&&!c.task)return{snap:o,err:new Error(`mutate task ${a} not defined`),result:null};const u={sn:0,fnItem:c,from:G.MUTATE};return r?yn(t,u):os(t,u)}function ps(e,t,n,r){return{run:()=>{const s=mn({target:e,desc:t});return ht(s)},runTask:()=>Promise.resolve(mn({target:e,desc:t,forTask:!0})).then(ht),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function iu(e){const{target:t,fnItem:n,label:r}=e,s=fe(t,{label:r}),o=es(n,"",s.mutateFnDict);if(!o)throw new Error("not a fn or fnItem { fn }");s.mutateFnDict[o.desc]=o;const a={[o.desc]:o};return hn({target:t,dict:a}),ps(t,o.desc,o.oriDesc,s)}function lu(e){const{target:t,fnDict:n,label:r}=e,s=fe(t,{label:r}),o=ts(n,s.mutateFnDict);hn({target:t,dict:o});const a={};return Object.keys(o).forEach(c=>{a[c]=ps(t,c,c,s)}),a}function fu(e,t){const{label:n,descOrOptions:r,forTask:s=!1}=t,{desc:o,strict:a}=za(r);return o?Nr(e,{label:n,strict:a})?{ok:!0,desc:o,forTask:s,err:null}:{ok:!1,desc:o,forTask:s,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:o,forTask:s,err:new Error("miss desc")}}function ys(e,t){const{ok:n,desc:r,forTask:s,err:o}=fu(e,t);if(!n)return s?Promise.resolve([e,o]):[e,o];const a=mn({target:e,desc:r,forTask:s});return s?Promise.resolve(a).then(ht):ht(a)}function hs(e,t){return ys(e,{descOrOptions:t,label:"runMutate"})}function gs(e,t){return ys(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function ms(e){return t=>iu({target:e,fnItem:t,label:"mutate"})}function Es(e){return t=>lu({target:e,fnDict:t,label:"mutateDict"})}function vs(e,t,n={}){const{tuple:r}=at(e,t,n);return r}function du(e,t,n={}){const{tuple:r}=at(e,t,n),[s,o,a]=r;return U(I({},a),{state:s,setState:o})}var pu="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",yu="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function hu(e,t,n){return e.isExpired?(e.isExpired=!1,!0):w(n)?!1:n!==t}function gu(e){un(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function mu(e,t){const{result:n,forAtom:r,showLoading:s}=t,{fnCtx:o,input:a,deriveFn:c}=e;let u=!1;if(c)if(hu(o,a,n))u=!0,gu(o);else return;e.input=n;const i=Le(n);if(!i)throw new Error(pu);if(r&&!ae(n))throw new Error(yu);e.deriveFn=()=>i.result,gn({fn:()=>i.result,deps:()=>[],task:()=>ao(this,null,function*(){return i.result})},{isAsync:i.isAsync,scopeType:q.HOOK,fnCtxBase:o,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:Je.MAY_TRANSFER,showLoading:s}),Or(o),u&&o.updater()}function Ss(e,t){const{result:n,forAtom:r}=t,{hookImpl:s,react:o}=e,a=s.useForceUpdate(),{current:c}=o.useRef({input:n,deriveFn:null,fnCtx:null});c.fnCtx||(c.fnCtx=it({updater:a,scopeType:q.HOOK,forAtom:r}));const u=c.fnCtx;return u.renderStatus=Re,mu(c,t),u}function Eu(e,t){t.shouldReplaceResult&&(Or(t),t.shouldReplaceResult=!1),ct(e,t.subscribe,()=>_r(t)),e.react.useEffect(()=>{t.renderStatus=Mt})}function As(e,t){e.react.useEffect(()=>(t.mountStatus=ze,Dr(t),()=>{un(t)}),[t])}function En(e,t){const n=Ss(e,t);return ct(e,n.subscribe,()=>_r(n)),As(e,n),n}function vu(e,t){const n=Ss(e,t);return Eu(e,n),As(e,n),n}function vn(e,t,n){const r=vu(e,I({result:t},n||{})),{proxyResult:s,status:o,renderInfo:a}=r;return[ae(t)?s.val:s,o,a]}function Ks(e,t,n){if(t===null)return n;if(!w(t))return null;const{sharedState:r,forAtom:s}=e,o=s?r.val:r,a={};Bt.set(u=>a[u[0]]=1);const c=Y(t,o);return Bt.del(),c.includes(o)?e.key2InsKeys:a}function Ds(e,t,n){const r=fe(t),[s]=e.react.useState(()=>Ks(r,n,null));return o=>{const{insCtxMap:a,key2InsKeys:c}=r,u=Ks(r,o,c)||s||c,i={};if(Object.keys(u).forEach(l=>{(c[l]||[]).forEach(y=>i[y]=1)}),Object.keys(i).length){r.sn+=1;const l=r.sn;Object.keys(i).forEach(d=>{dn(a,Number(d),l)})}}}function Su(e,t){Kn(e);const n=tn();return cn(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:_s,MUTATE:Ts}=G;function Sn(e,t){Kn(e);const{target:n,from:r="Mutate"}=t||{};let s=Vr();n&&(s=fe(n));const{loadingProxy:o,loadingState:a}=ut(re,{apiCtx:e,internal:s,from:r});return{loadingProxy:o,loadingState:a,internal:s,from:r}}function Rs(e,t){const{loadingProxy:n,internal:r,from:s}=Sn(e,t),{proxyState:o,extra:a,renderInfo:c}=cn(e,n);return[de(a,o,s),r.setState,c]}function Au(e,t){const{loadingProxy:n}=Sn(e,{target:t,from:Ts});return n}function Ku(e,t){return Rs(e,{target:t,from:Ts})}function Du(e,t){const{loadingProxy:n}=Sn(e,{target:t,from:_s});return n}function _u(e,t){return Rs(e,{target:t,from:_s})}function bs(e){return e.hookImpl.useForceUpdate()}function Is(e,t){const n=(r,s)=>{let o=null;if(w(r)){const a=(0,j.P2)(s),c=r(a);o=(0,j._x)(a),H(c)&&Object.assign(o,c)}else H(r)&&(o=I(I({},s),r));return o};return e.hookImpl.useObjectLogic(t,n,!0)}function Tu(e,t,n){e.react.useEffect(()=>{const r=qo();return r.on(t,n),()=>r.off(t,n)},[])}function Ms(e,t,n={}){const r=be(t),{insCtx:s}=at(e,t,U(I({},n),{forAtom:r,isReactive:!0}));return[s.proxyStateVal,s.proxyState,s.renderInfo]}function Ru(e,t,n){const r=H(n)?n:{};e.react.useEffect(()=>{const{srvRef:s}=r;w(s)&&s(t)},[])}function bu(e,t,n){const r=e.hookImpl.useStable(t);return Ru(e,r,n),r}function Iu(e){return t=>e.current=t}var{HOOK:Fs}=q;function ws(e,t){e(()=>{var n,r;return t.mountStatus=ze,Dr(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{un(t)}},[t])}function Mu(e,t,n){const{useState:r,useEffect:s}=e.react,[o]=r(()=>it());if(o.fn===F){const{manualDepKeys:a=[]}=n;yt(t,{scopeType:Fs,fnCtxBase:o,deps:()=>a.map(u=>{const{sharedKey:i,keyPath:f}=gr(u),l=fc(i);return ce(l,f)}),isSimpleWatch:!0})}ws(s,o)}function Fu(e,t,n){const{useRef:r,useState:s,useMemo:o,useEffect:a}=e.react,c=r({fn:t,wrap:null}),[u]=s(()=>it());if(c.current.fn=o(()=>t,[t]),!c.current.wrap){const{deps:i,immediate:f}=ns(n);c.current.wrap=l=>{u.mountStatus===ze?c.current.fn(l):u.extra.deferedWatch=()=>c.current.fn(l)},yt(c.current.wrap,{scopeType:Fs,fnCtxBase:u,deps:i,immediate:f,label:"useWatch"})}ws(a,u)}function wu(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:s,stopDepth:o,sharedKey:a}=t,c=Ct(n),u=I({},r),i=(y,m,p,g)=>{const E=we(m,p,{parentType:vr(y),parentKeyPath:g});zr(E,{internal:t,mutateCtx:c}),kn(u,E.fullKeyPath,p)},f=(y,m,p)=>Ie(y,{set:(g,E,v)=>(i(g,E,v,p),!0),get:(g,E)=>{const v=g[E];if($e.includes(E))return ot(m===1,s,a,E,v);const D=we(E,v,{isChanged:!1,parentKeyPath:p,op:"get",parentType:vr(g)});return m<o&&le(v)?f(v,m+1,D.fullKeyPath):ce(u,D.fullKeyPath)}}),l=f(u,1,[]);tt.set(l),jt.set(c);const d=s?l.val:l;return{draftRoot:l,draftNode:d,finishMutate(y,m={}){qr(c,m);const p=I({state:{},mutateCtx:c},e);Qr(p,l,d,y)}}}function ku(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function Cu(e){let t=[];return{target:Oc(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function ks(e,t,n){return s=>{let o=ku(s);e(a=>{const c=tt.current(),i={draft:a,draftRoot:c,path:t,isAtom:a!==c,UNDEFINED:wo},f=n==null?void 0:n(o,i);kn(c,t,f!==void 0?f:o)},{from:G.SYNC})}}function An(e,t){const{sharedKey:n,innerSetState:r}=t;let s=B(e,n),o=Cs.get(s);return o||(o=ks(r,e),Cs.set(s,o)),o}var Cs=new Map;function Os(e){const{forAtom:t,rawState:n}=e;return t?Mn(n.val)?Ie(n.val,{get:(r,s)=>An(["val",s],e)}):An(["val"],e):Ie(n,{get:(r,s)=>An([s],e)})}var Ls=new Map;function Ps(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:s}=e,o=Cu(s);return(a,c)=>{let u=[];if(Array.isArray(a))u=t?["val",...a]:a;else{const{target:l,getPath:d}=o;a(t?l.val:l),u=d()}let i=B(u,n);c&&(i+=`${c.toString()}`);let f=Ls.get(i);return f||(f=ks(r,u,c),Ls.set(i,f)),f}}function Ou(e,t){const{deep:n,forAtom:r,sharedKey:s}=t,o=Xa(t),a=Kt(n),c=(g={})=>{const E={internal:p,setFactoryOpts:g},{finishMutate:v,draftRoot:D,draftNode:M}=a?Ba(E):wu(E);return{finish:(T,S={})=>{const _=p.snap;if(T===_)return _;const k=Pc(r,T,M);return v(k,S),p.snap},draftRoot:D,draftNode:M}},u=(g={})=>c(g),i=(g,E={})=>c().finish(g,E),f=(g,E)=>{const[v,D,M]=E;return rn(e,Ce.current(s)),c({handleCbReturn:v,enableDep:D}).finish(g,ja(M))},p=or(t,{sharedState:e,setState:(g,E)=>f(g,[!0,!0,E]),setDraft:(g,E)=>f(g,[!1,!0,E]),insSetState:(g,E)=>f(g,[!0,!1,E]),insSetDraft:(g,E)=>f(g,[!1,!1,E]),setStateFactory:u,innerSetState:i,ruleConf:o,isDeep:a});return p.sync=Ps(p),p.syncer=Os(p),cc(e,p),p}function Lu(e,t){const n=Wa(e,t),{sharedRoot:r,sharedState:s}=Bc(n),o=Ou(r,n);dc(r,n),Mc(),hn({target:r,dict:n.mutateFnDict});const{draft:a,draftRoot:c}=sn(o,{isTop:!0});return o.reactive=a,o.reactiveRoot=c,oc(n.moduleName,o.loc),ba(o.usefulName),Qo(o),{sharedRoot:r,sharedState:s,internal:o,parsedOptions:n}}var{USER_STATE:Ns}=J,{MUTATE:Pu,ACTION:xs}=G;function Kn(e,t){Ns===(t||Ns)&&!tn()&&(Hc(e,re),Da(e,re))}function Us(e,t){const{createFn:n,ldAction:r,actionDict:s,actionCreator:o,internal:a,apiCtx:c,forTp:u=!1}=e;ut(n,{internal:a,from:xs,apiCtx:c});const i={},f={};return Object.keys(s).forEach(l=>{const d=s[l],y=u?d.__task:d,m=o(!1)(y,l,t);m.__fnName=l,f[l]=m;const p=(...g)=>{const E=m(...g);return qa(y)?Promise.resolve(E).then(v=>v.result):E.result};p.__fnName=l,i[l]=p}),{actions:i,eActions:f,getLoading:()=>r.getLoading(i),useLoading:()=>r.useLoading(i)[0],useLoadingInfo:()=>r.useLoading(i)}}function Vs(e){const{state:t,ldMutate:n,mutateFnDict:r}=e,s=Es(t)(r);return{witnessDict:s,getLoading:()=>n.getLoading(s),useLoading:()=>n.useLoading(s)[0],useLoadingInfo:()=>n.useLoading(s)}}function Nu(e){const{apiCtx:t,ldMutate:n,inital:r,mutateFnDict:s}=e,[o,,a]=Dn(t,r),c=Vs({state:o,ldMutate:n,mutateFnDict:s});return I({derivedState:o,useDerivedState:i=>{const[f,,l]=a.useState(i);return[f,l]}},c)}function xu(e){const{apiCtx:t,deriveFnDict:n,throwErr:r}=e,s={},o={};return Object.keys(n).forEach(c=>{const u=ds(n[c]);s[c]=u,o[c]={runDerive:i=>Pa(u,i!=null?i:r),runDeriveTask:i=>Na(u,i!=null?i:r),useDerived:i=>vn(t,u,i)[0],useDerivedInfo:i=>vn(t,u,i)}}),{result:new Proxy(s,{get:(c,u)=>s[u].val}),helper:o}}function re(e,t){const{stateType:n,apiCtx:r}=e;Kn(r,n);const{sharedRoot:s,sharedState:o,internal:a}=Lu(e,t),{syncer:c,sync:u,forAtom:i,setState:f,setDraft:l,sharedKey:d,sharedKeyStr:y,rootValKey:m,reactive:p,reactiveRoot:g}=a,E=us(s),v=E(),D={internal:a,from:Pu,apiCtx:r},M=re,T=Br(M,U(I({},D),{from:xs})),S=Br(M,D),_=K=>a.onRead=K,k={createFn:M,internal:a,apiCtx:r},b=U(I({},k),{ldAction:T,actionCreator:E});return{state:s,stateVal:o,setState:f,setDraft:l,defineActions:K=>A=>Us(U(I({},b),{actionDict:A}),K),defineTpActions:K=>A=>Us(U(I({},b),{actionDict:A,forTp:!0}),K),defineMutateDerive:K=>A=>Nu(U(I({},k),{ldMutate:S,inital:K,mutateFnDict:A})),defineMutateSelf:()=>K=>Vs({ldMutate:S,state:s,mutateFnDict:K}),defineFullDerive:K=>A=>xu({apiCtx:r,deriveFnDict:A,throwErr:K}),mutate:ms(s),runMutate:K=>hs(s,K),runMutateTask:K=>gs(s,K),action:E,call:(K,A,h,C)=>v(K,h,C)(A),useState:K=>vs(r,s,K),useForceUpdate:K=>Ds(r,s,K),useLocalState:K=>Is(r,K),useLocalForceUpdate:()=>bs(r),getMutateLoading:S.getLoading,useMutateLoading:S.useLoading,getActionLoading:T.getLoading,useActionLoading:T.useLoading,sync:u,syncer:c,setOnReadHook:_,sharedKey:d,sharedKeyStr:y,rootValKey:m,reactive:p,reactiveRoot:g,reactiveDesc:K=>Mr(s,K),useReactive:K=>Ms(r,s,K),flush:K=>rn(s,K),isAtom:i}}function Dn(e,t,n){const r=re({apiCtx:e,rawState:t},n);return[r.state,r.setState,r]}function Uu(e,t,n){return re({apiCtx:e,rawState:t},n)}function Vu(e,t,n){const r=re({apiCtx:e,rawState:t,forAtom:!0},n);return[r.state,r.setState,r]}function Yu(e,t,n){return re({apiCtx:e,rawState:t,forAtom:!0},n)}function Ys(e,t){const{label:n,isSyncer:r}=t,s=fe(e,{label:n});return(r?Os:Ps)(s)}function Gu(e){return Ys(e,{label:"sync"})}function Bu(e){return Ys(e,{label:"syncer",isSyncer:!0})}var Hu=100,ju=5e3;function $u(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function Wu(e,t=!1){const n=Z();e&&(n.initCount+=1);const r=gc(),s=$u(r,t);return Tr(e).set(r,s),s}function Xu(e){const t=Z();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function zu(e,t){const n=Z(),r=Tr(t);if(r.delete(e),t&&r.size===Hu&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const s=Date.now();r.forEach((o,a)=>{!o.mounted&&s-o.time>ju&&r.delete(a)})}}function Ju(e,t){const n=Z();n.runningKey=e.key,n.isDynamic=t}function Zu(e){const t=Z();t.runningKey="",t.isDynamic=!1,e.collected=!0}function Qu(e,t,n){Mu(e,n,{manualDepKeys:t.depKeys})}function Gs(e,t,n){let r={loading:!1,err:null,ok:!0};return Qu(e,t,n),t.results.forEach(s=>{const o=En(e,{result:s,forAtom:ae(s),showLoading:t.enableStatus});o.status.ok||(r=o.status)}),r}function Bs(e,t,n){e.react.useEffect(()=>(t.mounted||Xu(t),()=>{zu(t.key,n)}),[t])}var Ae=()=>!0,qu=e=>e;function ei(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function _n(e,t,n,r,s){const o=t;return o.displayName=n,r?e.react.memo(o,s):o}function Hs(e,t){const{sharedState:n,depKey:r,keyPath:s,compare:o,sharedKey:a,format:c=qu}=t;return _n(e,function(){const i=cn(e,n,{arrDep:!0});i.isFirstRender&&(s.length>=2?ei(s).forEach(d=>{i.recordDep({sharedKey:a,depKey:B(d,a),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},Ze)}):i.recordDep({sharedKey:a,depKey:r,keyPath:s}));const f=ce(i.internal.rawState,s);return c(f)},"HeluxSignal",!0,o)}function Tn(e,t,n){return _n(e,function(){return En(e,{result:t,forAtom:!0}).proxyResult.val},"HeluxDerivedAtomSignal",!0,n)}function ti(e,t,n,r){return _n(e,function(){return En(e,{result:t,forAtom:!1}),ce(t,n)},"HeluxDerivedSignal",!0,r)}function js(e,t){const{isDynamic:n,cb:r,props:s,ref:o}=t,{collected:a,status:c}=e;a||Ju(e,n);const i=r(s,{props:s,status:c,read:io,ref:o})||"";return a||Zu(e),i}function $s(e,t,n){const r=ae(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const s=Tn(e,n);return e.react.createElement(s,{status:{loading:!1,err:null,ok:!0}})}return jn(n)}function Ws(e,t,n,r){const{memo:s=!0,compare:o}=r||{},{key:a}=t,{react:c}=e,u=c.forwardRef||F,i=n();let f=u(i);se()&&(i.displayName="HeluxKeyedBlockForHMR",f=u((d,y)=>(y&&ho(y,"current")&&(t.ref=y),c.createElement(i,U(I({},d),{key:a})))));const l=s?c.memo(f,o):f;return l.displayName="HeluxBlock",l[It]=!0,l}function ni(e,t){const{cb:n,isDynamic:r,apiCtx:s,blockCtx:o}=e,{useForceUpdate:a}=s.hookImpl,c=r?Bs:F;return Ws(s,o,()=>(u,i)=>{const f=o.ref||i,l=js(o,{isDynamic:r,cb:n,props:u,ref:f}),d=a();return Gs(s,o,d),c(s,o,r),$s(s,o,l)},t)}function ri(e,t){const{cb:n,isDynamic:r,apiCtx:s,blockCtx:o}=e,a=r?Bs:F,{useForceUpdate:c}=s.hookImpl,{useEffect:u}=s.react;return Ws(s,o,()=>(i,f)=>{const l=o.ref||f,d=js(o,{isDynamic:r,cb:n,props:i,ref:l}),y=c(),m=Gs(s,o,y);a(s,o,r);const p=o.status.loading,g=m.loading;return u(()=>{p!==g&&y()},[p,g]),o.status=m,$s(s,o,d)},t)}function Xs(e,t){const n=Ja(t),{enableStatus:r}=n,s=U(I({},e),{blockCtx:Wu(e.isDynamic,r)});return r?ri(s,n):ni(s,n)}function si(e,t,n){return Xs({apiCtx:e,isDynamic:!1,cb:t},n)}function zs(e,t,n){return Xs({apiCtx:e,isDynamic:!0,cb:t},n)}function Js(e,t,n){const{react:r}=e;if(t&&t[It])return r.createElement(t);if(w(t)){const l=zs(e,t,{compare:Ae});return r.createElement(l)}if(ae(t)){const l=Tn(e,t,Ae);return r.createElement(l)}if(be(t)){const l=te(t),d=At("val",l),m=Hs(e,{sharedKey:l,sharedState:t,depKey:d,keyPath:["val"],compare:Ae});return r.createElement(m)}const s=Gc(),{sharedKey:o,val:a,stateOrResult:c,depKey:u,keyPath:i,isDerivedResult:f}=s;if(t===a&&c){if(s.isDerivedAtom){const d=Tn(e,c,Ae);return r.createElement(d)}if(f){const d=ti(e,c,i,Ae);return r.createElement(d)}const l=Hs(e,{sharedKey:o,sharedState:c,depKey:u,keyPath:i,compare:Ae,format:n});return r.createElement(l)}return t}var{shallowCompare:oi,isDiff:ci}=j.limuUtils,ai=Dn,ui=Js;function Zs(e,t,n){return t(e,n)}function ii(e,t){return Zs(e,t)}function li(e,t){return{build:n=>Zs(e,t,n)}}var fi=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function di(e){return e.startsWith("use")||fi.includes(e)}function pi(e){return Object.assign({useSyncExternalStore:F},e)}function Qs(e,t){const n=_o(e),r=I({},n),s={react:pi(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,c]=e.useState({});return()=>t(()=>c({}))});const o=Pn;return Object.keys(o).forEach(c=>{const u=o[c];di(c)?r[c]=u.bind(null,s):r[c]=u}),Object.assign({model:c=>ii(r,c),modelFactory:c=>li(r,c)},r)}function yi(e){const{inited:t,API:n}=jo();if(t)return n;const{heluxCtxKey:r,standalone:s,transfer:o,reactLib:a,act:c}=e,u=X[r],i=f=>{const l=Wn(),d=Qs(a,c);return Jn({ROOT:l,inited:!0,api:d}),X[f]=l,d};if(!u)return i(r);if(s)return i(`${String(r)}_${Date.now()}`);if(o){const f=Wn();Jn({ROOT:f,inited:!0}),o(u,f)}return Qs(a)}var hi=O(70079),gi=O.t(hi,2),qs=yi({heluxCtxKey:"__HELUX__",reactLib:gi}),mi=qs.share,{atom:Ei,atomx:vi,share:Si,sharex:Ai,derive:Ki,deriveDict:Di,defineDeriveTask:_i,defineDeriveFnItem:Ti,runDerive:Ri,runDeriveTask:bi,watch:Ii,useAtom:Mi,useAtomX:Fi,useReactive:wi,useDerived:ki,useWatch:Ci,useGlobalId:Oi,useService:Li,useOnEvent:Pi,useMutable:Ni,useMutateLoading:xi,useActionLoading:Ui,useEffect:Vi,useLayoutEffect:Yi,useStable:Gi,useObject:Bi,useLocalForceUpdate:Hi,useGlobalForceUpdate:ji,action:$i,signal:Wi,block:Xi,dynamicBlock:zi,$:Ji,mutate:Zi,mutateDict:Qi,runMutate:qi,runMutateTask:el,sync:tl,syncer:nl,model:rl,modelFactory:sl,emit:ol,on:cl,reactiveDesc:al,flush:ul,isAtom:il,isDerivedAtom:ll,storeSrv:fl,shallowCompare:dl,isDiff:pl,produce:yl,getMutateLoading:hl,getActionLoading:gl,getDeriveLoading:ml,getRawState:El,getSnap:vl,getAtom:Sl,addMiddleware:Al,addPlugin:Kl,EVENT_NAME:Dl,RECORD_LOADING:_l,VER:Tl,LIMU_VER:Rl}=qs}}]);
}());