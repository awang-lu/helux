"use strict";(self.webpackChunkhelux_docs=self.webpackChunkhelux_docs||[]).push([[1664],{71664:function(Ft,Ne,Ie){Ie.d(Ne,{TT:function(){return Ct},P2:function(){return Se},_x:function(){return ve},OA:function(){return xt},limuUtils:function(){return Pt},Xl:function(){return Vt},Uy:function(){return vt}});const bt=3,Be="3.12.0",U=Symbol("M"),ie=Symbol("V"),ce=Symbol("IMMUT_BASE"),k=Symbol("IS_RAW"),A="Map",x="Set",S="Array",Ke="Object",ze=[Symbol.iterator,Symbol.toStringTag],Le={Map:A,Set:x,Array:S},J="[object Object]",H="[object Map]",Y="[object Set]",X="[object Array]",$="[object Function]",Ue={[H]:A,[Y]:x,[X]:S,[J]:Ke},He=["push","pop","shift","splice","unshift","reverse","copyWithin","delete","fill"],Ye=["set","clear","delete"],Ge=["add","clear","delete"],We=["splice","sort","unshift","shift"],ke=["concat","copyWithin","entries","every","fill","filter","find","findIndex","flat","flatMap","forEach","includes","indexOf","join","keys","lastIndexOf","map","pop","push","reduce","reduceRight","reverse","shift","unshift","slice","some","sort","splice","values","valueOf"],Je=["clear","delete","entries","forEach","get","has","keys","set","values"],Xe=["add","clear","delete","entries","forEach","has","keys","values"],ae={[A]:Je,[x]:Xe,[S]:ke},$e={[A]:["clear","set","delete"],[x]:["clear","add","delete"],[S]:["pop","push","shift","unshift","splice","sort","copyWithin"]},qe={[A]:["forEach","get"],[x]:["forEach"],[S]:["forEach","map"]},B={value:0,usablePrefix:1},le={autoFreeze:!1,fastModeRange:"array"},Qe=Object.prototype.toString,Ze=!!Reflect,je=Object.prototype.hasOwnProperty;function ue(e,t){return Ze?Reflect.has(e,t):je.call(e,t)}function et(e,t,n,r){const o=(s,l,a)=>{T(s)||(r(s,l,a),Array.isArray(s)&&s.forEach((i,f)=>{o(i,s,f)}),G(s)&&s.forEach((i,f)=>{o(i,s,f)}),K(s)&&Object.keys(s).forEach(i=>{o(s[i],s,i)}))};o(e,t,n)}function w(e){return Qe.call(e)}function N(...e){return e}function K(e){return w(e)===J}function G(e){return w(e)===H}function q(e){return w(e)===Y}function F(e){return w(e)===$}function fe(e){var t=w(e);return Ue[t]}function T(e){const t=w(e);return![J,X,H,Y,$].includes(t)}function pe(e){return e.constructor.name==="AsyncFunction"||typeof e.then=="function"}function de(e){return typeof Promise!="undefined"&&e instanceof Promise}function Q(e){var t=typeof e;return t==="number"?!0:t==="string"?/^[0-9]*$/.test(e):!1}function tt(e){return typeof e=="symbol"}function nt(e){var t;return e&&(t=e[k])!==null&&t!==void 0?t:!1}const rt={[X]:Array.prototype,[H]:Map.prototype,[Y]:Set.prototype,[$]:Function.prototype};function ot(e){const t=w(e),n=rt[t]||Object.prototype,r=Object.create(null);return Object.setPrototypeOf(r,n),Object.setPrototypeOf(e,r),e}const Z=new Map;function z(e){e.rootMeta.modified=!0;const t=n=>{n&&!n.modified&&(n.modified=!0,t(n.parentMeta))};t(e)}function j(e,t,n){if(n.apiCtx.debug){const{fast:r}=n;r?e[U]=t:(ot(e),e.__proto__[U]=t)}return e}function st(e,t,n){const r=[t],o=D(e,n);if(o&&o.level>0){const{keyPath:s}=o;return[...s,t]}return r}function it(e,t,n){const{ver:r,parentMeta:o=null,immutBase:s,compareVer:l,apiCtx:a,hasOnOperate:i}=n,f=fe(t);let d=[],c=0,_=null;o&&(_=o.copy,c=at(_,a),d=st(_,e,a));const y={rootMeta:null,parentMeta:o,parent:_,selfType:f,self:t,copy:null,key:e,keyPath:d,level:c,proxyVal:null,proxyItems:null,modified:!1,scopes:[],isImmutBase:s,isDel:!1,isFast:!1,isArrOrderChanged:!1,newNodeStats:{},newNodeMap:new Map,newNodes:[],ver:r,compareVer:l,revoke:N,hasOnOperate:i,execOnOperate:N};return c===0?y.rootMeta=y:y.rootMeta=o.rootMeta,y}function ye(e){const t=ee(e);return t?!t.isImmutBase:!1}function ct(){B.value>=Number.MAX_SAFE_INTEGER?(B.value=1,B.usablePrefix+=1):B.value+=1;const{value:e,usablePrefix:t}=B;return`${t}_${e}`}function at(e,t){const n=b(e,t);return n?n.level+1:1}function D(e,t){return t.metaMap.get(e)}function b(e,t){let n=t||Me(e);return(n==null?void 0:n.metaMap.get(e))||null}function me(e){return e&&e[ie]||""}function Me(e){const t=me(e);return Z.get(t)||null}function ee(e){const t=Me(e);return t&&t.metaMap.get(e)||null}function he(e,t){const n=ee(e),r=ee(t);if(!n&&!r)return!Object.is(e,t);const{self:o,modified:s,compareVer:l,ver:a,level:i}=n||{self:e,modified:!1,compareVer:!1,ver:"0",level:0},{self:f,modified:d,compareVer:c,ver:_,level:y}=r||{self:t,modified:!1,compareVer:!1,ver:"0",level:0};return o!==f||(l||c)&&(i===0||y===0)&&a!==_?!0:s||d}function lt(e,t,n=!0){const r=n?he:Object.is;return!((l,a)=>{for(let i in l)if(!(i in a))return!0;for(let i in a)if(r(l[i],a[i]))return!0;return!1})(e,t)}function Nt(e){const t=n=>{if(isPrimitive(n))return n;let r=n;if(Array.isArray(n)&&(r=n.slice(),r.forEach((o,s)=>{r[s]=t(o)})),isSet(n)){const o=Array.from(n);o.forEach((s,l)=>{o[l]=t(s)}),r=new Set(o)}return isMap(n)&&(r=new Map(n),r.forEach((o,s)=>{r.set(s,t(o))})),isObject(n)&&(r={},Object.keys(n).forEach(o=>{r[o]=t(n[o])})),r};return t(e)}function ut(e,t){const{parentType:n,fastModeRange:r}=t;if(Array.isArray(e))return{copy:e.slice(),fast:!1};const o=r==="array"&&n===S||r==="all";let s=e;return e&&K(e)&&(s=Object.assign({},e)),G(e)&&(s=new Map(e)),q(e)&&(s=new Set(e)),{copy:s,fast:o}}function ft(e,t,n){const{apiCtx:r,immutBase:o}=n;if(o)return{copy:e,fast:!1};const{copy:s,fast:l}=ut(e,n);return j(s,t,{apiCtx:r,fast:l}),{copy:s,fast:l}}function pt(e,t,n){const{copy:r,isArrOrderChanged:o}=e,{targetNode:s,key:l}=n;if(o){const a=r.findIndex(i=>i===t.copy);a>=0&&(r[a]=s);return}r[l]=s}function dt(e,t){return K(e)?me(e)===t:!0}function yt(e,t){const{debug:n}=t,r=new Map;t.newNodeMap.forEach(o=>{const{node:s,parent:l,key:a}=o,i=r.get(s);if(i){l[a]=i;return}const f=o;et(s,l,a,(d,c,_)=>{const y=b(d,t);if(y){const{modified:O,copy:g,self:M}=y,P=O?g:M;c[_]=P}}),f.target=l[a],r.set(s,f.target)}),e.scopes.forEach(o=>{const{modified:s,copy:l,parentMeta:a,key:i,self:f,revoke:d,proxyVal:c,isDel:_,isFast:y}=o;if(!l||(n&&(y?delete l[U]:delete l.__proto__[U]),!a))return d();const O=s?l:f,g=a.copy,M=a.selfType;if(M===A)return g.set(i,O),d();if(M===x)return g.delete(c),g.add(O),d();if(M===S)return pt(a,o,{targetNode:O,key:i}),d();if(_!==!0)return g[i]=O,d()}),e.scopes.length=0}function mt(e,t){const{self:n,copy:r,modified:o}=e;let s=n;return r&&o&&(s=e.copy),yt(e,t),s}function _e(e){e.rootMeta.scopes.push(e)}function ge(e,t,n){const{traps:r,parentType:o,fastModeRange:s,immutBase:l,apiCtx:a}=n,i=it(e,t,n),{copy:f,fast:d}=ft(t,i,{immutBase:l,parentType:o,fastModeRange:s,apiCtx:a});if(i.copy=f,i.isFast=d,l){const c=new Proxy(f,r);i.proxyVal=c,i.revoke=N}else{const c=Proxy.revocable(f,r);i.proxyVal=c.proxy,i.revoke=c.revoke}return a.metaMap.set(f,i),a.metaMap.set(i.proxyVal,i),i}function Mt(e,t){return e===S?!0:(qe[e]||[]).includes(t)}function ht(e,t){const{key:n,parentMeta:r,parent:o,parentType:s,fastModeRange:l,readOnly:a,apiCtx:i}=t;let f=e;if(a&&r&&!F(e)){const{copy:c,self:_}=r,y=_[n];if(f!==y){const O=i.metaMap.get(f);O&&(i.metaMap.delete(f),i.metaMap.delete(O.proxyVal)),c[n]=y,f=y}}const d=(c,_)=>{const y=_||"";if(T(c)||!c)return c;if(!r)throw new Error("[[ createMeta ]]: meta should not be null");if(!F(c)){if(r.newNodeStats[y]||c[k])return c;let g=D(c,i);return g||(g=ge(y,c,t),_e(g),r.selfType===A?o.set(y,g.copy):o[y]=g.copy),g.proxyVal}if(!Mt(s,y)||r.proxyItems)return c;let O=[];if(s===x){const g=new Set;o.forEach(M=>g.add(d(M))),Oe(g,r,{dataType:x,apiCtx:i}),O=j(g,r,{fast:l,apiCtx:i}),r.copy=O}else if(s===A){const g=new Map;o.forEach((M,P)=>g.set(P,d(M,P))),Oe(g,r,{dataType:A,apiCtx:i}),O=j(g,r,{fast:l,apiCtx:i}),r.copy=O}else s===S&&y!=="sort"&&(r.copy=r.copy||o.slice(),O=r.proxyVal);return r.proxyItems=O,c};return d(f,n)}function Ee(e,t){if(!K(e))return e;const n=D(e,t);return n?n.copy:e}function Oe(e,t,n){const{dataType:r,apiCtx:o}=n,s=e.delete.bind(e),l=e.clear.bind(e);if(e.delete=function(...i){return z(t),s(...i)},e.clear=function(...i){return z(t),l(...i)},r===x){const a=e.add.bind(e);e.add=function(...f){return z(t),a(...f)}}if(r===A){const a=e.set.bind(e),i=e.get.bind(e);e.set=function(...d){if(z(t),t.hasOnOperate){const c=d[1];t.rootMeta.execOnOperate("set",d[0],{mayProxyVal:c,value:c,parentMeta:t})}return a(...d)},e.get=function(...d){const c=i(...d);if(t.hasOnOperate){const _=b(c,o),y=_?_.copy||_.self:c;t.rootMeta.execOnOperate("get",d[0],{mayProxyVal:c,value:y,parentMeta:t,isChanged:!1})}return c}}}function _t(e){const{calledBy:t,parentMeta:n,op:r,parentType:o}=e;(["deleteProperty","set"].includes(t)||t==="get"&&(o===x&&Ge.includes(r)||o===S&&He.includes(r)||o===A&&Ye.includes(r)))&&z(n)}function Pe(e,t){const n=e.keyPath.slice();return n.push(t),n.join("|")}function te(e,t){const{op:n,key:r,value:o,calledBy:s,parentType:l,parentMeta:a,apiCtx:i}=t,f=Ee(o,i);if(!a){e[r]=f;return}const{self:d,copy:c}=a;_t({calledBy:s,parentMeta:a,op:n,key:r,parentType:l});const _=ae[l]||[];if(F(o)&&_.includes(n))return n==="slice"?d.slice:(We.includes(n)&&(a.isArrOrderChanged=!0),c?l===x||l===A?c[n].bind(c):c[n]:d[n].bind(d));if(!c)return f;const y=c[r],O=()=>{const M=b(y,i);M&&(M.isDel=!0)},g=()=>{const M=b(o,i);M&&M.isDel&&(M.isDel=!1,M.key=r,M.keyPath=a.keyPath.concat([r]),M.level=a.level+1,M.parent=a.copy,M.parentMeta=a)};if(s==="deleteProperty"){const M=b(o,i);M?M.isDel=!0:O();const P=c[r];T(P)||i.newNodeMap.delete(Pe(a,r)),delete c[r];return}T(f)||(a.newNodeStats[r]=!0,i.newNodeMap.set(Pe(a,r),{parent:c,node:f,key:r,target:null})),c[r]=f,O(),g()}function ne(e){if(T(e))return e;if(Array.isArray(e)&&e.length>0)return e.forEach(ne),Object.freeze(e);if(q(e)){const n=e;n.add=()=>n,n.delete=()=>!1,n.clear=N;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}if(G(e)){const n=e;n.set=()=>n,n.delete=()=>!1,n.clear=N;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}return Object.getOwnPropertyNames(e).forEach(n=>{const r=e[n];ne(r)}),Object.freeze(e)}const gt=["length","constructor","asymmetricMatch","nodeType","size"],Ce={};gt.forEach(e=>Ce[e]=1);const Et={[S]:1,[x]:1,[A]:1},re=new Map;function Ae(e){var t,n,r,o,s;const l=e||{},a=l.onOperate,i=!!a,f=l.customKeys||[],d=l.fastModeRange||le.fastModeRange,c=(t=l[ce])!==null&&t!==void 0?t:!1,_=(n=l.readOnly)!==null&&n!==void 0?n:!1,y=l.disableWarn,O=(r=l.compareVer)!==null&&r!==void 0?r:!1,g=(o=l.debug)!==null&&o!==void 0?o:!1,M=(s=l.autoFreeze)!==null&&s!==void 0?s:le.autoFreeze,P=ct(),v={metaMap:new Map,newNodeMap:new Map,debug:g,metaVer:P};Z.set(P,v);const Te=()=>(y||console.warn("can not mutate state at readOnly mode!"),!0),V=(L,R,m)=>{const{mayProxyVal:u,parentMeta:p,value:E,isCustom:h=!1}=m;let C=!1;if(!a)return{isChanged:C,mayProxyVal:u};const W=p||{},{selfType:I="",keyPath:Re=[],copy:Tt,self:we,modified:Dt,proxyVal:Rt}=W||{};let Fe=!1;m.isChanged!==void 0?C=m.isChanged:(ae[I]||[]).includes(R)?(Fe=!0,C=($e[I]||[]).includes(R)):L!=="get"&&(C=p?(Dt?Tt:we)[R]!==E:!0);let oe=null,se=!1;return a({immutBase:c,parent:we,parentType:I,parentProxy:Rt,op:L,replaceValue:be=>{se=!0,oe=be},getReplaced:()=>({isReplaced:se,replacedValue:oe}),isBuiltInFnKey:Fe,isChanged:C,isCustom:h,key:R,keyPath:Re,fullKeyPath:Re.concat(R),value:E,proxyValue:u}),{mayProxyVal:se?oe:u,isChanged:C}},De=(()=>{let L=!0;const R={get:(m,u)=>{if(ie===u)return P;const p=m[u];if(ze.includes(u))return F(p)?p.bind(m):p;if(u==="__proto__"||u==="toJSON"&&!ue(m,u))return p;let E=p;const h=D(m,v);if(f.includes(u))return V("get",u,{parentMeta:h,mayProxyVal:E,value:p,isChanged:!1,isCustom:!0}).mayProxyVal;const C=h==null?void 0:h.selfType;return Et[C]&&Ce[u]?h.copy[u]:(E=ht(p,{key:u,compareVer:O,parentMeta:h,parentType:C,ver:P,traps:R,parent:m,fastModeRange:d,immutBase:c,readOnly:_,apiCtx:v,hasOnOperate:i}),C===S&&Q(u)?V("get",u,{parentMeta:h,mayProxyVal:E,value:p}).mayProxyVal:Le[C]?(E=te(m,{op:u,key:u,value:p,metaVer:P,calledBy:"get",parentType:C,parentMeta:h,apiCtx:v}),V("get",u,{parentMeta:h,mayProxyVal:E,value:p}).mayProxyVal):V("get",u,{parentMeta:h,mayProxyVal:E,value:p}).mayProxyVal)},set:(m,u,p)=>{let E=p;const h=D(m,v);if(ye(p))if(dt(p,P)){if(E=Ee(p,v),E===m[u])return!0}else L=!1;if(_)return V("set",u,{parentMeta:h,isChanged:!1,value:E}),Te();if(h&&h.selfType===S){if(h.copy&&h.__callSet&&Q(u))return V("set",u,{parentMeta:h,value:E}),h.copy[u]=E,!0;h.__callSet=!0}let C=!1;return a?C=V("set",u,{parentMeta:h,value:E}).isChanged:C=(h.modified?h.copy:h.self)[u]!==p,C&&te(m,{parentMeta:h,key:u,value:E,metaVer:P,calledBy:"set",apiCtx:v}),!0},deleteProperty:(m,u)=>{const p=D(m,v),E=m[u];return _?(V("del",u,{parentMeta:p,isChanged:!1,value:E}),Te()):(V("del",u,{parentMeta:p,isChanged:!0,value:E}),te(m,{parentMeta:p,op:"del",key:u,value:"",metaVer:P,calledBy:"deleteProperty",apiCtx:v}),!0)},apply:function(m,u,p){return m.apply(u,p)}};return{createDraft:m=>{if(T(m))throw new Error("base state can not be primitive");let u=m;const p=D(m,v);if(p){if(c&&p.isImmutBase)return p.proxyVal;u=p.self}const E=ge("",u,{ver:P,traps:R,immutBase:c,readOnly:_,compareVer:O,apiCtx:v,hasOnOperate:i});return _e(E),E.execOnOperate=V,re.set(E.proxyVal,De.finishDraft),E.proxyVal},finishDraft:m=>{const u=D(m,v);if(!u)throw new Error("rootMeta should not be null!");if(u.level!==0)throw new Error("can not finish sub draft node!");if(u.isImmutBase)return m;let p=mt(u,v);return M&&L&&(p=ne(p)),Z.delete(P),p}}})();return De}function It(e){const t=getDraftMeta(e);return t?t.self:e}function Bt(e){const t=getDraftMeta(e);return t?deepCopy(t.copy||t.self):e}function Ot(e){return!e||T(e)||(e[k]=!0),e}const Pt={has:ue,noop:N,isObject:K,isMap:G,isSet:q,isFn:F,isPrimitive:T,isPromiseFn:pe,isPromiseResult:de,isSymbol:tt,isMardedRaw:nt,canBeNum:Q,isDraft:ye,isDiff:he,shallowCompare:lt,getDraftMeta:b,getDataType:fe},Ct=Be;function Se(e,t){return Ae(t).createDraft(e)}function ve(e){const t=re.get(e);if(!t)throw new Error("Not a Limu root draft or draft has been finished!");return re.delete(e),t(e)}function xe(e){if(!F(e))throw new Error("produce callback is not a function")}function At(e,t){if(pe(e)||de(t))throw new Error("produce callback can not be a promise function or result")}function Ve(e,t,n){xe(t);const r=Se(e,n),o=t(r);return At(t,o),ve(r)}function St(e,t,n){if(!t||!F(t)){const r=e,o=t;return xe(e),s=>Ve(s,r,o)}return Ve(e,t,n)}const vt=St,Ut=null;function Ht(e){return deepCopyFn(e)}function xt(e,t){return Ae(Object.assign(Object.assign({},t||{}),{readOnly:!0,[ce]:!0})).createDraft(e)}function Yt(e){conf.autoFreeze=e}function Gt(){return conf.autoFreeze}const Wt=null,Vt=Ot,kt=null}}]);
