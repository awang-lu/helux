!(function(){"use strict";var el=Object.defineProperty,tl=Object.defineProperties;var nl=Object.getOwnPropertyDescriptors;var St=Object.getOwnPropertySymbols;var ms=Object.prototype.hasOwnProperty,gs=Object.prototype.propertyIsEnumerable;var hs=(P,N,x)=>N in P?el(P,N,{enumerable:!0,configurable:!0,writable:!0,value:x}):P[N]=x,w=(P,N)=>{for(var x in N||(N={}))ms.call(N,x)&&hs(P,x,N[x]);if(St)for(var x of St(N))gs.call(N,x)&&hs(P,x,N[x]);return P},Y=(P,N)=>tl(P,nl(N));var Es=(P,N)=>{var x={};for(var b in P)ms.call(P,b)&&N.indexOf(b)<0&&(x[b]=P[b]);if(P!=null&&St)for(var b of St(P))N.indexOf(b)<0&&gs.call(P,b)&&(x[b]=P[b]);return x};var vs=(P,N,x)=>new Promise((b,z)=>{var ge=j=>{try{Ee(x.next(j))}catch(J){z(J)}},Ge=j=>{try{Ee(x.throw(j))}catch(J){z(J)}},Ee=j=>j.done?b(j.value):Promise.resolve(j.value).then(ge,Ge);Ee((x=x.apply(P,N)).next())});(self.webpackChunkhelux_docs=self.webpackChunkhelux_docs||[]).push([[3649],{73649:function(P,N,x){x.r(N),x.d(N,{$:function(){return Sf},action:function(){return mf},addMiddleware:function(){return Zf},addPlugin:function(){return Qf},atom:function(){return Ni},atomx:function(){return Ui},block:function(){return Ef},createShared:function(){return Pi},cst:function(){return qf},defineDeriveFnItem:function(){return ji},defineDeriveTask:function(){return Hi},defineMutateFnItem:function(){return Rf},derive:function(){return Yi},deriveDict:function(){return Gi},dynamicBlock:function(){return vf},emit:function(){return Mf},flush:function(){return Of},getActionLoading:function(){return $f},getAtom:function(){return Jf},getDeriveLoading:function(){return Wf},getMutateLoading:function(){return jf},getRawState:function(){return Xf},getSnap:function(){return zf},init:function(){return kf},isAtom:function(){return Lf},isDerivedAtom:function(){return Pf},isDerivedResult:function(){return Nf},isDiff:function(){return Gf},isDraft:function(){return Uf},isSharedState:function(){return xf},markRaw:function(){return Yf},model:function(){return If},modelFactory:function(){return wf},mutate:function(){return Af},mutateDict:function(){return Kf},on:function(){return Ff},produce:function(){return Hf},reactiveDesc:function(){return Cf},runDerive:function(){return $i},runDeriveTask:function(){return Wi},runMutate:function(){return Df},runMutateTask:function(){return _f},shallowCompare:function(){return Vf},share:function(){return Bi},sharex:function(){return Vi},signal:function(){return gf},storeSrv:function(){return Bf},sync:function(){return Tf},syncer:function(){return bf},useActionLoading:function(){return uf},useAtom:function(){return Ji},useAtomX:function(){return Zi},useDerived:function(){return ef},useEffect:function(){return ff},useGlobalForceUpdate:function(){return hf},useGlobalId:function(){return rf},useLayoutEffect:function(){return lf},useLocalForceUpdate:function(){return yf},useMutable:function(){return cf},useMutateLoading:function(){return af},useObject:function(){return pf},useOnEvent:function(){return sf},useReactive:function(){return Qi},useReactiveX:function(){return qi},useService:function(){return of},useStable:function(){return df},useWatch:function(){return tf},useWatchEffect:function(){return nf},watch:function(){return Xi},watchEffect:function(){return zi}});function b(e,t){e.includes(t)||e.push(t)}function z(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function ge(e){return Array.from(new Set(e))}function Ge(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function Ee(e,t){let n="";const r=e.length;for(let o=0;o<r;o++){const s=e[o];if(t.startsWith(s)){n=s;break}}return n}function j(e,t,n){if(!e)return[];const r=e(t,n);return Array.isArray(r)?r:[r]}var J=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),Cn=!1;function k(...e){}var Ss=k;function As(...e){return e}function ve(...e){return[]}function rl(...e){}var Ks=Object.prototype.toString,Ds="[object Map]";function ol(){return!(typeof window!="undefined"&&window.document)}function At(e){return Ks.call(e)===Ds}function On(e){return e===Number.MAX_SAFE_INTEGER}function ce(){return!(!Cn&&J.name!=="previewFrame"&&!J.BrowserFS)}function X(e){return e&&typeof e=="object"&&!Array.isArray(e)}function Ln(e){return e&&typeof e=="object"}function O(e){return typeof e=="function"}function sl(e){return Cn?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function Kt(e){return typeof e=="symbol"}function Dt(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&O(e.then)}function cl(e){try{return e.test,!1}catch(t){return!0}}function Re(){return typeof Proxy=="function"}function ae(e,t){var f;const{throwErr:n=!1,prefixLabel:r="",suffixLabel:o=", see details in console.",logErr:s=!0,alertErr:c}=t||{};let a=e,u=!1;if(e instanceof Error&&(u=!0,a=e.message),(c!=null?c:ce())&&e&&((f=J.alert)==null||f.call(J,`${r}${a}${o}`)),s&&console.error(e),n)throw u?e:new Error(String(e))}function Se(e,t=0){t===0?(console.error(e),ce()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function Te(e){return On(e)?1:e+1}var _s=!!Reflect,Rs=Object.prototype.hasOwnProperty;function Ts(e,t){return _s?Reflect.has(e,t):Rs.call(e,t)}function be(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function He(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function xn(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function Pn(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function ue(e,t){let n,r=e;return t.forEach(o=>{n=At(r)?Pn(r,o):r[o],r=n}),n}function Nn(e,t,n){let r=e;const o=t.length-1;t.forEach((s,c)=>{const a=At(r);if(c===o)return void(a?r.set(s,n):r[s]=n);r=a?Pn(r,s):r[s]})}function bs(){return Se("changing shared state is invalid"),!0}function al(e){return e}function _t(e,t){return`${t}/${e}`}function Rt(e){return e&&Re()}var Is=Object.defineProperty,Tt={};((e,t)=>{for(var n in t)Is(e,n,{get:t[n],enumerable:!0})})(Tt,{useEffect:()=>ks,useEffectLogic:()=>It,useForceUpdate:()=>Un,useLayoutEffect:()=>Fs,useObject:()=>Os,useObjectLogic:()=>Vn,useStable:()=>Bn});var ws=0,je=new Map,bt=0;function Ms(e,t){const n=()=>{const r=t();return()=>{je.delete(e),r&&r()}};if(function(r){bt||(bt=r)}(e),function(r){const o=je.get(r);o?o.count+=1:je.set(r,{count:1})}(e),bt%2!=0)return n();{const r=function(o){return je.get(o)}(e);if(r&&r.count>1)return n()}}function It(e,t,n){const{useState:r,useLayoutEffect:o,useEffect:s}=e.react,{isLayout:c,deps:a}=n,[u]=r(()=>++ws);(c?o:s)(()=>Ms(u,t),a)}function Fs(e,t,n){It(e,t,{isLayout:!0,deps:n})}function ks(e,t,n){It(e,t,{deps:n})}function Un(e){const[,t]=e.react.useState({});return()=>t({})}function Cs(e){const{data:t}=e.current;O(t)?e.current.wrap=(...n)=>e.current.data(...n):X(t)?e.current.wrap=function(n,r){if(!Re()){const s={};return Object.keys(n).forEach(c=>{const a=n[c];O(a)?s[c]=(...u)=>r.current.data[c](...u):Object.defineProperty(s,c,{get:()=>r.current.data[c],set(u){r.current.data[c]=u}})}),s}const o={};return new Proxy(n,{get(s,c){const a=s[c];return O(a)?be(o,c,(...u)=>r.current.data[c](...u)):a}})}(t,e):e.current.wrap=t}function Bn(e,t){const{useRef:n,useMemo:r}=e.react,o=n({data:t,wrap:{},inited:!1});return o.current.data=r(()=>t,[t]),o.current.inited||(Cs(o),o.current.inited=!0),o.current.wrap}function Vn(e,t,n,r){const{useState:o,useRef:s,useEffect:c}=e.react,[a]=o(t),u=Un(e),f=s({state:null,unmount:!1,shouldCopy:!0}),l=Bn(e,{setState(i){const d=f.current;if(d.unmount)return;let p;const{state:h}=d;n?(p=n(i,d.state||a),r&&p?(d.state=p,d.shouldCopy=!1):d.shouldCopy=!0):(p=(O(i)?i(h):i)||{},d.shouldCopy=!0),Object.assign(a,p||{}),u()},getLatestState(){const i=f.current;return i.shouldCopy&&(i.state=w({},a),i.shouldCopy=!1),i.state}});return c(()=>{const i=f.current;return i.unmount=!1,()=>{i.unmount=!0}},[f]),[a,l.setState,l]}function Os(e,t){return Vn(e,t)}function Ls(e){const t={},n={react:e},r=Tt;return Object.keys(Tt).forEach(o=>{t[o]=r[o].bind(null,n)}),t}var $=x(47622),xs=Object.defineProperty,Ps=(e,t)=>{for(var n in t)xs(e,n,{get:t[n],enumerable:!0})},Yn={};Ps(Yn,{$:()=>Ti,action:()=>Eo,addMiddleware:()=>cc,addPlugin:()=>fc,atom:()=>ri,atomx:()=>oi,block:()=>Ai,createShared:()=>Ri,cst:()=>bi,currentDraftRoot:()=>Nc,defineDeriveFnItem:()=>Du,defineDeriveTask:()=>Ku,defineMutateFnItem:()=>bu,derive:()=>Ko,deriveDict:()=>Au,dynamicBlock:()=>is,emit:()=>yc,flush:()=>an,getActionLoading:()=>Nu,getAtom:()=>Zn,getDeriveLoading:()=>Qa,getMutateLoading:()=>xu,getRawState:()=>Ac,getSnap:()=>dr,init:()=>sc,isAtom:()=>De,isDerivedAtom:()=>ie,isDerivedResult:()=>Qs,isDiff:()=>Di,isDraft:()=>_i,isSharedState:()=>Zs,markRaw:()=>$.Xl,mutate:()=>bo,mutateDict:()=>Dn,on:()=>hc,produce:()=>$.Uy,reactiveDesc:()=>Pr,runDerive:()=>Xa,runDeriveTask:()=>za,runMutate:()=>Ro,runMutateTask:()=>To,shallowCompare:()=>Ki,share:()=>qo,sharex:()=>es,signal:()=>fs,storeSrv:()=>Gu,sync:()=>si,syncer:()=>ci,useActionLoading:()=>Uu,useAtom:()=>Io,useAtomX:()=>wo,useDerived:()=>Rn,useGlobalForceUpdate:()=>Co,useGlobalId:()=>Lu,useLocalForceUpdate:()=>Po,useMutable:()=>No,useMutateLoading:()=>Pu,useOnEvent:()=>Bu,useReactive:()=>bn,useReactiveX:()=>Uo,useService:()=>Yu,useWatch:()=>ju,useWatchEffect:()=>$u,watch:()=>du,watchEffect:()=>pu});var Gn="4.1.6",Ns=$.TT,wt={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},Mt={NO:"no",PRIVATE:"private",GLOBAL:"global"},Hn=0,jn=Symbol,Us=typeof jn=="function";function ee(e){return Us?jn(e):(Hn+=1,`__HELUX_SYMBOL_${Hn}__`)}var Bs="__proto__",Vs=Re(),Ys=ee("HeluxUndefined"),$n=ee("HeluxMutateFnItem"),$e=ee("HeluxFnKey"),We=ee("HeluxSharedKey"),Wn=ee("HeluxReactiveMeta"),Ft=ee("HeluxIsBlock"),Ae=ee("HeluxIsAtom"),Ie=ee("HeluxIsDerivedAtom"),Xe=[We,Ae,Ie,Ft],ze="SingleMutate",Gs="HeluxGlobalLoading",Hs=6,js=!0,Xn=2e3,$s=20,we="1",kt="2",Je=1,Ze=2,zn=3,Ke="|",Qe={TASK:"task",MAY_TRANSFER:"may_transfer"},te={STATIC:"static",HOOK:"hook"},Z={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},Ws="derive",Jn="watch",qe="Object",Xs="Map",zs="Array",Js="Other",H={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function De(e){var t;return e&&(t=e[Ae])!=null?t:!1}function Zs(e){return e?e[Ae]!==void 0:!1}function ie(e){return e&&e[Ie]||!1}function Qs(e){return e?e[Ie]!==void 0:!1}function Zn(e){return De(e)||ie(e)?e.val:e}function qs(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function ec(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function tc(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function nc(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function Qn(){const e={};return{on:(t,n)=>{be(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(o=>o(...n))},off:(t,n)=>{const r=e[t]||[],o=r.findIndex(s=>s===n);o>=0&&r.splice(o,1)},canEmit:t=>e[t]}}function qn(){const e={VER:Gn,LIMU_VER:$.TT,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:Qn(),userBus:Qn(),mod:{},middlewares:[],plugins:[],sharedScope:nc(),fnScope:qs(),insScope:tc(),blockScope:ec(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var et={},er=!1,tr=null,nr=!1;function V(){return et.ctx||{}}function rc(){return et}function rr(e){et=e.ROOT,tr=e.api,er=e.inited}function oc(){return{ROOT:et,inited:er,API:tr}}function sc(e){if(nr)return!1;nr=!0;const{isRootRender:t=!0}=e;return V().isRootRender=t,!0}function cc(e){const{middlewares:t}=V();t.push(e)}function ac(e,t,n,r){const{middlewares:o}=V();if(!o.length)return;const s={},{sharedKey:c,moduleName:a,forAtom:u}=e,l={forAtom:u,draftRoot:t,draft:n,sharedKey:c,moduleName:a,setData:(i,d)=>s[i]=d,data:s,idx:0,sn:r};o.forEach((i,d)=>{i(Y(w({},l),{idx:d}))})}var{ON_DATA_CHANGED:Ct,ON_SHARE_CREATED:or,ON_ERROR_OCCURED:uc}=wt,ic=[Z.GLOGAL_LOADING,Z.PRIVATE_LOADING];function fc(e){const{plugins:t,bus:n}=V();t.push(e);const r={on:(o,s)=>n.on(o,s),onStateChanged:o=>n.on(Ct,o)};e.install(r)}function lc(e,t){const{bus:n}=V();if(n.canEmit(Ct)){const{from:r,desc:o}=t,{forAtom:s,sharedKey:c,moduleName:a,snap:u,usefulName:f,stateType:l}=e;let i;ic.includes(l)?i=`${f}/setState`:i=`${f}@${r||"Api"}/${o}`,n.emit(Ct,{forAtom:s,snap:u,sharedKey:c,moduleName:a,usefulName:f,type:i})}}function dc(e){const{bus:t}=V();if(t.canEmit(or)){const{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c}=e,a=`${c}@FactoryApi/createShared`;t.emit(or,{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c,type:a})}}function sr(e,t,n){const{bus:r}=V();if(!r.canEmit(t))return!1;const{sharedKey:o,moduleName:s}=e;return r.emit(t,{moduleName:s,sharedKey:o,data:n}),!0}function cr(e,t){sr(e,uc,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function pc(){const{userBus:e}=V();return e}function yc(e,...t){const{userBus:n}=V();n.emit(e,...t)}function hc(e,t){const{userBus:n}=V();return n.on(e,t),()=>n.off(e,t)}function mc(e,t){return e.__proto__=t,e}function gc(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var Ot=Object.setPrototypeOf||({__proto__:[]}instanceof Array?mc:gc);function Ec(e){const t=Object.create(null);return Ot(t,w({},Object.prototype)),e&&Object.assign(t,e),t}function ar(e){if(O(e))return;const t=Object.create(null);return Ot(t,Object.prototype),Ot(e,t),e}function ur(e,t,n){return e[t]=n,!0}function ir(e,t){return e[t]}function Me(e,t){const{set:n=ur,get:r=ir,obj:o={}}=t||{};return Object.keys(e).forEach(s=>{Object.defineProperty(o,s,{enumerable:!0,configurable:!1,set:function(c){return n(e,s,c)},get:function(){return r(e,s)}})}),o}function fe(e,t){const{set:n=ur,get:r=ir}=t||{};if(Re())return new Proxy(e,{set(c,a,u){return n(c,a,u)},get(c,a){return r(c,a)}});const o=Ec();return Me(o,{obj:o,set:n,get:r})}var Fe=V();function tt(e){const n=V()[e];return Fe[e]=n,n}function Q(){return Fe.blockScope||tt("blockScope")}function U(){return Fe.fnScope||tt("fnScope")}function ne(){return Fe.sharedScope||tt("sharedScope")}function fr(){return Fe.insScope||tt("insScope")}function lr(){const{INTERMAL_MAP:e}=ne();return e}function vc(e,t){if(!e||!ce()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:o}=ne();let s=[],c=!1;if(n.forEach(a=>{a.moduleName===e&&a.loc===t&&a.stateType===Z.USER_STATE&&s.push(a.sharedKey)}),s.length>1){const a=s[0],u=n.get(a);n.delete(a),u&&(r.delete(u.sharedKey),o.delete(u.rawState))}return c}function ke(e){return lr().get(e)}function B(e){const t=re(e);return ke(t)}function Sc(e,t){const n=lr(),r=re(e);n.set(r,t)}function Ac(e){return B(e).rawState}function dr(e,t=!0){const n=B(e);return t?n.prevSnap:n.snap}function re(e){return e&&(e[We]||ne().STATE_SHARED_KEY_MAP.get(e))||0}function Lt(e){let t={state:{},stateRoot:{},isAtom:!1};if(!e)return t;const n=B(e);if(n){const{sharedState:r,sharedRoot:o}=n;t={state:r,stateRoot:o,isAtom:n.forAtom}}return t}function Kc(e){const t=ne(),{STATE_SHARED_KEY_MAP:n}=t,r=Te(t.keySeed);return n.set(e,r),t.keySeed=r,r}function Dc(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=ne();n.set(e,t),r.set(t,e)}function _c(e){return ne().SHARED_KEY_STATE_MAP.get(e)}function Rc(e,t){const{rootState:n,ctx:r}=rc(),{moduleName:o,usefulName:s}=t,c=n[s],a=B(c);if(o&&a&&a.loc!==t.loc){const u=`
loc1:${a.loc} 
loc2:${t.loc}`;return Se(`only-dev-mode tip: moduleName ${o} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+u)}n[s]=e,r.mod[s]=B(e)}var Tc={innerSetState:k};function pr(e,t){const{rawState:n,forAtom:r}=e,o=new Map,s={},c={},a=[],u=w({},n);let f=u;return r&&(f=n.val),Y(w(w({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:k,syncer:k,snap:u,prevSnap:u,rawStateVal:f},e),t),{insCtxMap:o,key2InsKeys:s,id2InsKeys:c,recordId(l,i){if(!l)return;const d=be(c,l,[]);b(d,i)},delId(l,i){l&&z(c[l]||[],i)},recordDep(l,i){const d=be(s,l,[]);b(d,i)},delDep(l,i){z(s[l]||[],i)},mapInsCtx(l,i){o.set(i,l)},delInsCtx(l){o.delete(l)},extra:{},loadingInternal:Tc,level1ArrKeys:a})}var bc={Mutate:"",Reactive:"r",[te.STATIC]:"s",[te.HOOK]:"h"};function Ic(){const e=fr(),t=Te(e.keySeed);return e.keySeed=t,t}function wc(){const e=Q(),{keySeed:t,keyPrefix:n}=e,r=Te(t);e.keySeed=r;let o=n;return On(t)&&(o=Te(n),e.keyPrefix=o),`${o}_${r}`}function Mc(){const e=V(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function xt(e){const t=bc[e],r=U().keySeed,o=Te(r[e]);return r[e]=o,`${t}${o}`}function Fc(){return xt("Reactive")}var{MAY_TRANSFER:kc}=Qe,{SET_STATE:Cc,REACTIVE:Oc}=H,Lc=()=>({isReplaced:!1,replacedValue:null}),xc=()=>{},Pc=Nt({isFake:!0});function yr(e,t,n=k){const{desc:r="",onRead:o,from:s=Oc,depKeys:c=[],isTop:a=!1,expired:u=!1,insKey:f=0}=t;return{draft:e,finish:n,modified:!1,expired:u,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:k,data:[],isTop:a,key:"",fnKey:"",depKeys:c,writeKeys:[],desc:r,onRead:o,from:s,insKey:f}}function Pt(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:o=Cc,enableDep:s=!1,handleCbReturn:c=!0,sn:a=Mc(),isFirstCall:u=!1,desc:f="",onRead:l}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:c,draftVal:null,from:o,isReactive:r,enableDep:s,sn:a,isFirstCall:u,desc:f,onRead:l}}function Ce(e,t,n){const{isChanged:r=!0,parentKeyPath:o=[],op:s="set",parentType:c="Object"}=n,a=o.slice();return a.push(e),{isChanged:r,isCustom:!1,op:s,immutBase:!1,key:e,value:t,proxyValue:t,parentType:c,keyPath:o,fullKeyPath:a,isBuiltInFnKey:!1,replaceValue:k,getReplaced:Lc}}function Nt(e){const i=e||{},{desc:t="",fn:n=k,task:r=xc,depKeys:o=[],writeKeys:s=[],deps:c=ve,isFake:a=!1,onlyDeps:u=!1}=i,f=Es(i,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return w({fn:n,task:r,deps:c,oriDesc:"",onlyDeps:u,desc:t,depKeys:o,writeKeys:s,checkDeadCycle:void 0,watchKey:"",isFake:a,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}},f)}function hr(){const e={fnKey:"",fn:k,subFnInfo:Pc,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:k,deps:ve,status:{loading:!1,err:null,ok:!0},stateRoot:{},isStateAtom:!1,forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:Je,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:we,proxyResult:{},updater:k,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:k},asyncType:kc,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var mr={draftRoot:{val:null},isFake:!0,isAtom:!0},gr=Pt({}),nt=yr(!0,{expired:!0}),ul=Nt(),Er=pr({rawState:{},forAtom:!1,usefulName:""},{}),vr=hr(),rt=mr,Ut=gr,Sr="",Bt=new Map,Vt=new Map,Yt=new Map,Gt=k,Ht=[],jt="";function Nc(){return rt}var Oe={current:()=>jt,set:e=>jt=e,del:()=>jt=""},$t={current:()=>Gt,set:e=>Gt=e,del:()=>Gt=k},Le={current:e=>Vt.get(e)||"SetState",set:(e,t)=>Vt.set(e,t),del:e=>Vt.delete(e)},xe={current:()=>Ht,set:e=>Ht=e,del:()=>Ht=[]},oe={current:()=>Yt.get(Sr)||nt,markUsing:e=>Sr=e,set:(e,t)=>Yt.set(e,t),del:e=>Yt.delete(e)},Wt={current:e=>Bt.get(e),set:(e,t)=>Bt.set(e,t),del:e=>Bt.delete(e)},ot={current:()=>rt,set:(e,t)=>{Object.assign(rt,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>rt=mr},Xt={current:()=>Ut,set:e=>Ut=e,del:()=>Ut=gr};function zt(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=U();return e[0]==="s"?t:n}function Uc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=U();He(n,e,[]).push(t)}function Bc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=U(),r=n.get(e);r&&z(r,t)}function Vc(e){const{DEPKEY_FNKEYS_MAP:t}=U(),{depKeys:n,fnKey:r}=e;n.forEach(o=>{const s=t.get(o)||[];z(s,r)})}function Ar(e,t){const{FNKEY_STATIC_CTX_MAP:n}=U(),{fnKey:r,prevLevelFnKeys:o}=e;o.forEach(s=>{var a;const c=(a=n.get(s))==null?void 0:a.nextLevelFnKeys;c&&(t?b(c,r):z(c,r))})}function Yc(){const{FNKEY_HOOK_CTX_MAP:e}=U();ce()&&e.forEach(t=>{t.isExpired=!0})}function Kr(e,t,n){const r=n||xt(t);return O(e)?e[$e]=r:(ar(e),e.__proto__[$e]=r),r}function Dr(e){return O(e)?e[$e]||"":X(e)&&e.__proto__[$e]||""}function le(e){return zt(e).get(e)}function Jt(e){return zt(e).get(e)||vr}function Pe(e){const t=Dr(e);return le(t)||null}function st(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r}=U();return{fnCtx:e?le(e):null,depKeys:t,isIgnore:r,runningSharedKey:n}}function Gc(){return U().runningFnKey}var{USER_STATE:Hc}=Z;function jc(e,t=8){let n="";if(ce()&&e)try{throw new Error("loc")}catch(r){const o=r.stack.split(`
`),s=o[1]||"";s.includes("webpack-internal")||s.includes("/node_modules/")?n=o.slice(0,16).join(" -> "):n=o.map(a=>a.substring(0,a.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function _r(e){const[t,n]=e.split("/"),r=n.split(Ke);return{sharedKey:Number(t),keyPath:r,depKey:e}}function Rr(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",o=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:o,sharedKey:t}}function W(e,t){try{return _t(e.join(Ke),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function $c(e,t){const{snap:n,prevSnap:r,stateType:o}=e;if(Hc!==o)return!0;const{keyPath:s}=_r(t);try{const c=ue(n,s),a=ue(r,s);return c!==a}catch(c){return!0}}function Wc(e,t){return Re()?(0,$.OA)(e,{onOperate:t,compareVer:!0}):fe(e,{get(n,r){const o=n[r],s=Ce(r,o,{isChanged:!1,parentKeyPath:[]});return t(s),o}})}function Xc(e,t){if(t!==void 0){if(e)return{val:t};if(X(t))return t}}function zc(e,t,n){const r=O(t)?t(n):t;return Xc(e,r)}function ct(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:o}=e.getReplaced();o&&(n=r)}return n}function Tr(e){return[zs,Xs].includes(e)}function Jc(e){return Array.isArray(e)||At(e)}var{isObject:de,getDataType:br}=$.limuUtils;function Zt(e,t){return typeof e=="boolean"?e:t}function Ir(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(Ke);return`${e}${Ke}${r[0]}`}function Zc(e,t){Ee(e,t)||b(e,t)}var Qt=new Map;function wr(e,t){let n=!1;const{depKey:r,keyPath:o,sharedKey:s}=e,{stopDepInfo:c,level1ArrKeys:a,recordCb:u}=t,f=Qt.get(r);if(f)return u(f),!0;const{keys:l,isArrDict:i,depth:d,arrKeyStopDcit:p,stopArrDep:h}=c,E=Ee(a,r),y=o.length>d;if(y||E){let g="",A=d;return E&&(A=d+1,p[E]===!1||h&&(y?g=W(o.slice(0,A),s):g=Ir(E,r))),g||(g=W(o.slice(0,A),s)),E||Qt.set(r,g),u(g),!0}const m=String(s);for(const g of l){if(!r.startsWith(g)||g===m)continue;const A=i[g],_=A?Ir(g,r):g;A||Qt.set(r,_),u(_),n=!0;break}return n}function qt(e,t){const n=Q(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:o,KEY_CTX_MAP:s,isDynamic:c}=n,u=(c?o:s).get(r);if(u){const{results:f,depKeys:l}=u;t?b(f,t):e.forEach(i=>b(l,i))}}}function at(e,t){const n=ne(),{COMPARE_MAP:r}=n;let o=r.get(t);return o!==void 0?o:e.sharedKeyStr===t?n.isStateChanged:(o=$c(e,t),r.set(t,o),o&&(n.isStateChanged=!0),o)}function Mr(e,t,n){if(t.includes(n)&&at(e,n))return!0;let r=!1;for(const o of t)o.startsWith(n)&&at(e,o)&&(r=!0);return r}function Qc(){const e=ne();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function en(e=!0){const t=U();t.isIgnore=e}function _e(e,t){const{fnCtx:n,depKeys:r,isIgnore:o}=st(),s=t.specificCtx||n;if(!s){$t.current()(e);return}const{DEPKEY_FNKEYS_MAP:c}=U(),{belongCtx:a,sharedKey:u}=t;if(u&&b(s.depSharedKeys,u),n&&a){n.isFirstLevel=!1,a.isAsync&&(n.isAsync=!0);const l=a.fnKey;b(s.prevLevelFnKeys,l),b(a.nextLevelFnKeys,n.fnKey)}const{fnKey:f}=s;e.forEach(l=>{if(Bs===l||o)return;n&&b(r,l);const i=He(c,l,[]);b(i,f)})}function tn(e){e&&e.depKeys.forEach(t=>_e([t],{specificCtx:e}))}function Fr(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=U(),{fnKey:r}=e;t.set(r,e),Ar(e,!0);let o=n.get(r);o?o.c=2:(o={c:1,t:Date.now(),prev:0},n.set(r,o));const{c:s}=o;if(s===2){const c=le(r);tn(c)}}function kr(e){let t="";return e.depSharedKeys.forEach(n=>{var o;const r=((o=ke(n))==null?void 0:o.ver)||0;t+=`${r}_`}),t}function qc(e,t,n){const{DEPKEY_FNKEYS_MAP:r}=U(),o=r.get(t)||[],s=[],c=[];return o.forEach(a=>{const u=le(a);if(u&&Mr(e,u.depKeys,t)){u.isFirstLevel&&s.push(a),u.isAsync&&c.push(a);const f=n[a];n[a]=f===void 0?1:f+1}}),{firstLevelFnKeys:s,asyncFnKeys:c}}function nn(e){Vc(e),Ar(e)}function ea(){const{FNKEY_HOOK_CTX_MAP:e}=U();if(e.size>=$s){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:o,fnKey:s}=n;[Je,zn].includes(r)&&t-o>Xn&&(nn(n),e.delete(s))})}}function rn(e,t,n,r,o,s=!1,c=!1){const a=Q();a.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:o,isDerivedResult:s,isDerivedAtom:c}}function ta(){return Q().latest}function Cr(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=Q();return e?t:n}function Or(){return Se("changing shared state is invalid"),!0}function ut(e,t,n,r,o){return r===Ae?e?t:!1:r===We?n:o}function on(e,t,n){e.replaceValue(ut(e.keyPath.length===0,t,n,e.key,e.value))}function na(e){let t={};const{rawState:n,sharedKey:r,forAtom:o,onRead:s,isPrimitive:c,stopDepth:a}=e,u=(l,i)=>{const d=W(l,r);_e([d],{sharedKey:r}),qt([d]),rn(r,i,t,d,l)};if(Vs)t=(0,$.OA)(n,{customKeys:Xe,onOperate:l=>{const{isBuiltInFnKey:i,isCustom:d}=l;if(d)return on(l,o,r);if(!i){const{fullKeyPath:p}=l,h=ct(l,s);u(p,h)}},compareVer:!0});else{const l=(i,d,p)=>Me(i,{set:Or,get:(h,E)=>{const y=h[E];if(Xe.includes(E))return ut(d===1,o,r,E,y);const m=Ce(E,y,{isChanged:!1,parentKeyPath:p});if(d<a&&de(y))return l(y,d+1,m.fullKeyPath);const g=ct(m,s);return u(m.fullKeyPath,g),g}});t=l(n,1,[])}let f=t;return o&&(c?f=n.val:f=fe(n,{set:Or,get:(l,i)=>t.val[i]})),Dc(r,t),{sharedRoot:t,sharedState:f}}var Lr=null;function sn(){return Lr}function ra(e,t){const n=V();let r=n.globalEmpty;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:Z.GLOGAL_EMPTY}),s=B(o);n.globalEmpty=o,n.globalEmptyInternal=s}return Lr=r,r}function cn(e){const{GID_INSKEYS_MAP:t}=U();return He(t,e,[])}function oa(){return V().globalEmptyInternal}function xr(e,t){if(!e)return;const n=cn(e);b(n,t)}function sa(e,t){if(!e)return;const n=cn(e);z(n,t)}var{REACTIVE:ca}=H,Ne=new Map;function aa(e){return!!(e&&!e.expired&&e.modified)}function ua(e){const{sharedKey:t}=e;e.expired=!0,oe.del(e.key);const n=Le.current(t);return Le.del(t),e.finish(null,{desc:n})}function Pr(e,t){const n=re(e);return t&&Le.set(n,t),n}function an(e,t){const n=re(e);Ue(n,t)}function ia(){const e=oe.current();e.isTop&&Ue(e.sharedKey,e.desc)}function Ue(e,t){const n=Ne.get(e);aa(n)&&(t&&Le.set(e,t),ua(n))}function fa(e){const t=Ne.get(e)||nt;t.expired=!0}function la(e,t){const n=Ne.get(e)||nt;n.modified=!0,n.nextTickFlush(t)}function da(e,t){const{from:n=ca,onRead:r}=t,{finish:o,draftRoot:s}=e.setStateFactory({isReactive:!0,from:n,handleCbReturn:!1,enableDep:!0,onRead:r}),c=yr(s,t,o);return c.key=Fc(),c.sharedKey=e.sharedKey,c.nextTickFlush=a=>{const{expired:u,hasFlushTask:f}=c;u||(c.data=[a]),f||(c.hasFlushTask=!0,Promise.resolve().then(()=>{const[l]=c.data;Ue(e.sharedKey,l)}))},c}function Nr(e,t,n){const{sharedKey:r}=e,{insKey:o=0,from:s}=t;let c=Ne.get(r)||nt;c.expired&&(c=da(e,{isTop:!0,from:s}),Ne.set(r,c),oe.set(c.key,c),c.fnKey=Oe.current()),oe.markUsing(c.key),c.onRead=o?t.onRead:void 0,c.insKey=o;const{draft:a}=c;return{val:n?a.val:a,meta:c}}function un(e,t){let n={},r={};const{rawState:o,deep:s,forAtom:c,isPrimitive:a,sharedKey:u}=e;if(Rt(s)){const f={[We]:u,[Ae]:c},l=(d,p,h)=>{const{val:E}=Nr(e,t,d);return E[p]=h,!0},i=(d,p,h)=>{const E=h[p];if(E!==void 0)return E;const{val:y,meta:m}=Nr(e,t,d);return Wn===p?m:y[p]};if(n=new Proxy(o,{set:(d,p,h)=>l(!1,p,h),get:(d,p)=>i(!1,p,f)}),r=n,c){const d=Y(w({},f),{[Ae]:!1});r=a?o.val:new Proxy(o.val,{set:(p,h,E)=>l(!0,h,E),get:(p,h)=>i(!0,h,d)})}}else n=o,r=o.val;return{draftRoot:n,draft:r}}function pa(e){const{UNMOUNT_INFO_MAP:t}=fr(),{insKey:n,readMap:r,internal:o}=e;o.mapInsCtx(e,n);let s=t.get(n);s?(s.c=2,s.prev=n-1):(s={c:1,t:Date.now(),prev:0},t.set(n,s));const{c}=s;c===2&&Object.keys(r).forEach(a=>{o.recordDep(a,n)})}function Ur(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(o=>r.delDep(o,n)),r.delInsCtx(n)}function ya(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function ha(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function Br(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:o}=n,s=Jc(o);s&&Zc(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,s)}function fn(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:o}=e;return(t?r:n).concat(o)}function ma(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===Je){Date.now()-r>Xn?Ur(e):e.needEFUpdate=!0;return}t()}function Vr(e){const{internal:t,isReactive:n,insKey:r}=e,{rawState:o,isDeep:s,sharedKey:c,onRead:a,forAtom:u}=t;if(s){const f=l=>{const{isBuiltInFnKey:i,key:d}=l;if(i)return;if(Kt(d))return on(l,u,c);const{fullKeyPath:p,keyPath:h,parentType:E}=l,y=ct(l,a),g={depKey:W(p,c),keyPath:p,parentKeyPath:h,sharedKey:c};Br(e,g,{parentType:E,rawVal:y})};if(n){const{draft:l,draftRoot:i}=un(t,{onRead:f,insKey:r});e.proxyState=i,e.proxyStateVal=l}else e.proxyState=(0,$.OA)(o,{onOperate:f,compareVer:!0})}else e.proxyState=fe(o,{set:()=>(Se("changing shared state is invalid"),!0),get:(f,l)=>{const i=f[l];if(Kt(l))return ut(!0,u,c,l,i);const d=ct(Ce(l,i,{isChanged:!1,parentKeyPath:[]}),a),p=_t(l,c),h=de(f)?qe:Js;return Br(e,{depKey:p,keyPath:[l],sharedKey:c},{parentType:h,rawVal:d}),d}})}function ga(e){var C;const{updater:t,sharedState:n,id:r="",globalId:o="",collectType:s="every",deps:c,pure:a=!0,arrDep:u=!0,isReactive:f=!1}=e,l=u&&(C=e.arrIndexDep)!=null?C:!0,i=B(n);if(!i)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=Ic(),{rawState:p,isDeep:h,ver:E,ruleConf:y,level1ArrKeys:m,forAtom:g,sharedKey:A,sharedKeyStr:_,snap:I}=i,{stopDepInfo:S}=y,R={readMap:{},delReadMap:{},pure:a,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:h,isReactive:f,insKey:d,internal:i,rawState:p,sharedState:n,sharedKey:A,proxyState:{},proxyStateVal:{},updater:t,mountStatus:Je,renderStatus:we,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:E,id:r,globalId:o,collectType:s,canCollect:s!=="no",isFirstRender:!0,subscribe:v=>{v()},extra:{},getDeps:()=>fn(R,!0),renderInfo:{isAtom:g,setDraft:i.insSetDraft,time:Date.now(),sn:0,snap:I,insKey:d,getDeps:()=>fn(R,!0),getPrevDeps:()=>fn(R,!1)},recordDep:(v,K,T)=>{let D=v.depKey;wr(v,{stopDepInfo:S,level1ArrKeys:m,recordCb:Ye=>{D=Ye}});const{renderStatus:M,fixedDepKeys:G}=R;if(M===kt)return;const{readMap:F,insKey:L,currentDepKeys:q,delReadMap:Et}=R;_e([D],{}),Gc()&&(z(q,D),b(R.fixedDepKeys,D));const ps=()=>{F[D]=1,i.recordDep(D,L),G.includes(D)||b(q,D)};if(!F[D]&&!Et[D]){const{parentKeyPath:Ye}=v;if(a&&K===qe&&Ye){const vt=Ye.length?W(Ye,A):_;F[vt]&&(delete F[vt],Et[vt]=1,z(q,vt))}const ys=Tr(K);if(ys){l&&ps();return}(!T||!ys&&u)&&ps()}}};if(o&&xr(o,d),Vr(R),i.mapInsCtx(R,d),i.recordId(r,d),O(c)){const v=g?R.proxyState.val:R.proxyState,K=j(c,v),T=R.getDeps().slice();K.includes(v)&&T.push(i.rootValKey),R.fixedDepKeys=T}return R}function Yr(e){const{result:t,forAtom:n}=e;e.proxyResult=fe(t,{set:()=>(Se("changing derived result is invalid"),!1),get:(r,o)=>Ie===o?n:(we===e.renderStatus&&tn(e),t[o])})}function Ea(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:o,isReactive:s}=e,{sharedKey:c,sharedKeyStr:a,insSetState:u,forAtom:f}=n;r.snap=n.snap,r.time=Date.now();const l=f?t.val:t;return e.isFirstRender&&(e.rootVal=l,Wt.set(e.rootVal,e)),!f&&o&&e.recordDep({depKey:a,keyPath:[],sharedKey:c},qe),[s?t:l,u,r]}function va(e,t){if(t&&!De(e))throw new Error("useAtom only accept atom")}function Sa(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,Vr(e))}function Aa(e){e.mountStatus=Ze;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),xr(n,r),pa(e)}function Ka(e){e.mountStatus=zn;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),sa(n,r),Ur(e)}function Da(e,t){const n=B(t).sharedKey;return e.internal.sharedKey!==n}function it(e,t,n,r){if(V().isRootRender)try{const o=r||n;e.react.useSyncExternalStore(t,n,o)}catch(o){console.error(o)}}var _a=null;function Gr(e,t,n){const{hookImpl:r,react:o}=e,s=r.useForceUpdate(),c=o.useRef({ctx:_a});let a=c.current.ctx;return(!a||Da(a,t))&&(a=ga(w({updater:s,sharedState:t},n)),c.current.ctx=a),a}function Hr(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Wt.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),Aa(t),()=>{Ka(t)}),[t])}function Ra(e,t,n,r){n.renderStatus=we,ha(n),it(e,n.subscribe,()=>B(t).snap),e.react.useEffect(()=>{n.renderStatus=kt,n.isFirstRender=!1,ya(n)})}function ln(e,t,n={}){const r=Gr(e,t,n);return it(e,r.subscribe,()=>B(t).snap),Hr(e,r),r}function ft(e,t,n={}){const{forAtom:r}=n;va(t,r);const o=Gr(e,t,n);return Ra(e,t,o,n),Hr(e,o),Sa(o),{tuple:Ea(o),insCtx:o}}function jr(e,t){const{forAtom:n,label:r,strict:o=!1}=t||{};let s;if(typeof e=="number"?s=ke(e):s=B(e),!s&&e){const a=e[Wn];s=ke(a==null?void 0:a.sharedKey)}let c=r?`[[${r}]] err:`:"err:";if(!s)if(o)ae(`${c} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!s.forAtom&&ae(`${c} expect a shared but recived a atom`,{throwErr:!0}),!n&&s.forAtom&&ae(`${c} expect a atom but recived a shared`,{throwErr:!0})),s}function pe(e,t){return jr(e,Y(w({},t||{}),{strict:!0}))}var{MUTATE:Ta,LOADING:ba}=H,{GLOGAL_LOADING:Ia,PRIVATE_LOADING:wa}=Z,{PRIVATE:Ma,GLOBAL:Fa}=Mt,$r={},ka={},Ca={time:0,sn:0,getDeps:ve,getPrevDeps:ve,insKey:0,setDraft:k,isAtom:!1},Oa=[ye($r,ka,Ta),k,Ca];function La(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:o,moduleName:s}=n,c={};Object.keys(o).forEach(f=>{c[f]={loading:!1,err:null,ok:!0}});const a=s?`${s}@Loading`:"";return e({apiCtx:r,rawState:c,isLoading:!0,stateType:wa},{moduleName:a}).state}var Wr=null;function xa(){return Wr}function Xr(){return V().globalLoadingInternal}function Pa(e,t){const n=V();let r=n.globalLoading;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},stateType:Ia},{moduleName:Gs}),s=B(o);n.globalLoadingInternal=s,n.globalLoading=o}return Wr=r,r}function dn(e,t){let n=t;return Kt(t)&&(n=t.toString()),`${e}>${n}`}function zr(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(o=>{o[t]=n},{from:ba}),n.err&&(sr(e,wt.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function ye(e,t,n){let r=e[n];return r||(r=fe(t,{get(o,s){const c=dn(n,s);return o[c]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function Be(e,t){const{internal:n,from:r}=t,{stateType:o,recordLoading:s}=n,c=Z.USER_STATE===o;let a=ye($r,{},r),u={};if(c)if(Ma===s)u=n.extra.loadingProxy,u||(u=La(e,t),n.extra.loadingProxy=u,n.loadingInternal=B(u)),a=ye(n.extra,u,r);else if(Fa===s){const f=Xr();u=xa(),n.loadingInternal=f,a=ye(f.extra,u,r)}else u=sn();else u=n.sharedState,a=ye(n.extra,u,r);return{loadingState:a,loadingProxy:u}}function Jr(e,t){if(!de(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?Y(w({},e),{internal:pe(r.__sharedKey)}):e}function Zr(e,t){const{internal:n,from:r,apiCtx:o}=t,{stateType:s}=n,c=Z.USER_STATE===s;Be(e,t);let a=()=>Oa;return c&&(a=u=>{const f=Jr(t,u),l=Be(e,f).loadingProxy,{insCtx:{proxyState:i,internal:d,extra:p,renderInfo:h}}=ft(o,l);return[ye(p,i,r),d.setState,h]}),{useLoading:a,getLoading:u=>{const f=Jr(t,u);return Be(e,f).loadingState}}}function lt(e){const t=hr();return Object.assign(t,e||{})}function he(){const e=U(),{runningFnKey:t}=e;if(!t)return[];const n=le(t);let r=[];if(n){const{depKeys:o}=e,{depKeys:s}=n,c={};o.forEach(u=>c[u]=1),o.forEach(u=>{const f=xn(c,u);f&&f!==u&&delete c[f]}),Object.keys(c).forEach(u=>b(s,u)),r=s.slice()}return e.runningFnKey="",e.depKeys=[],e.runningSharedKey=0,r}function pn(e,t){const n=U();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function Qr(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:o}=n,s=Kr(e,o),c=w({fn:e,fnKey:s},n),a=r?Object.assign(r,c):lt(c);return zt(o).set(s,a),a}function yn(e){var o;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=U(),{fnKey:r}=e;nn(e),e.extra.deferedWatch=null,t.delete(r),((o=n.get(r))==null?void 0:o.c)===2&&n.delete(r),ea()}function qr(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=U(),{prevLevelFnKeys:n,depKeys:r}=e;let o=!1;for(const s of r){const c=t.get(s)||[];if(Ge(c,n)){o=!0;break}}return o}function Na(e,t=!0,n=Ke){return e.map(r=>{const[o,s]=r.split("/"),c=s.split(Ke);return`${t?`${ke(Number(o)).usefulName}/`:""}${c.join(n)}`})}var dt=new Map,pt={WATCH:"1",MUTATE:"2"},Ua={[pt.WATCH]:"watch",[pt.MUTATE]:"mutate fn or task"};function Ba(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function eo(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function Va(e){dt.delete(e)}function Ya(e,t,n,r){const o=Ua[r],{desc:s,task:c,fn:a,isFake:u}=t.subFnInfo,f=s?`(${s})`:"",l=`DEAD_CYCLE: found reactive object in ${o}${f} cb is changing module(${e.usefulName})'s some of these dep keys(${Na(n,!1,".")}), it will cause a infinity loop call!`,i=u?t.fn:c||a;return{err:new Error(`[only-dev-mode alert] ${l}`),tipFn:()=>console.error(` ${l} open the stack to find the below fn: 
`,i)}}function Ga(e,t,n){if(e&&n){const{usefulName:r}=e,o=He(dt,r,Ba(t));o.sn!==t&&(o.descs=[],o.errs=[]);const{descs:s}=o;if(s.length>1&&s[0]===n){const c=s.slice();throw o.cycle=c,s.length=0,eo(r,c,n)}b(s,n)}}function hn(e,t){t.tipFn(),ae(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function me(e,t,n){const{depKeys:r,subFnInfo:o}=t;let s=t.depKeys,c=n;r.length>n.length&&(s=n,c=r);let a=!1;if(Ge(s,c)){const u=o.desc?pt.MUTATE:pt.WATCH,f=Ya(e,t,n,u);hn(e,f),t.dcErrorInfo=f,a=!0}return a}function Ha(e,t){const n=dt.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function ja(e,t,n=!0){const r=dt.get(e);if(!r)return;const{timer:o,errs:s}=r;s.push(t),o&&clearTimeout(o),r.timer=setTimeout(()=>{let c=null;for(const a of s)c?a.data.length>c.data.length&&(c=a):c=a;c&&ae(c,{alertErr:n}),s.length=0},0)}function mn(e,t=0){const n=le(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:$a}=Qe;function Wa(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:o=0,from:s,internal:c=Er,desc:a,fromFnKey:u}=t;if(e.dcErrorInfo.err){hn(c,e.dcErrorInfo);return}if(e.fnKey===u){me(c,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:o});if(H.MUTATE===s&&Ga(c,o,a),e.isRunning&&me(c,e,t.depKeys||[]))return;const f=oe.current();if(f.fnKey===e.fnKey&&me(c,e,f.writeKeys)||(Ue(f.sharedKey,f.desc),e.isRunning===!0&&f.isTop&&me(c,e,f.writeKeys)))return;e.isRunning=!0,Oe.set(e.fnKey);const i=e.fn({isFirstCall:n,triggerReasons:r,sn:o});Oe.del();const d=oe.current();if(!(d.isTop&&d.fnKey===e.fnKey&&me(c,e,d.writeKeys))&&!(i&&i.task&&d.from===H.MUTATE&&me(c,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,i}function to(e,t,n){let r=t.val;return n||(r=t),{input:j(e,{state:r,stateRoot:t,isAtom:n}),state:r,stateRoot:t}}function Ve(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:o=!1,throwErr:s=!1,triggerReasons:c=[],sn:a=0,err:u,unbox:f=!1,internal:l=Er}=t,i=le(e),d=(F=null)=>{if(F&&s)throw F;const L=i||vr;return f?[L.result.val,F]:[L.result,F]};if(!i)return d(new Error(`not a valid watch or derive cb for key ${e}`));if(i.fnType===Jn)return Wa(i,t);const{isAsync:p,fn:h,task:E,isAsyncTransfer:y,forAtom:m,result:g,depKeys:A}=i;i.remainRunCount>0&&(i.remainRunCount-=1);const _=F=>{const L=m?{val:F}:F;!i.returnUpstreamResult&&L&&Object.assign(i.result,L),i.shouldReplaceResult=!0},I=()=>{i.renderInfo.sn=a,i.updater()},S=F=>{const{data:L,err:q=null}=F;q?i.setLoading(!1,q):(_(L),n?p&&i.status.loading&&!qr(i)&&i.setLoading(!1,q):i.remainRunCount===0&&i.setLoading(!1,q)),I(),i.nextLevelFnKeys.forEach(Et=>{Ve(Et,{isFirstCall:n,sn:a,triggerReasons:c,err:q})})},R=m?g:g.val,{deps:C,isStateAtom:v}=i,{input:K,state:T,stateRoot:D}=to(C,i.stateRoot,v),M={isAtom:i.isStateAtom,state:T,stateRoot:D,isFirstCall:n,prevResult:R,triggerReasons:c,input:K,sn:a};if(!p||r||p&&!E){const F=h(M);return S({data:F}),d()}if(p&&n&&i.nextLevelFnKeys.forEach(F=>mn(F,0)),y)return S({err:u}),d();if(i.asyncType===$a){const F=h(M);return S({data:F}),d()}if(E){let F=Ss;return n?(A.forEach(L=>Uc(L,e)),F=()=>A.forEach(L=>Bc(L,e))):o&&i.nextLevelFnKeys.forEach(L=>mn(L)),Promise.resolve(()=>{const L=E(M);return Dt(L)?L:(ae("ERR_NON_FN: derive task arg should be async function!",{throwErr:s}),null)}).then(L=>L()).then(L=>(F(),S({data:L}),d())).catch(L=>{if(F(),S({err:L}),s)throw L;return cr(l,L),d(L)})}return d(u)}function yt(e,t){const n=Pe(e);if(!n)throw new Error("[Helux]: not a derived result");return Ve(n.fnKey,w({},t||{}))}function Xa(e,t){return yt(e,{forceFn:!0,throwErr:t})}function za(e,t){return Promise.resolve(yt(e,{forceTask:!0,throwErr:t}))}function Ja(e,t){return yt(e,{forceFn:!0,throwErr:t,unbox:!0})}function Za(e,t){return Promise.resolve(yt(e,{forceTask:!0,throwErr:t,unbox:!0}))}function Qa(e){const t=Pe(e);return t?t.status:{loading:!1,err:null,ok:!0}}function gn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,ma(r))}function qa(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:o,depKeys:s,triggerReasons:c,isFirstCall:a,from:u,sn:f,desc:l,fnKey:i}=t,{key2InsKeys:d,id2InsKeys:p,insCtxMap:h,rootValKey:E}=n;let y=[],m=[],g=[],A=[];const _={};if(a){const S=he();xe.set(S)}const I=S=>{if(!at(n,S))return;const R=d[S]||[],C=[];for(const T of R){if(y.includes(T))continue;const D=h.get(T);if(!D)continue;const M=D.getDeps();if(M[0]===E){at(n,E)&&C.push(T);continue}Mr(n,M,S)&&C.push(T)}y=y.concat(C);const{firstLevelFnKeys:v,asyncFnKeys:K}=qc(n,S,_);g=g.concat(v),A=A.concat(K)};if(s.forEach(S=>I(S)),s.includes(E)||I(E),Qc(),r.forEach(S=>{y=y.concat(p[S]||[])}),o.forEach(S=>{cn(S).forEach(R=>b(m,R))}),y=ge(y),g=ge(g),A=ge(A),A.forEach(S=>mn(S,_[S])),g.forEach(S=>Ve(S,{depKeys:s,sn:f,from:u,triggerReasons:c,internal:n,desc:l,isFirstCall:a,fromFnKey:i})),y.forEach(S=>gn(h,S,f)),m.length){const S=oa().insCtxMap;m.forEach(R=>gn(S,R,f))}}function eu(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:o,isDeep:s,ver:c,snap:a}=n;s?(n.prevSnap=c===0?w({},a):a,n.snap=t,Object.assign(o,t)):n.snap=w({},o),n.ver+=1,n.sn=r.sn,qa(e)}var{MUTATE:tu}=H;function no(e,t){const{writeKey:n,ids:r,internal:o,opParams:s}=t,{snap:c}=o,{fullKeyPath:a,value:u}=s;Object.keys(e).forEach(f=>{n.startsWith(f)&&ue(c,a)!==u&&e[f].forEach(l=>b(r,l))})}function ro(e,t){const{isChanged:n,fullKeyPath:r,keyPath:o,parentType:s,value:c}=e,{internal:a,mutateCtx:u}=t,{arrKeyDict:f,isReactive:l,readKeys:i}=u,{sharedKey:d}=a,p=Tr(s),h=oe.current();if(e.op==="get"){p&&(f[W(o,d)]=1);const D=W(r,d);i[D]=1,u.enableDep&&(h.onRead?h.onRead(e):(st().fnCtx&&_e([D],{sharedKey:d}),l&&(qt([D]),rn(d,c,a.sharedState,D,r))));return}if(!n)return;const{moduleName:E,ruleConf:y,level1ArrKeys:m}=a,{writeKeyPathInfo:g,ids:A,globalIds:_,writeKeys:I}=u,S=W(r,d);if(h.key&&(h.isTop?b(h.writeKeys,S):h.from===tu&&b(Jt(h.fnKey).subFnInfo.writeKeys||[],S)),p){const D=W(o,d);g[D]={sharedKey:d,moduleName:E,keyPath:o},I[D]=1}const{hasIds:R,hasGlobalIds:C,stopDepInfo:v}=y;g[S]={sharedKey:d,moduleName:E,keyPath:r};const K=xn(f,S);K&&(I[K]=1),wr({sharedKey:d,keyPath:r,depKey:S},{stopDepInfo:v,level1ArrKeys:m,recordCb:D=>{I[D]=1}})||(I[S]=1),R&&no(y.idsDict,{ids:A,writeKey:S,internal:a,opParams:e}),C&&no(y.globalIdsDict,{ids:_,writeKey:S,internal:a,opParams:e}),l?la(d,h.desc):fa(d)}function oo(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function ht(e,t){if(!t)return e;en(!0);const n=e.val;return en(!1),n}function so(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:o}=e;if(!t)return;if(!n){de(t)&&oo(o,t);return}const s=t.val;if(de(o)){de(s)?oo(o,s):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=s}function nu(e,t){const{internal:n,mutateCtx:r}=e,o=ht(t,n.forAtom),{from:s,sn:c,desc:a}=r;n.before({from:s,draftRoot:t,draft:o,desc:a,sn:c}),ac(n,t,o,c)}function co(e,t,n,r){const{mutateCtx:o,internal:s}=e,{writeKeys:c,writeKeyPathInfo:a,handleCbReturn:u}=o,{forAtom:f}=s;u&&so({partial:r,forAtom:f,draftRoot:t,draftNode:n}),nu(e,t),o.depKeys=Object.keys(c),ot.del(),Xt.del(),e.state=(0,$._x)(t),e.state!==s.rawState&&(o.triggerReasons=Object.values(a),eu(e),lc(s,o))}function ao(e,t){const{ids:n,globalIds:r,from:o,desc:s,fnKey:c}=t;n&&n.forEach(a=>b(e.ids,a)),r&&r.forEach(a=>b(e.globalIds,a)),o&&(e.from=o),s&&(e.desc=s),c&&(e.fnKey=c)}function ru(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:o}=t,s=Pt(n),c=(0,$.P2)(o,{customKeys:Xe,onOperate:u=>{if(u.isCustom)return on(u,r,t.sharedKey);ro(u,{internal:t,mutateCtx:s})}});ot.set(c,r),Xt.set(s);const a=ht(c,r);return r&&(s.readKeys={}),{draftRoot:c,draftNode:a,finishMutate(u,f={}){ao(s,f),co({state:{},mutateCtx:s,internal:t},c,a,u)}}}function ou(e){return ar(e),Kc(e)}function su(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function cu(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=O(n);let o=!1;if(t)n=r?{val:n()}:{val:n},o=!n.val||!Ln(n.val);else{if(n=r?n():n,!X(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(re(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:o,rawState:n}}function uo(e,t,n){let r=null,o=t||"";if(O(e)&&e!==k)r={[$n]:1,fn:e,deps:ve,oriDesc:o,onlyDeps:!1,desc:o,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}};else if(X(e)){const{fn:s,desc:c,deps:a,task:u,immediate:f,checkDeadCycle:l,onlyDeps:i=!1}=e,d=t||c||"",p=O(s)?s:void 0,h=O(u)?u:void 0,E=O(a)?a:ve;(s||u)&&(r={[$n]:1,checkDeadCycle:l,fn:p,watchKey:"",desc:d,oriDesc:d,deps:E,task:h,onlyDeps:i,immediate:f,depKeys:[],writeKeys:[],isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}})}if(r&&n){const{oriDesc:s}=r;(!s||n[s])&&(r.desc=xt(H.MUTATE))}return r}function io(e,t,n=!0){const r={},o=t||{};if(!e)return r;const s=(c,a)=>{const u=uo(c,a,o);u&&(u.enabled=n,r[u.desc]=u,o[u.desc]=u)};if(Array.isArray(e))if(e.length===1){const c=e[0],a=(X(c)?c.desc:"")||ze;s(e[0],a)}else e.forEach(c=>s(c));else O(e)?s(e,ze):X(e)&&Object.keys(e).forEach(c=>{s(e[c],c)});return r}function au(e,t={}){var C,v,K,T,D;const{forAtom:n=!1,forGlobal:r=!1,stateType:o=Z.USER_STATE}=e,{rawState:s,isPrimitive:c}=cu(e),a=ou(s),u=t.moduleName||"",f=(C=t.alertDeadCycleErr)!=null?C:ce(),l=(v=t.deep)!=null?v:!0,i=(K=t.checkDeadCycle)!=null?K:!0,d=(T=t.enableMutate)!=null?T:!0,p=t.recordLoading||Mt.PRIVATE,h=t.rules||[],E=t.before||k,y=t.mutate||k,m=(D=t.stopArrDep)!=null?D:!0,g=t.stopDepth||Hs,A=`${a}`,_=n?`${a}/val`:A,I=u||A,S=jc(u),R=io(y,{},d);return{isDestroyed:!1,alertDeadCycleErr:f,checkDeadCycle:i,rawState:s,sharedKey:a,sharedKeyStr:A,rootValKey:_,moduleName:u,usefulName:I,forAtom:n,forGlobal:r,loc:S,deep:l,rules:h,before:E,mutate:y,mutateFnDict:R,onRead:null,enableMutate:d,stateType:o,recordLoading:p,stopArrDep:m,stopDepth:g,isPrimitive:c}}function uu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:o,rules:s,stopDepth:c,stopArrDep:a,forAtom:u}=e,f={},l={},i={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:c,stopArrDep:a},d={},p=Rt(o);s.forEach(y=>{const m=[],{when:g,ids:A=[],globalIds:_=[],stopDep:I}=y;let S;if(p){let T="";S=(0,$.OA)(t,{onOperate:({fullKeyPath:D,value:M,isBuiltInFnKey:G})=>{if(G)return;const F=W(D,n);T&&F.includes(T)&&m.pop(),m.push(F),d[F]=Array.isArray(M),T=F}})}else S=fe(t,{set:bs,get:(T,D)=>{const M=W([D],n);m.push(M);const G=T[D];return d[M]=Array.isArray(G),G}});const R=u?S.val:S,C=j(g,R),v=(T,D,M)=>{const G=be(T,M,[]);D.forEach(F=>b(G,F))},K=T=>{v(f,A,T),v(l,_,T);let D;d[T]?(D=I!=null?I:js,i.arrKeyStopDcit[T]=D,i.isArrDict[T]=d[T]):D=I!=null?I:!1,D&&b(i.keys,T)};m.forEach(K),C.includes(R)&&K(r)});const h=Object.keys(f).length>0,E=Object.keys(l).length>0;return{hasIds:h,idsDict:f,hasGlobalIds:E,globalIdsDict:l,stopDepInfo:i}}function iu(e){const{desc:t=ze,strict:n=!1,throwErr:r=!1}={};return typeof e=="string"?{desc:e,strict:n,throwErr:r}:Y(w({desc:t,strict:n},e),{throwErr:r})}function fo(e,t){var o;let n=k,r=!1;return O(t)?n=t:X(t)&&(n=t.deps||k,r=(o=t.immediate)!=null?o:!1),r=e?!0:r,{immediate:r,deps:n}}function fu(e){return e?typeof e=="boolean"?{enableStatus:e}:X(e)?e:{}:{}}function lu(e){Array.isArray(e)&&e.forEach(t=>{const n=Wt.current(t),r=B(t)||(n==null?void 0:n.internal);if(r){const{depKey:o,sharedKey:s}=Rr(r);_e([o],{sharedKey:s})}n&&n.recordDep(Rr(r))})}function lo(e,t,n){const{deps:r,immediate:o}=fo(e,n),s=mt(t,{scopeType:te.STATIC,deps:r,immediate:o});return{run:c=>Ve(s.fnKey,{throwErr:c}),unwatch:()=>nn(s)}}function mt(e,t){const{scopeType:n,fnCtxBase:r,immediate:o,deps:s=k,label:c="watch",sharedState:a,isSimpleWatch:u}=t;if(!O(e))throw new Error(`ERR_NON_FN: pass an non-function to ${c}!`);const f=Qr(e,{specificProps:{scopeType:n,fnType:Jn,isSimpleWatch:u},fnCtxBase:r});pn(f.fnKey,re(a));const l=s()||[];return lu(l),o&&e({isFirstCall:!0}),he(),f}function du(e,t){return lo(!1,e,t)}function pu(e,t){return lo(!0,e,t)}var po=()=>{},En=new Map;function yo(e,t){const{forAtom:n,rawState:r}=e,{deps:o,extraBound:s}=t;return n?j(o,r.val,s):j(o,r,s)}function yu(e){var t;return(t=En.get(e))!=null?t:!1}function vn(e,t){const{sn:n,getArgs:r=k,from:o,throwErr:s,isFirstCall:c,fnItem:a,mergeReturn:u}=t,{desc:f="",depKeys:l,task:i=po,extraBound:d}=a,p=B(e),{sharedKey:h}=p,E={desc:f,sn:n,from:o},y=dn(o,f),{draft:m,draftRoot:g}=un(p,{depKeys:l,desc:f,from:o}),A=M=>{Ue(h,M)},_=M=>{A(f);const{finish:G}=p.setStateFactory(E);return G(M)},I=H.MUTATE===o?yo(p,a):[],S={isFirstCall:c,desc:f,setState:_,input:I,draft:m,draftRoot:g,flush:A,extraBound:d},R=r(S)||[S],C=En.get(i),v=C===void 0,K=(M,G,F)=>{(v||C)&&zr(p,y,{loading:M,err:G,ok:F})};K(!0,null,!1);const T=M=>{if(xe.del(),K(!1,M,!1),s)throw M;return{snap:p.snap,err:M,result:null}},D=M=>(u&&M&&_(M),K(!1,null,!0),A(f),{snap:p.snap,err:null,result:M});try{const M=i(...R),G=Dt(M);return En.set(i,G),G?Promise.resolve(M).then(D).catch(T):D(M)}catch(M){return T(M)}}function ho(e,t){const{sn:n,getArgs:r=k,from:o,throwErr:s,isFirstCall:c=!1,fnItem:a}=t,{desc:u="",watchKey:f,fn:l=po,extraBound:i}=a,d=H.MUTATE===o;d&&Oe.set(f);const p=B(e),{setStateFactory:h,forAtom:E,sharedRoot:y}=p,g={desc:u,sn:n,from:o,isFirstCall:c,enableDep:d&&c},A=K=>{const{finish:T}=h(g);return T(K)},_=ht(y,E),I=d?yo(p,a):[],{draftNode:S,draftRoot:R,finish:C}=h(g),v=r({draft:S,draftRoot:R,setState:A,desc:u,input:I})||[S,{input:I,state:_,draftRoot:R,isFirstCall:c,extraBound:i}];try{const K=Jt(a.watchKey);if(K.dcErrorInfo.err)return hn(p,K.dcErrorInfo),{snap:p.snap,err:null,result:null};const T=l(...v);return C(T,{fnKey:K.fnKey}),mo(p,a,c),{snap:p.snap,err:null,result:null}}catch(K){if(mo(p,a,c),s)throw K;return{snap:p.snap,err:K,result:null}}}function mo(e,t,n){n&&!t.onlyDeps&&(st().fnCtx?t.depKeys=he():t.depKeys=xe.current(),xe.del());const r=oe.current();r.isTop&&r.fnKey===t.watchKey&&me(e,Jt(t.watchKey),r.writeKeys),Oe.del()}function hu(e,t){var r;ia(),xe.del(),en(!1);const n=st().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=he())}function Sn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const o=B(t),{mutateFnDict:s,usefulName:c,forAtom:a,sharedRoot:u}=o,f=l=>cr(o,l);r.forEach(l=>{const i=s[l];mt(({sn:d,isFirstCall:p})=>{if(p&&hu(o,i),!o.enableMutate)return;const{desc:h,fn:E,task:y,immediate:m}=i,g=Ha(c,h);try{if(g.isIn)throw eo(c,g.cycle,h);const A={sn:d,throwErr:!0,isFirstCall:p,fnItem:i,from:H.MUTATE};if(E&&(p||!y)&&ho(t,A),y){p&&(i.depKeys=he());const _=p&&(m!=null?m:!E);(!p||_)&&vn(t,A).catch(f)}return i}catch(A){A.cause==="DeadCycle"&&ja(c,A,o.alertDeadCycleErr),f(A)}},{deps:()=>i.deps?i.deps(ht(u,a),i.extraBound)||[]:[],sharedState:t,scopeType:te.STATIC,immediate:!0})})}var{ACTION:go}=H;function mu(e,t){const{label:n,throwErr:r,desc:o="",task:s,mergeReturn:c=!0}=t,a=Zt(r,!1),u=pe(e,{label:n}),{forAtom:f}=u,l=(i,d)=>{const p=Zt(d,a),h=Nt({desc:o,task:s,depKeys:[]}),E=(y,m)=>y.__action?y.__action(m):y(m);return vn(e,{fnItem:h,from:go,mergeReturn:c,throwErr:p,getArgs:({draft:y,draftRoot:m,setState:g,desc:A,flush:_})=>[{draft:y,draftRoot:m,setState:g,desc:A,payload:i,flush:_,merge:S=>{so({partial:S,forAtom:f,draftRoot:m,draftNode:y})},dispatch:E}]})};return zr(u,dn(go,o),{loading:!1,ok:!0,err:null}),l.__sharedKey=u.sharedKey,l.__fnName=o,l.__task=s,s.__action=l,l}function Eo(e){return t=>(n,r="",o)=>mu(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:o})}var{TASK:vo}=Qe,{STATIC:gu,HOOK:Eu}=te;function So(e,t,n){if(!n&&(!X(t)||Dt(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:o}=e;if(r&&!o){const s=Dr(t),c=re(t);if(s&&e.fnKey!==s||c)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function vu(e,t){const n=fe(e.result,{set:()=>(Se("changing derived result is invalid"),!1),get:(r,o)=>{if(o===Ie)return t;const s=r[o];return _e(e.depKeys,{belongCtx:e}),qt(e.depKeys,n),rn(0,s,n,"",[o],!0,t),s}});return e.proxyResult=n,n}function Ao(e,t){const{result:n,isUpstream:r}=t,o=Pe(n);o&&(e.depKeys=ge(e.depKeys.concat(o.depKeys)),b(o.nextLevelFnKeys,e.fnKey),b(e.prevLevelFnKeys,o.fnKey),e.isFirstLevel=!1,r==null||r())}function Su(e){var C,v;const{scopeType:t=gu,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:o=vo,returnUpstreamResult:s,runAsync:c=!0,forAtom:a=!1,immediate:u}=e;if(!O(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:f=k,deps:l=k,task:i,stateRoot:d={}}=e,p=De(d),h=(C=e.isAsync)!=null?C:O(i),E=(v=e.showLoading)!=null?v:h,y=Qr(f,{specificProps:{forAtom:a,scopeType:t,stateRoot:d,isStateAtom:p,fnType:Ws,task:i,deps:l,isAsync:h,asyncType:o,isAsyncTransfer:r,showLoading:E},fnCtxBase:n});pn(y.fnKey,0);const{input:m,state:g}=to(l,d,p);m.forEach(K=>Ao(y,{result:K}));let _=f({isFirstCall:!0,prevResult:null,triggerReasons:[],input:m,sn:0,state:g,stateRoot:d,isAtom:p});he();const I=Pe(_);a&&!I&&(_={val:_,z__is_atom_result__:!0});const S=y.fnKey;So(y,_),Ao(y,{result:_,isUpstream:()=>{y.returnUpstreamResult=s!=null?s:!h}}),tn(y),y.returnUpstreamResult||Kr(_,t,S);const R=c&&o===vo&&(u!=null?u:!e.fn);return i&&R&&Ve(S,{isFirstCall:!0,sn:y.renderInfo.sn+1}).then(K=>{So(y,K[0],a)}).catch(K=>ae(K)),y.result=_,t===Eu&&qr(y)&&y.setLoading(!0),y.returnUpstreamResult?y.proxyResult=_:vu(y,a),y}function An(e,t){const n=O(e)?{fn:e}:e||{};return Su(w(w({},t||{}),n))}function Ko(e,t){return An(e,{forAtom:!0,stateRoot:t}).proxyResult}function Au(e,t){return An(e,{stateRoot:t}).proxyResult}function Ku(e){return t=>Y(w({},t),{deps:e})}function Du(e){return e}var gt=e=>[e.snap,e.err];function Kn(e){const{target:t,desc:n="",forTask:r=!1,throwErr:o}=e,{mutateFnDict:s,snap:c}=B(t),a=n||ze,u=s[a];if(!u)return{snap:c,err:new Error(`mutate fn ${a} not defined`),result:null};if(r&&!u.task)return{snap:c,err:new Error(`mutate task ${a} not defined`),result:null};const f=Zt(o,!1),l={sn:0,fnItem:u,from:H.MUTATE,throwErr:f};return r?vn(t,l):ho(t,l)}function Do(e,t,n,r){return{run:o=>{const s=Kn({target:e,desc:t,throwErr:o});return gt(s)},runTask:o=>Promise.resolve(Kn({target:e,desc:t,forTask:!0,throwErr:o})).then(gt),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function _u(e){const{target:t,fnItem:n,label:r,extraTarget:o}=e,s=pe(t,{label:r}),c=uo(n,"",s.mutateFnDict);if(!c)throw new Error("not a fn or fnItem { fn }");o&&(c.extraBound=Lt(o)),s.mutateFnDict[c.desc]=c,c.enabled=s.enableMutate;const a={[c.desc]:c};return s.enableMutate&&Sn({target:t,dict:a}),Do(t,c.desc,c.oriDesc,s)}function Ru(e){const{target:t,fnDict:n,label:r}=e,o=pe(t,{label:r}),s=io(n,o.mutateFnDict,o.enableMutate);if(e.extraTarget){const a=Lt(e.extraTarget);Object.keys(s).forEach(u=>s[u].extraBound=a)}o.enableMutate&&Sn({target:t,dict:s});const c={};return Object.keys(s).forEach(a=>{c[a]=Do(t,a,a,o)}),c}function Tu(e,t){const{label:n,descOrOptions:r,forTask:o=!1}=t,{desc:s,strict:c,throwErr:a}=iu(r);return s?jr(e,{label:n,strict:c})?{ok:!0,desc:s,forTask:o,throwErr:a,err:null}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("miss desc")}}function _o(e,t){const{ok:n,desc:r,forTask:o,err:s,throwErr:c}=Tu(e,t);if(!n){if(c)throw s;return o?Promise.resolve([e,s]):[e,s]}const a=Kn({target:e,desc:r,forTask:o,throwErr:c});return o?Promise.resolve(a).then(gt):gt(a)}function Ro(e,t){return _o(e,{descOrOptions:t,label:"runMutate"})}function To(e,t){return _o(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function bo(e,t){return n=>_u({target:e,extraTarget:t,fnItem:n,label:"mutate"})}function Dn(e,t){return n=>Ru({target:e,extraTarget:t,fnDict:n,label:"mutateDict"})}function bu(e){return e}function Io(e,t,n={}){const{tuple:r}=ft(e,t,n);return r}function wo(e,t,n={}){const{tuple:r}=ft(e,t,n),[o,s,c]=r;return Y(w({},c),{state:o,setState:s})}var Iu="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",wu="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function Mu(e,t,n){return e.isExpired?(e.isExpired=!1,!0):O(n)?!1:n!==t}function Fu(e){yn(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function ku(e,t){const{result:n,forAtom:r,showLoading:o}=t,{fnCtx:s,input:c,deriveFn:a}=e;let u=!1;if(a)if(Mu(s,c,n))u=!0,Fu(s);else return;e.input=n;const f=Pe(n);if(!f)throw new Error(Iu);if(r&&!ie(n))throw new Error(wu);e.deriveFn=()=>f.result,An({fn:()=>f.result,deps:()=>[],task:()=>vs(this,null,function*(){return f.result})},{isAsync:f.isAsync,scopeType:te.HOOK,fnCtxBase:s,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:Qe.MAY_TRANSFER,showLoading:o}),Yr(s),u&&s.updater()}function Mo(e,t){const{result:n,forAtom:r}=t,{hookImpl:o,react:s}=e,c=o.useForceUpdate(),{current:a}=s.useRef({input:n,deriveFn:null,fnCtx:null});a.fnCtx||(a.fnCtx=lt({updater:c,scopeType:te.HOOK,forAtom:r}));const u=a.fnCtx;return u.renderStatus=we,ku(a,t),u}function Cu(e,t){t.shouldReplaceResult&&(Yr(t),t.shouldReplaceResult=!1),it(e,t.subscribe,()=>kr(t)),e.react.useEffect(()=>{t.renderStatus=kt})}function Fo(e,t){e.react.useEffect(()=>(t.mountStatus=Ze,Fr(t),()=>{yn(t)}),[t])}function _n(e,t){const n=Mo(e,t);return it(e,n.subscribe,()=>kr(n)),Fo(e,n),n}function Ou(e,t){const n=Mo(e,t);return Cu(e,n),Fo(e,n),n}function Rn(e,t,n){const r=Ou(e,w({result:t},n||{})),{proxyResult:o,status:s,renderInfo:c}=r;return[ie(t)?o.val:o,s,c]}function ko(e,t,n){if(t===null)return n;if(!O(t))return null;const{sharedState:r,forAtom:o}=e,s=o?r.val:r,c={};$t.set(u=>c[u[0]]=1);const a=j(t,s);return $t.del(),a.includes(s)?e.key2InsKeys:c}function Co(e,t,n){const r=pe(t),[o]=e.react.useState(()=>ko(r,n,null));return s=>{const{insCtxMap:c,key2InsKeys:a}=r,u=ko(r,s,a)||o||a,f={};if(Object.keys(u).forEach(i=>{(a[i]||[]).forEach(p=>f[p]=1)}),Object.keys(f).length){r.sn+=1;const i=r.sn;Object.keys(f).forEach(d=>{gn(c,Number(d),i)})}}}function Lu(e,t){wn(e);const n=sn();return ln(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:Oo,MUTATE:Lo}=H;function Tn(e,t){wn(e);const{target:n,from:r="Mutate"}=t||{};let o=Xr();n&&(o=pe(n));const{loadingProxy:s,loadingState:c}=Be(se,{apiCtx:e,internal:o,from:r});return{loadingProxy:s,loadingState:c,internal:o,from:r}}function xo(e,t){const{loadingProxy:n,internal:r,from:o}=Tn(e,t),{proxyState:s,extra:c,renderInfo:a}=ln(e,n);return[ye(c,s,o),r.setState,a]}function xu(e,t){const{loadingProxy:n}=Tn(e,{target:t,from:Lo});return n}function Pu(e,t){return xo(e,{target:t,from:Lo})}function Nu(e,t){const{loadingProxy:n}=Tn(e,{target:t,from:Oo});return n}function Uu(e,t){return xo(e,{target:t,from:Oo})}function Po(e){return e.hookImpl.useForceUpdate()}function No(e,t){const n=(r,o)=>{let s=null;if(O(r)){const c=(0,$.P2)(o),a=r(c);s=(0,$._x)(c),X(a)&&Object.assign(s,a)}else X(r)&&(s=w(w({},o),r));return s};return e.hookImpl.useObjectLogic(t,n,!0)}function Bu(e,t,n){const{useRef:r,useMemo:o,useEffect:s}=e.react,c=r({fn:n,wrap:null});c.current.fn=o(()=>n,[n]),c.current.wrap||(c.current.wrap=(...a)=>{c.current.fn(...a)}),s(()=>{const a=pc(),u=c.current.wrap;return a.on(t,u),()=>a.off(t,u)},[t,c])}function bn(e,t,n={}){const r=De(t),{insCtx:o}=ft(e,t,Y(w({},n),{forAtom:r,isReactive:!0}));return[o.proxyStateVal,o.proxyState,o.renderInfo]}function Uo(e,t,n={}){const[r,o,s]=bn(e,t,n);return Y(w({},s),{state:r,stateRoot:o})}function Vu(e,t,n){const r=X(n)?n:{};e.react.useEffect(()=>{const{srvRef:o}=r;O(o)&&o(t)},[])}function Yu(e,t,n){const r=e.hookImpl.useStable(t);return Vu(e,r,n),r}function Gu(e){return t=>e.current=t}var{HOOK:Bo}=te;function Vo(e,t){e(()=>{var n,r;return t.mountStatus=Ze,Fr(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{yn(t)}},[t])}function Yo(e,t){const{useRef:n,useState:r,useMemo:o,useEffect:s}=e.react,{label:c,forEffect:a,watchFn:u,watchOptions:f}=t,l=n({fn:u,wrap:null,fnKey:"",isDeferMarked:!1}),[i]=r(()=>lt());if(l.current.fn=o(()=>u,[u]),!l.current.wrap){const{deps:d,immediate:p}=fo(a,f);l.current.wrap=E=>{if(i.mountStatus===Ze){l.current.fn(E);return}i.extra.deferedWatch=()=>{if(l.current.isDeferMarked){l.current.fn(E);return}l.current.isDeferMarked=!0,pn(l.current.fnKey,0),l.current.fn(E),he()}};const{fnKey:h}=mt(l.current.wrap,{scopeType:Bo,fnCtxBase:i,deps:d,immediate:p,label:c});l.current.fnKey=h}Vo(s,i)}function Hu(e,t,n){const{useState:r,useEffect:o}=e.react,[s]=r(()=>lt());if(s.fn===k){const{manualDepKeys:c=[]}=n;mt(t,{scopeType:Bo,fnCtxBase:s,deps:()=>c.map(u=>{const{sharedKey:f,keyPath:l}=_r(u),i=_c(f);return ue(i,l)}),isSimpleWatch:!0})}Vo(o,s)}function ju(e,t,n){Yo(e,{label:"useWatch",forEffect:!1,watchFn:t,watchOptions:n})}function $u(e,t,n){Yo(e,{label:"useWatchEffect",forEffect:!0,watchFn:t,watchOptions:n})}function Wu(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:o,stopDepth:s,sharedKey:c}=t,a=Pt(n),u=w({},r),f=(p,h,E,y)=>{const m=Ce(h,E,{parentType:br(p),parentKeyPath:y});ro(m,{internal:t,mutateCtx:a}),Nn(u,m.fullKeyPath,E)},l=(p,h,E)=>Me(p,{set:(y,m,g)=>(f(y,m,g,E),!0),get:(y,m)=>{const g=y[m];if(Xe.includes(m))return ut(h===1,o,c,m,g);const A=Ce(m,g,{isChanged:!1,parentKeyPath:E,op:"get",parentType:br(y)});return h<s&&de(g)?l(g,h+1,A.fullKeyPath):ue(u,A.fullKeyPath)}}),i=l(u,1,[]);ot.set(i,o),Xt.set(a);const d=o?i.val:i;return{draftRoot:i,draftNode:d,finishMutate(p,h={}){ao(a,h);const E=w({state:{},mutateCtx:a},e);co(E,i,d,p)}}}function Xu(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function zu(e){let t=[];return{target:Wc(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function Go(e,t,n){return o=>{let s=Xu(o);e(c=>{const{isAtom:a,draftRoot:u}=ot.current(),f={draft:c,draftRoot:u,path:t,isAtom:a,UNDEFINED:Ys},l=n==null?void 0:n(s,f);Nn(u,t,l!==void 0?l:s)},{from:H.SYNC})}}function In(e,t){const{sharedKey:n,innerSetState:r}=t;let o=W(e,n),s=Ho.get(o);return s||(s=Go(r,e),Ho.set(o,s)),s}var Ho=new Map;function jo(e){const{forAtom:t,rawState:n}=e;return t?Ln(n.val)?Me(n.val,{get:(r,o)=>In(["val",o],e)}):In(["val"],e):Me(n,{get:(r,o)=>In([o],e)})}var $o=new Map;function Wo(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:o}=e,s=zu(o);return(c,a)=>{let u=[];if(Array.isArray(c))u=t?["val",...c]:c;else{const{target:i,getPath:d}=s;c(t?i.val:i),u=d()}let f=W(u,n);a&&(f+=`${a.toString()}`);let l=$o.get(f);return l||(l=Go(r,u,a),$o.set(f,l)),l}}function Ju(e,t,n){const{deep:r,forAtom:o,sharedKey:s}=n,c=uu(n),a=Rt(r),u=(m={})=>{const g={internal:y,setFactoryOpts:m},{finishMutate:A,draftRoot:_,draftNode:I}=a?ru(g):Wu(g);return{finish:(S,R={})=>{const C=y.snap;if(S===C)return C;const v=zc(o,S,I);return A(v,R),y.snap},draftRoot:_,draftNode:I}},f=(m={})=>u(m),l=(m,g={})=>u().finish(m,g),i=(m,g)=>{const[A,_,I]=g;return an(e,Le.current(s)),u({handleCbReturn:A,enableDep:_}).finish(m,su(I))},y=pr(n,{sharedRoot:e,sharedState:t,setState:(m,g)=>i(m,[!0,!0,g]),setDraft:(m,g)=>i(m,[!1,!0,g]),insSetState:(m,g)=>i(m,[!0,!1,g]),insSetDraft:(m,g)=>i(m,[!1,!1,g]),setStateFactory:f,innerSetState:l,ruleConf:c,isDeep:a});return y.sync=Wo(y),y.syncer=jo(y),Sc(e,y),y}function Zu(e,t){const n=au(e,t),{sharedRoot:r,sharedState:o}=na(n),s=Ju(r,o,n);Rc(r,n),Yc(),Sn({target:r,dict:n.mutateFnDict});const{draft:c,draftRoot:a}=un(s,{isTop:!0});return s.reactive=c,s.reactiveRoot=a,vc(n.moduleName,s.loc),Va(s.usefulName),dc(s),{sharedRoot:r,sharedState:o,internal:s,parsedOptions:n}}var{USER_STATE:Xo}=Z,{MUTATE:Qu,ACTION:zo}=H;function wn(e,t){Xo===(t||Xo)&&!sn()&&(ra(e,se),Pa(e,se))}function Jo(e,t){const{createFn:n,ldAction:r,actionDict:o,actionCreator:s,internal:c,apiCtx:a,forTp:u=!1}=e;Be(n,{internal:c,from:zo,apiCtx:a});const f={},l={};return Object.keys(o).forEach(i=>{const d=o[i],p=u?d.__task:d,h=s(!1)(p,i,t);h.__fnName=i,l[i]=h;const E=(...y)=>{const m=h(...y);return yu(p)?Promise.resolve(m).then(g=>g.result):m.result};E.__fnName=i,f[i]=E}),{actions:f,eActions:l,getLoading:()=>r.getLoading(f),useLoading:()=>r.useLoading(f)[0],useLoadingInfo:()=>r.useLoading(f)}}function Zo(e,t,n){const{state:r,stateRoot:o,isAtom:s}=e,c=Lt(n);return O(t)?t({state:r,stateRoot:o,isAtom:s,extraBound:c}):t}function Qo(e){const{common:t,ldMutate:n,mutateFnDict:r,extra:o}=e,s=Zo(t,r,o),c=Dn(t.stateRoot,o)(s);return{witnessDict:c,getLoading:()=>n.getLoading(c),useLoading:()=>n.useLoading(c)[0],useLoadingInfo:()=>n.useLoading(c)}}function qu(e){const{common:t,ldMutate:n,inital:r,mutateFnDict:o}=e,{stateRoot:s,useState:c,state:a,isAtom:u}=es(t.apiCtx,r),f=Y(w({},t),{stateRoot:s,state:a,isAtom:u,internal:B(s)}),l=Qo({common:f,ldMutate:n,mutateFnDict:o,extra:t.stateRoot});return w({derivedState:s,useDerivedState:c},l)}function ei(e){const{common:t,deriveFnDict:n,throwErr:r}=e,o=Zo(t,n),{apiCtx:s,stateRoot:c}=t,a={},u={};return Object.keys(o).forEach(l=>{const i=Ko(o[l],c);a[l]=i,u[l]={runDerive:d=>Ja(i,d!=null?d:r),runDeriveTask:d=>Za(i,d!=null?d:r),useDerived:d=>Rn(s,i,d)[0],useDerivedInfo:d=>Rn(s,i,d)}}),{result:new Proxy(a,{get:(l,i)=>a[i].val}),helper:u}}function ti(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(o=>{const s=n[o];s.enabled||(s.enabled=!0,r[o]=s)}),Dn(t.sharedState)(r)}}function ni(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}}function se(e,t){const{stateType:n,apiCtx:r}=e;wn(r,n);const{sharedRoot:o,sharedState:s,internal:c}=Zu(e,t),{syncer:a,sync:u,forAtom:f,setState:l,setDraft:i,sharedKey:d,sharedKeyStr:p,rootValKey:h,reactive:E,reactiveRoot:y}=c,m=Eo(o),g=m(),A={internal:c,from:Qu,apiCtx:r},_=se,I=Zr(_,Y(w({},A),{from:zo})),S=Zr(_,A),R={createFn:_,internal:c,apiCtx:r,state:s,stateRoot:o,isAtom:f},C=Y(w({},R),{ldAction:I,actionCreator:m});return{state:s,stateVal:s,stateRoot:o,setState:l,setDraft:i,setEnableMutate:v=>ti(v,c),getOptions:()=>ni(c),setOnReadHook:v=>c.onRead=v,defineActions:v=>K=>Jo(Y(w({},C),{actionDict:K}),v),defineTpActions:v=>K=>Jo(Y(w({},C),{actionDict:K,forTp:!0}),v),defineMutateDerive:v=>K=>qu({common:R,ldMutate:S,inital:v,mutateFnDict:K}),defineMutateSelf:()=>v=>Qo({common:R,ldMutate:S,mutateFnDict:v}),defineFullDerive:v=>K=>ei({common:R,deriveFnDict:K,throwErr:v}),mutate:bo(o),runMutate:v=>Ro(o,v),runMutateTask:v=>To(o,v),action:m,call:(v,K,T,D)=>g(v,T,D)(K),useState:v=>Io(r,o,v),useStateX:v=>wo(r,o,v),useForceUpdate:v=>Co(r,o,v),useLocalState:v=>No(r,v),useLocalForceUpdate:()=>Po(r),getMutateLoading:S.getLoading,useMutateLoading:S.useLoading,getActionLoading:I.getLoading,useActionLoading:I.useLoading,getSnap:v=>dr(o,v),sync:u,syncer:a,sharedKey:d,sharedKeyStr:p,rootValKey:h,reactive:E,reactiveRoot:y,reactiveDesc:v=>Pr(o,v),useReactive:v=>bn(r,o,v),useReactiveX:v=>Uo(r,o,v),flush:v=>an(o,v),isAtom:f}}function qo(e,t,n){const r=se({apiCtx:e,rawState:t},n);return[r.stateRoot,r.setState,r]}function es(e,t,n){return se({apiCtx:e,rawState:t},n)}function ri(e,t,n){const r=se({apiCtx:e,rawState:t,forAtom:!0},n);return[r.stateRoot,r.setState,r]}function oi(e,t,n){return se({apiCtx:e,rawState:t,forAtom:!0},n)}function ts(e,t){const{label:n,isSyncer:r}=t,o=pe(e,{label:n});return(r?jo:Wo)(o)}function si(e){return ts(e,{label:"sync"})}function ci(e){return ts(e,{label:"syncer",isSyncer:!0})}var ai=100,ui=5e3;function ii(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function fi(e,t=!1){const n=Q();e&&(n.initCount+=1);const r=wc(),o=ii(r,t);return Cr(e).set(r,o),o}function li(e){const t=Q();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function di(e,t){const n=Q(),r=Cr(t);if(r.delete(e),t&&r.size===ai&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const o=Date.now();r.forEach((s,c)=>{!s.mounted&&o-s.time>ui&&r.delete(c)})}}function pi(e,t){const n=Q();n.runningKey=e.key,n.isDynamic=t}function yi(e){const t=Q();t.runningKey="",t.isDynamic=!1,e.collected=!0}function hi(e,t,n){Hu(e,n,{manualDepKeys:t.depKeys})}function ns(e,t,n){let r={loading:!1,err:null,ok:!0};return hi(e,t,n),t.results.forEach(o=>{const s=_n(e,{result:o,forAtom:ie(o),showLoading:t.enableStatus});s.status.ok||(r=s.status)}),r}function rs(e,t,n){e.react.useEffect(()=>(t.mounted||li(t),()=>{di(t.key,n)}),[t])}var mi=()=>!0,Mn=e=>e;function gi(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function Fn(e,t,n,r,o){const s=t;return s.displayName=n,r?e.react.memo(s,o):s}function os(e,t){const{sharedState:n,depKey:r,keyPath:o,compare:s,sharedKey:c,format:a=Mn}=t;return Fn(e,function(){const f=ln(e,n,{arrDep:!0});f.isFirstRender&&(o.length>=2?gi(o).forEach(d=>{f.recordDep({sharedKey:c,depKey:W(d,c),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},qe)}):f.recordDep({sharedKey:c,depKey:r,keyPath:o}));const l=ue(f.internal.rawState,o);return a(l)},"HeluxSignal",!0,s)}function kn(e,t){return Fn(e,function(){const{result:r,format:o=Mn}=t,s=_n(e,{result:r,forAtom:!0});return o(s.proxyResult.val)},"HeluxDerivedAtomSignal",!0,t.compare)}function Ei(e,t){return Fn(e,function(){const{result:r,keyPath:o,format:s=Mn}=t;return _n(e,{result:r,forAtom:!1}),s(ue(r,o))},"HeluxDerivedSignal",!0,t.compare)}function ss(e,t){const{isDynamic:n,cb:r,props:o,ref:s}=t,{collected:c,status:a}=e;c||pi(e,n);const f=r(o,{props:o,status:a,read:As,ref:s})||"";return c||yi(e),f}function cs(e,t,n){const r=ie(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const o=kn(e,{result:n});return e.react.createElement(o,{status:{loading:!1,err:null,ok:!0}})}return Zn(n)}function as(e,t,n,r){const{memo:o=!0,compare:s}=r||{},{key:c}=t,{react:a}=e,u=a.forwardRef||k,f=n();let l=u(f);ce()&&(f.displayName="HeluxKeyedBlockForHMR",l=u((d,p)=>(p&&Ts(p,"current")&&(t.ref=p),a.createElement(f,Y(w({},d),{key:c})))));const i=o?a.memo(l,s):l;return i.displayName="HeluxBlock",i[Ft]=!0,i}function vi(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,{useForceUpdate:c}=o.hookImpl,a=r?rs:k;return as(o,s,()=>(u,f)=>{const l=s.ref||f,i=ss(s,{isDynamic:r,cb:n,props:u,ref:l}),d=c();return ns(o,s,d),a(o,s,r),cs(o,s,i)},t)}function Si(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,c=r?rs:k,{useForceUpdate:a}=o.hookImpl,{useEffect:u}=o.react;return as(o,s,()=>(f,l)=>{const i=s.ref||l,d=ss(s,{isDynamic:r,cb:n,props:f,ref:i}),p=a(),h=ns(o,s,p);c(o,s,r);const E=s.status.loading,y=h.loading;return u(()=>{E!==y&&p()},[E,y]),s.status=h,cs(o,s,d)},t)}function us(e,t){const n=fu(t),{enableStatus:r}=n,o=Y(w({},e),{blockCtx:fi(e.isDynamic,r)});return r?Si(o,n):vi(o,n)}function Ai(e,t,n){return us({apiCtx:e,isDynamic:!1,cb:t},n)}function is(e,t,n){return us({apiCtx:e,isDynamic:!0,cb:t},n)}function fs(e,t,n){const{react:r}=e;if(t&&t[Ft])return r.createElement(t);const o=mi;if(O(t)){const d=is(e,t,{compare:o});return r.createElement(d)}if(ie(t)){const d=kn(e,{result:t,compare:o,format:n});return r.createElement(d)}if(De(t)){const d=re(t),p=_t("val",d),E=os(e,{sharedKey:d,sharedState:t,depKey:p,keyPath:["val"],compare:o,format:n});return r.createElement(E)}const s=ta(),{sharedKey:c,val:a,stateOrResult:u,depKey:f,keyPath:l,isDerivedResult:i}=s;if(t===a&&u){if(s.isDerivedAtom){const p=kn(e,{result:u,compare:o,format:n});return r.createElement(p)}if(i){const p=Ei(e,{result:u,keyPath:l,compare:o,format:n});return r.createElement(p)}const d=os(e,{sharedKey:c,sharedState:u,depKey:f,keyPath:l,compare:o,format:n});return r.createElement(d)}return t}var{shallowCompare:Ki,isDiff:Di,isDraft:_i}=$.limuUtils,Ri=qo,Ti=fs,bi={EVENT_NAME:wt,RECORD_LOADING:Mt,VER:Gn,LIMU_VER:Ns};function ls(e,t,n){return t(e,n)}function Ii(e,t){return ls(e,t)}function wi(e,t){return{build:n=>ls(e,t,n)}}var Mi=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function Fi(e){return e.startsWith("use")||Mi.includes(e)}function ki(e){return Object.assign({useSyncExternalStore:k},e)}function Ci(e,t){const n=Ls(e),r=w({},n),o={react:ki(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,a]=e.useState({});return()=>t(()=>a({}))});const s=Yn;return Object.keys(s).forEach(a=>{const u=s[a];Fi(a)?r[a]=u.bind(null,o):r[a]=u}),Object.assign({model:a=>Ii(r,a),modelFactory:a=>wi(r,a)},r)}function Oi(e){const{inited:t,API:n}=oc();if(t)return n;const{heluxCtxKey:r,standalone:o,transfer:s,reactLib:c,act:a}=e,u=J[r],f=(l,i)=>{const d=i||qn(),p=Ci(c,a);return rr({ROOT:d,inited:!0,api:p}),J[l]=d,p};if(!u)return f(r);if(o)return f(`${String(r)}_${Date.now()}`);if(s){const l=qn();rr({ROOT:l,inited:!0}),s(u,l)}return f(r,u)}var Li=x(70079),xi=x.t(Li,2),ds=Oi({heluxCtxKey:"__HELUX__",reactLib:xi}),Pi=ds.share,{atom:Ni,atomx:Ui,share:Bi,sharex:Vi,derive:Yi,deriveDict:Gi,defineDeriveTask:Hi,defineDeriveFnItem:ji,runDerive:$i,runDeriveTask:Wi,watch:Xi,watchEffect:zi,useAtom:Ji,useAtomX:Zi,useReactive:Qi,useReactiveX:qi,useDerived:ef,useWatch:tf,useWatchEffect:nf,useGlobalId:rf,useService:of,useOnEvent:sf,useMutable:cf,useMutateLoading:af,useActionLoading:uf,useEffect:ff,useLayoutEffect:lf,useStable:df,useObject:pf,useLocalForceUpdate:yf,useGlobalForceUpdate:hf,action:mf,signal:gf,block:Ef,dynamicBlock:vf,$:Sf,mutate:Af,mutateDict:Kf,runMutate:Df,runMutateTask:_f,defineMutateFnItem:Rf,sync:Tf,syncer:bf,model:If,modelFactory:wf,emit:Mf,on:Ff,init:kf,reactiveDesc:Cf,flush:Of,isAtom:Lf,isSharedState:xf,isDerivedAtom:Pf,isDerivedResult:Nf,isDraft:Uf,storeSrv:Bf,shallowCompare:Vf,markRaw:Yf,isDiff:Gf,produce:Hf,getMutateLoading:jf,getActionLoading:$f,getDeriveLoading:Wf,getRawState:Xf,getSnap:zf,getAtom:Jf,addMiddleware:Zf,addPlugin:Qf,cst:qf}=ds}}]);
}());