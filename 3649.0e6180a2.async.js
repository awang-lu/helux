!(function(){"use strict";var el=Object.defineProperty,tl=Object.defineProperties;var nl=Object.getOwnPropertyDescriptors;var At=Object.getOwnPropertySymbols;var Es=Object.prototype.hasOwnProperty,vs=Object.prototype.propertyIsEnumerable;var gs=(N,U,L)=>U in N?el(N,U,{enumerable:!0,configurable:!0,writable:!0,value:L}):N[U]=L,w=(N,U)=>{for(var L in U||(U={}))Es.call(U,L)&&gs(N,L,U[L]);if(At)for(var L of At(U))vs.call(U,L)&&gs(N,L,U[L]);return N},H=(N,U)=>tl(N,nl(U));var Ss=(N,U)=>{var L={};for(var T in N)Es.call(N,T)&&U.indexOf(T)<0&&(L[T]=N[T]);if(N!=null&&At)for(var T of At(N))U.indexOf(T)<0&&vs.call(N,T)&&(L[T]=N[T]);return L};var As=(N,U,L)=>new Promise((T,J)=>{var ve=W=>{try{Se(L.next(W))}catch(Z){J(Z)}},$e=W=>{try{Se(L.throw(W))}catch(Z){J(Z)}},Se=W=>W.done?T(W.value):Promise.resolve(W.value).then(ve,$e);Se((L=L.apply(N,U)).next())});(self.webpackChunkhelux_docs=self.webpackChunkhelux_docs||[]).push([[3649],{73649:function(N,U,L){L.r(U),L.d(U,{$:function(){return Sf},action:function(){return mf},addMiddleware:function(){return Zf},addPlugin:function(){return Qf},atom:function(){return Ni},atomx:function(){return Ui},block:function(){return Ef},createShared:function(){return Pi},cst:function(){return qf},defineDeriveFnItem:function(){return ji},defineDeriveTask:function(){return Hi},defineMutateFnItem:function(){return Rf},derive:function(){return Yi},deriveDict:function(){return Gi},dynamicBlock:function(){return vf},emit:function(){return Mf},flush:function(){return Of},getActionLoading:function(){return $f},getAtom:function(){return Jf},getDeriveLoading:function(){return Wf},getMutateLoading:function(){return jf},getRawState:function(){return Xf},getSnap:function(){return zf},init:function(){return kf},isAtom:function(){return Lf},isDerivedAtom:function(){return Pf},isDerivedResult:function(){return Nf},isDiff:function(){return Gf},isDraft:function(){return Uf},isSharedState:function(){return xf},markRaw:function(){return Yf},model:function(){return If},modelFactory:function(){return wf},mutate:function(){return Af},mutateDict:function(){return Kf},on:function(){return Ff},produce:function(){return Hf},reactiveDesc:function(){return Cf},runDerive:function(){return $i},runDeriveTask:function(){return Wi},runMutate:function(){return Df},runMutateTask:function(){return _f},shallowCompare:function(){return Vf},share:function(){return Bi},sharex:function(){return Vi},signal:function(){return gf},storeSrv:function(){return Bf},sync:function(){return Tf},syncer:function(){return bf},useActionLoading:function(){return uf},useAtom:function(){return Ji},useAtomX:function(){return Zi},useDerived:function(){return ef},useEffect:function(){return ff},useGlobalForceUpdate:function(){return hf},useGlobalId:function(){return rf},useLayoutEffect:function(){return lf},useLocalForceUpdate:function(){return yf},useMutable:function(){return cf},useMutateLoading:function(){return af},useObject:function(){return pf},useOnEvent:function(){return sf},useReactive:function(){return Qi},useReactiveX:function(){return qi},useService:function(){return of},useStable:function(){return df},useWatch:function(){return tf},useWatchEffect:function(){return nf},watch:function(){return Xi},watchEffect:function(){return zi}});function T(e,t){e.includes(t)||e.push(t)}function J(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function ve(e){return Array.from(new Set(e))}function $e(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function Se(e,t){let n="";const r=e.length;for(let o=0;o<r;o++){const s=e[o];if(t.startsWith(s)){n=s;break}}return n}function W(e,t,n){if(!e)return[];const r=e(t,n);return Array.isArray(r)?r:[r]}var Z=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),On=!1;function F(...e){}var Ks=F;function Ds(...e){return e}function Ae(...e){return[]}function rl(...e){}var _s=Object.prototype.toString,Rs="[object Map]";function ol(){return!(typeof window!="undefined"&&window.document)}function Kt(e){return _s.call(e)===Rs}function Ln(e){return e===Number.MAX_SAFE_INTEGER}function ae(){return!(!On&&Z.name!=="previewFrame"&&!Z.BrowserFS)}function z(e){return e&&typeof e=="object"&&!Array.isArray(e)}function xn(e){return e&&typeof e=="object"}function O(e){return typeof e=="function"}function sl(e){return On?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function Dt(e){return typeof e=="symbol"}function _t(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&O(e.then)}function cl(e){try{return e.test,!1}catch(t){return!0}}function Ie(){return typeof Proxy=="function"}function ue(e,t){const{throwErr:n=!1,prefixLabel:r="",suffixLabel:o=", see details in console.",logErr:s=!0,alertErr:c}=t||{};let a=e,u=!1;if(e instanceof Error&&(u=!0,a=e.message),(typeof c=="boolean"?c:ae())&&Z.alert&&e&&Z.alert(`${r}${a}${o}`),s&&console.error(e),n)throw u?e:new Error(String(e))}function Ke(e,t=0){t===0?(console.error(e),ae()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function we(e){return Ln(e)?1:e+1}var Ts=!!Reflect,bs=Object.prototype.hasOwnProperty;function Is(e,t){return Ts?Reflect.has(e,t):bs.call(e,t)}function Me(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function Fe(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function Pn(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function Nn(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function ie(e,t){let n,r=e;return t.forEach(o=>{n=Kt(r)?Nn(r,o):r[o],r=n}),n}function Un(e,t,n){let r=e;const o=t.length-1;t.forEach((s,c)=>{const a=Kt(r);if(c===o)return void(a?r.set(s,n):r[s]=n);r=a?Nn(r,s):r[s]})}function ws(){return Ke("changing shared state is invalid"),!0}function al(e){return e}function Rt(e,t){return`${t}/${e}`}function Tt(e){return e&&Ie()}var Ms=Object.defineProperty,bt={};((e,t)=>{for(var n in t)Ms(e,n,{get:t[n],enumerable:!0})})(bt,{useEffect:()=>Os,useEffectLogic:()=>wt,useForceUpdate:()=>Bn,useLayoutEffect:()=>Cs,useObject:()=>xs,useObjectLogic:()=>Yn,useStable:()=>Vn});var Fs=0,We=new Map,It=0;function ks(e,t){const n=()=>{const r=t();return()=>{We.delete(e),r&&r()}};if(function(r){It||(It=r)}(e),function(r){const o=We.get(r);o?o.count+=1:We.set(r,{count:1})}(e),It%2!=0)return n();{const r=function(o){return We.get(o)}(e);if(r&&r.count>1)return n()}}function wt(e,t,n){const{useState:r,useLayoutEffect:o,useEffect:s}=e.react,{isLayout:c,deps:a}=n,[u]=r(()=>++Fs);(c?o:s)(()=>ks(u,t),a)}function Cs(e,t,n){wt(e,t,{isLayout:!0,deps:n})}function Os(e,t,n){wt(e,t,{deps:n})}function Bn(e){const[,t]=e.react.useState({});return()=>t({})}function Ls(e){const{data:t}=e.current;O(t)?e.current.wrap=(...n)=>e.current.data(...n):z(t)?e.current.wrap=function(n,r){if(!Ie()){const s={};return Object.keys(n).forEach(c=>{const a=n[c];O(a)?s[c]=(...u)=>r.current.data[c](...u):Object.defineProperty(s,c,{get:()=>r.current.data[c],set(u){r.current.data[c]=u}})}),s}const o={};return new Proxy(n,{get(s,c){const a=s[c];return O(a)?Me(o,c,(...u)=>r.current.data[c](...u)):a}})}(t,e):e.current.wrap=t}function Vn(e,t){const{useRef:n,useMemo:r}=e.react,o=n({data:t,wrap:{},inited:!1});return o.current.data=r(()=>t,[t]),o.current.inited||(Ls(o),o.current.inited=!0),o.current.wrap}function Yn(e,t,n,r){const{useState:o,useRef:s,useEffect:c}=e.react,[a]=o(t),u=Bn(e),l=s({state:null,unmount:!1,shouldCopy:!0}),i=Vn(e,{setState(f){const d=l.current;if(d.unmount)return;let p;const{state:h}=d;n?(p=n(f,d.state||a),r&&p?(d.state=p,d.shouldCopy=!1):d.shouldCopy=!0):(p=(O(f)?f(h):f)||{},d.shouldCopy=!0),Object.assign(a,p||{}),u()},getLatestState(){const f=l.current;return f.shouldCopy&&(f.state=w({},a),f.shouldCopy=!1),f.state}});return c(()=>{const f=l.current;return f.unmount=!1,()=>{f.unmount=!0}},[l]),[a,i.setState,i]}function xs(e,t){return Yn(e,t)}function Ps(e){const t={},n={react:e},r=bt;return Object.keys(bt).forEach(o=>{t[o]=r[o].bind(null,n)}),t}var X=L(47622),Ns=Object.defineProperty,Us=(e,t)=>{for(var n in t)Ns(e,n,{get:t[n],enumerable:!0})},Gn={};Us(Gn,{$:()=>Ti,action:()=>Ao,addMiddleware:()=>ac,addPlugin:()=>lc,atom:()=>ri,atomx:()=>oi,block:()=>Ai,createShared:()=>Ri,cst:()=>bi,currentDraftRoot:()=>Uc,defineDeriveFnItem:()=>Du,defineDeriveTask:()=>Ku,defineMutateFnItem:()=>bu,derive:()=>Ro,deriveDict:()=>Au,dynamicBlock:()=>ds,emit:()=>hc,flush:()=>un,getActionLoading:()=>Nu,getAtom:()=>qn,getDeriveLoading:()=>qa,getMutateLoading:()=>xu,getRawState:()=>Kc,getSnap:()=>yr,init:()=>cc,isAtom:()=>Re,isDerivedAtom:()=>fe,isDerivedResult:()=>qs,isDiff:()=>Di,isDraft:()=>_i,isSharedState:()=>Qs,markRaw:()=>X.Xl,mutate:()=>Mo,mutateDict:()=>_n,on:()=>mc,produce:()=>X.Uy,reactiveDesc:()=>Ur,runDerive:()=>za,runDeriveTask:()=>Ja,runMutate:()=>Io,runMutateTask:()=>wo,shallowCompare:()=>Ki,share:()=>ns,sharex:()=>rs,signal:()=>ps,storeSrv:()=>Gu,sync:()=>si,syncer:()=>ci,useActionLoading:()=>Uu,useAtom:()=>Fo,useAtomX:()=>ko,useDerived:()=>Tn,useGlobalForceUpdate:()=>xo,useGlobalId:()=>Lu,useLocalForceUpdate:()=>Bo,useMutable:()=>Vo,useMutateLoading:()=>Pu,useOnEvent:()=>Bu,useReactive:()=>In,useReactiveX:()=>Yo,useService:()=>Yu,useWatch:()=>ju,useWatchEffect:()=>$u,watch:()=>du,watchEffect:()=>pu});var Hn="4.2.1",Bs=X.TT,Mt={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},Ft={NO:"no",PRIVATE:"private",GLOBAL:"global"},jn=0,$n=Symbol,Vs=typeof $n=="function";function ee(e){return Vs?$n(e):(jn+=1,`__HELUX_SYMBOL_${jn}__`)}var Ys="__proto__",Gs=Ie(),Hs=ee("HeluxUndefined"),Wn=ee("HeluxMutateFnItem"),Xe=ee("HeluxFnKey"),ze=ee("HeluxSharedKey"),Xn=ee("HeluxReactiveMeta"),kt=ee("HeluxIsBlock"),De=ee("HeluxIsAtom"),ke=ee("HeluxIsDerivedAtom"),Je=[ze,De,ke,kt],Ze="SingleMutate",js="HeluxGlobalLoading",$s=6,Ws=!0,zn=2e3,Xs=20,Ce="1",Ct="2",Qe=1,qe=2,Jn=3,_e="|",et={TASK:"task",MAY_TRANSFER:"may_transfer"},te={STATIC:"static",HOOK:"hook"},Q={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},Zn="derive",Qn="watch",tt="Object",zs="Map",Js="Array",Zs="Other",j={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function Re(e){var t;return e&&(t=e[De])!=null?t:!1}function Qs(e){return e?e[De]!==void 0:!1}function fe(e){return e&&e[ke]||!1}function qs(e){return e?e[ke]!==void 0:!1}function qn(e){return Re(e)||fe(e)?e.val:e}function ec(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],delPathAoa:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,SKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function tc(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function nc(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function rc(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function er(){const e={};return{on:(t,n)=>{Me(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(o=>o(...n))},off:(t,n)=>{const r=e[t]||[],o=r.findIndex(s=>s===n);o>=0&&r.splice(o,1)},canEmit:t=>e[t]}}function tr(){const e={VER:Hn,LIMU_VER:X.TT,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:er(),userBus:er(),mod:{},middlewares:[],plugins:[],sharedScope:rc(),fnScope:ec(),insScope:nc(),blockScope:tc(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var nt={},nr=!1,rr=null,or=!1;function G(){return nt.ctx||{}}function oc(){return nt}function sr(e){nt=e.ROOT,rr=e.api,nr=e.inited}function sc(){return{ROOT:nt,inited:nr,API:rr}}function cc(e){if(or)return!1;or=!0;const{isRootRender:t=!0}=e;return G().isRootRender=t,!0}function ac(e){const{middlewares:t}=G();t.push(e)}function uc(e,t,n,r){const{middlewares:o}=G();if(!o.length)return;const s={},{sharedKey:c,moduleName:a,forAtom:u}=e,i={forAtom:u,draftRoot:t,draft:n,sharedKey:c,moduleName:a,setData:(f,d)=>s[f]=d,data:s,idx:0,sn:r};o.forEach((f,d)=>{f(H(w({},i),{idx:d}))})}var{ON_DATA_CHANGED:Ot,ON_SHARE_CREATED:cr,ON_ERROR_OCCURED:ic}=Mt,fc=[Q.GLOGAL_LOADING,Q.PRIVATE_LOADING];function lc(e){const{plugins:t,bus:n}=G();t.push(e);const r={on:(o,s)=>n.on(o,s),onStateChanged:o=>n.on(Ot,o)};e.install(r)}function dc(e,t){const{bus:n}=G();if(n.canEmit(Ot)){const{from:r,desc:o}=t,{forAtom:s,sharedKey:c,moduleName:a,snap:u,usefulName:l,stateType:i}=e;let f;fc.includes(i)?f=`${l}/setState`:f=`${l}@${r||"Api"}/${o}`,n.emit(Ot,{forAtom:s,snap:u,sharedKey:c,moduleName:a,usefulName:l,type:f})}}function pc(e){const{bus:t}=G();if(t.canEmit(cr)){const{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c}=e,a=`${c}@FactoryApi/createShared`;t.emit(cr,{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c,type:a})}}function ar(e,t,n){const{bus:r}=G();if(!r.canEmit(t))return!1;const{sharedKey:o,moduleName:s}=e;return r.emit(t,{moduleName:s,sharedKey:o,data:n}),!0}function ur(e,t){ar(e,ic,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function yc(){const{userBus:e}=G();return e}function hc(e,...t){const{userBus:n}=G();n.emit(e,...t)}function mc(e,t){const{userBus:n}=G();return n.on(e,t),()=>n.off(e,t)}function gc(e,t){return e.__proto__=t,e}function Ec(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var Lt=Object.setPrototypeOf||({__proto__:[]}instanceof Array?gc:Ec);function vc(e){const t=Object.create(null);return Lt(t,w({},Object.prototype)),e&&Object.assign(t,e),t}function ir(e){if(O(e))return;const t=Object.create(null);return Lt(t,Object.prototype),Lt(e,t),e}function fr(e,t,n){return e[t]=n,!0}function lr(e,t){return e[t]}function Oe(e,t){const{set:n=fr,get:r=lr,obj:o={}}=t||{};return Object.keys(e).forEach(s=>{Object.defineProperty(o,s,{enumerable:!0,configurable:!1,set:function(c){return n(e,s,c)},get:function(){return r(e,s)}})}),o}function le(e,t){const{set:n=fr,get:r=lr}=t||{};if(Ie())return new Proxy(e,{set(c,a,u){return n(c,a,u)},get(c,a){return r(c,a)}});const o=vc();return Oe(o,{obj:o,set:n,get:r})}var Le=G();function rt(e){const n=G()[e];return Le[e]=n,n}function q(){return Le.blockScope||rt("blockScope")}function V(){return Le.fnScope||rt("fnScope")}function ne(){return Le.sharedScope||rt("sharedScope")}function dr(){return Le.insScope||rt("insScope")}function pr(){const{INTERMAL_MAP:e}=ne();return e}function Sc(e,t){if(!e||!ae()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:o}=ne();let s=[],c=!1;if(n.forEach(a=>{a.moduleName===e&&a.loc===t&&a.stateType===Q.USER_STATE&&s.push(a.sharedKey)}),s.length>1){const a=s[0],u=n.get(a);n.delete(a),u&&(r.delete(u.sharedKey),o.delete(u.rawState))}return c}function xe(e){return pr().get(e)}function Y(e){const t=re(e);return xe(t)}function Ac(e,t){const n=pr(),r=re(e);n.set(r,t)}function Kc(e){return Y(e).rawState}function yr(e,t=!0){const n=Y(e);return t?n.prevSnap:n.snap}function re(e){return e&&(e[ze]||ne().STATE_SHARED_KEY_MAP.get(e))||0}function xt(e){let t={state:{},stateRoot:{},isAtom:!1};if(!e)return t;const n=Y(e);if(n){const{sharedState:r,sharedRoot:o}=n;t={state:r,stateRoot:o,isAtom:n.forAtom}}return t}function Dc(e){const t=ne(),{STATE_SHARED_KEY_MAP:n}=t,r=we(t.keySeed);return n.set(e,r),t.keySeed=r,r}function _c(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=ne();n.set(e,t),r.set(t,e)}function Rc(e){return ne().SHARED_KEY_STATE_MAP.get(e)}function Tc(e,t){const{rootState:n,ctx:r}=oc(),{moduleName:o,usefulName:s}=t,c=n[s],a=Y(c);if(o&&a&&a.loc!==t.loc){const u=`
loc1:${a.loc} 
loc2:${t.loc}`;return Ke(`only-dev-mode tip: moduleName ${o} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+u)}n[s]=e,r.mod[s]=Y(e)}var bc={innerSetState:F};function hr(e,t){const{rawState:n,forAtom:r}=e,o=new Map,s={},c={},a=[],u=w({},n);let l=u;return r&&(l=n.val),H(w(w({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:F,syncer:F,snap:u,prevSnap:u,rawStateVal:l},e),t),{insCtxMap:o,key2InsKeys:s,id2InsKeys:c,recordId(i,f){if(!i)return;const d=Me(c,i,[]);T(d,f)},delId(i,f){i&&J(c[i]||[],f)},recordDep(i,f){const d=Me(s,i,[]);T(d,f)},delDep(i,f){J(s[i]||[],f)},mapInsCtx(i,f){o.set(f,i)},delInsCtx(i){o.delete(i)},extra:{},loadingInternal:bc,level1ArrKeys:a})}var Ic={Mutate:"",Reactive:"r",[te.STATIC]:"s",[te.HOOK]:"h"};function wc(){const e=dr(),t=we(e.keySeed);return e.keySeed=t,t}function Mc(){const e=q(),{keySeed:t,keyPrefix:n}=e,r=we(t);e.keySeed=r;let o=n;return Ln(t)&&(o=we(n),e.keyPrefix=o),`${o}_${r}`}function Fc(){const e=G(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function Pt(e){const t=Ic[e],r=V().keySeed,o=we(r[e]);return r[e]=o,`${t}${o}`}function kc(){return Pt("Reactive")}var{MAY_TRANSFER:Cc}=et,{SET_STATE:Oc,REACTIVE:Lc}=j,xc=()=>({isReplaced:!1,replacedValue:null}),Pc=()=>{},Nc=Ut({isFake:!0});function mr(e,t,n=F){const{desc:r="",onRead:o,from:s=Lc,depKeys:c=[],isTop:a=!1,expired:u=!1,insKey:l=0}=t;return{draft:e,finish:n,modified:!1,expired:u,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:F,data:[],isTop:a,key:"",fnKey:"",depKeys:c,writeKeys:[],desc:r,onRead:o,from:s,insKey:l}}function Nt(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:o=Oc,enableDep:s=!1,handleCbReturn:c=!0,sn:a=Fc(),isFirstCall:u=!1,desc:l="",onRead:i}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:c,draftVal:null,from:o,isReactive:r,enableDep:s,sn:a,isFirstCall:u,desc:l,onRead:i}}function Pe(e,t,n){const{isChanged:r=!0,parentKeyPath:o=[],op:s="set",parentType:c="Object"}=n,a=o.slice();return a.push(e),{isChanged:r,isCustom:!1,op:s,immutBase:!1,key:e,value:t,proxyValue:t,parentType:c,keyPath:o,fullKeyPath:a,isBuiltInFnKey:!1,replaceValue:F,getReplaced:xc}}function Ut(e){const f=e||{},{desc:t="",fn:n=F,task:r=Pc,depKeys:o=[],writeKeys:s=[],deps:c=Ae,isFake:a=!1,onlyDeps:u=!1}=f,l=Ss(f,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return w({fn:n,task:r,deps:c,oriDesc:"",onlyDeps:u,desc:t,depKeys:o,writeKeys:s,checkDeadCycle:void 0,watchKey:"",isFake:a,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}},l)}function gr(){const e={fnKey:"",fn:F,subFnInfo:Nc,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:F,deps:Ae,status:{loading:!1,err:null,ok:!0},stateRoot:{},isStateAtom:!1,forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:Qe,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:Ce,proxyResult:{},updater:F,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:F},asyncType:Cc,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var Er={draftRoot:{val:null},isFake:!0,isAtom:!0},vr=Nt({}),ot=mr(!0,{expired:!0}),ul=Ut(),Sr=hr({rawState:{},forAtom:!1,usefulName:""},{}),Ar=gr(),st=Er,Bt=vr,Kr="",Vt=new Map,Yt=new Map,Gt=new Map,Ht=F,jt=[],$t="";function Uc(){return st}var Ne={current:()=>$t,set:e=>$t=e,del:()=>$t=""},Wt={current:()=>Ht,set:e=>Ht=e,del:()=>Ht=F},Ue={current:e=>Yt.get(e)||"SetState",set:(e,t)=>Yt.set(e,t),del:e=>Yt.delete(e)},Be={current:()=>jt,set:e=>jt=e,del:()=>jt=[]},oe={current:()=>Gt.get(Kr)||ot,markUsing:e=>Kr=e,set:(e,t)=>Gt.set(e,t),del:e=>Gt.delete(e)},Xt={current:e=>Vt.get(e),set:(e,t)=>Vt.set(e,t),del:e=>Vt.delete(e)},ct={current:()=>st,set:(e,t)=>{Object.assign(st,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>st=Er},zt={current:()=>Bt,set:e=>Bt=e,del:()=>Bt=vr};function Jt(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=V();return e[0]==="s"?t:n}function Bc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=V();Fe(n,e,[]).push(t)}function Vc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=V(),r=n.get(e);r&&J(r,t)}function Yc(e){const{DEPKEY_FNKEYS_MAP:t}=V(),{depKeys:n,fnKey:r}=e;n.forEach(o=>{const s=t.get(o)||[];J(s,r)})}function Dr(e,t){const{FNKEY_STATIC_CTX_MAP:n}=V(),{fnKey:r,prevLevelFnKeys:o}=e;o.forEach(s=>{var a;const c=(a=n.get(s))==null?void 0:a.nextLevelFnKeys;c&&(t?T(c,r):J(c,r))})}function Gc(){const{FNKEY_HOOK_CTX_MAP:e}=V();ae()&&e.forEach(t=>{t.isExpired=!0})}function _r(e,t,n){const r=n||Pt(t);return O(e)?e[Xe]=r:(ir(e),e.__proto__[Xe]=r),r}function Rr(e){return O(e)?e[Xe]||"":z(e)&&e.__proto__[Xe]||""}function de(e){return Jt(e).get(e)}function Zt(e){return Jt(e).get(e)||Ar}function Ve(e){const t=Rr(e);return de(t)||null}function Ye(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r,delPathAoa:o}=V();return{fnCtx:e?de(e):null,depKeys:t,delPathAoa:o,isIgnore:r,runningSharedKey:n}}function Hc(){return V().runningFnKey}var{USER_STATE:jc}=Q;function $c(e,t=8){let n="";if(ae()&&e)try{throw new Error("loc")}catch(r){const o=r.stack.split(`
`),s=o[1]||"";s.includes("webpack-internal")||s.includes("/node_modules/")?n=o.slice(0,16).join(" -> "):n=o.map(a=>a.substring(0,a.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function Tr(e){const[t,n]=e.split("/"),r=n.split(_e);return{sharedKey:Number(t),keyPath:r,depKey:e}}function br(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",o=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:o,sharedKey:t}}function $(e,t){try{return Rt(e.join(_e),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Wc(e,t){const{snap:n,prevSnap:r,stateType:o}=e;if(jc!==o)return!0;const{keyPath:s}=Tr(t);try{const c=ie(n,s),a=ie(r,s);return c!==a}catch(c){return!0}}function Xc(e,t){return Ie()?(0,X.OA)(e,{onOperate:t,compareVer:!0}):le(e,{get(n,r){const o=n[r],s=Pe(r,o,{isChanged:!1,parentKeyPath:[]});return t(s),o}})}function zc(e,t){if(t!==void 0){if(e)return{val:t};if(z(t))return t}}function Jc(e,t,n){const r=O(t)?t(n):t;return zc(e,r)}function at(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:o}=e.getReplaced();o&&(n=r)}return n}function Ir(e){return[Js,zs].includes(e)}function Zc(e){return Array.isArray(e)||Kt(e)}var{isObject:pe,getDataType:wr}=X.limuUtils;function Qt(e,t){return typeof e=="boolean"?e:t}function Mr(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(_e);return`${e}${_e}${r[0]}`}function Qc(e,t){Se(e,t)||T(e,t)}var qt=new Map;function Fr(e,t){let n=!1;const{depKey:r,keyPath:o,sharedKey:s}=e,{stopDepInfo:c,level1ArrKeys:a,recordCb:u}=t,l=qt.get(r);if(l)return u(l),!0;const{keys:i,isArrDict:f,depth:d,arrKeyStopDcit:p,stopArrDep:h}=c,m=Se(a,r),y=o.length>d;if(y||m){let E="",A=d;return m&&(A=d+1,p[m]===!1||h&&(y?E=$(o.slice(0,A),s):E=Mr(m,r))),E||(E=$(o.slice(0,A),s)),m||qt.set(r,E),u(E),!0}const g=String(s);for(const E of i){if(!r.startsWith(E)||E===g)continue;const A=f[E],R=A?Mr(E,r):E;A||qt.set(r,R),u(R),n=!0;break}return n}function en(e,t){const n=q(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:o,KEY_CTX_MAP:s,isDynamic:c}=n,u=(c?o:s).get(r);if(u){const{results:l,depKeys:i}=u;t?T(l,t):e.forEach(f=>T(i,f))}}}function ut(e,t){const n=ne(),{COMPARE_MAP:r}=n;let o=r.get(t);return o!==void 0?o:e.sharedKeyStr===t?n.isStateChanged:(o=Wc(e,t),r.set(t,o),o&&(n.isStateChanged=!0),o)}function kr(e,t,n){if(t.includes(n)&&ut(e,n))return!0;let r=!1;for(const o of t)o.startsWith(n)&&ut(e,o)&&(r=!0);return r}function qc(){const e=ne();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function tn(e=!0){const t=V();t.isIgnore=e}function Te(e,t){const{fnCtx:n,depKeys:r,isIgnore:o}=Ye(),s=t.specificCtx||n;if(!s){Wt.current()(e);return}const{DEPKEY_FNKEYS_MAP:c,SKEY_FNKEYS_MAP:a}=V(),{belongCtx:u,sharedKey:l}=t;if(l&&T(s.depSharedKeys,l),n&&u){n.isFirstLevel=!1,u.isAsync&&(n.isAsync=!0);const f=u.fnKey;T(s.prevLevelFnKeys,f),T(u.nextLevelFnKeys,n.fnKey)}const{fnKey:i}=s;e.forEach(f=>{if(Ys===f||o)return;n&&T(r,f);const d=Fe(c,f,[]);T(d,i);const[p]=f.split("/"),h=Fe(a,p,[]);T(h,i)})}function nn(e){e&&e.depKeys.forEach(t=>Te([t],{specificCtx:e}))}function Cr(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=V(),{fnKey:r}=e;t.set(r,e),Dr(e,!0);let o=n.get(r);o?o.c=2:(o={c:1,t:Date.now(),prev:0},n.set(r,o));const{c:s}=o;if(s===2){const c=de(r);nn(c)}}function Or(e){let t="";return e.depSharedKeys.forEach(n=>{var o;const r=((o=xe(n))==null?void 0:o.ver)||0;t+=`${r}_`}),t}function ea(e,t,n,r=!1){const{DEPKEY_FNKEYS_MAP:o,SKEY_FNKEYS_MAP:s}=V(),a=(r?s:o).get(t)||[],u=[],l=[];return a.forEach(i=>{const f=de(i);if(f&&kr(e,f.depKeys,t)){f.isFirstLevel&&u.push(i),f.isAsync&&f.fnType===Zn&&l.push(i);const d=n[i];d===void 0?n[i]=1:r||(n[i]=d+1)}}),{firstLevelFnKeys:u,asyncFnKeys:l}}function rn(e){Yc(e),Dr(e)}function ta(){const{FNKEY_HOOK_CTX_MAP:e}=V();if(e.size>=Xs){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:o,fnKey:s}=n;[Qe,Jn].includes(r)&&t-o>zn&&(rn(n),e.delete(s))})}}function on(e,t,n,r,o,s=!1,c=!1){const a=q();a.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:o,isDerivedResult:s,isDerivedAtom:c}}function na(){return q().latest}function Lr(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=q();return e?t:n}function xr(){return Ke("changing shared state is invalid"),!0}function it(e,t,n,r,o){return r===De?e?t:!1:r===ze?n:o}function sn(e,t,n){e.replaceValue(it(e.keyPath.length===0,t,n,e.key,e.value))}function ra(e){let t={};const{rawState:n,sharedKey:r,forAtom:o,onRead:s,isPrimitive:c,stopDepth:a}=e,u=(i,f)=>{const d=$(i,r);Te([d],{sharedKey:r}),en([d]),on(r,f,t,d,i)};if(Gs)t=(0,X.OA)(n,{customKeys:Je,onOperate:i=>{const{isBuiltInFnKey:f,isCustom:d}=i;if(d)return sn(i,o,r);if(!f){const{fullKeyPath:p}=i,h=at(i,s);u(p,h)}},compareVer:!0});else{const i=(f,d,p)=>Oe(f,{set:xr,get:(h,m)=>{const y=h[m];if(Je.includes(m))return it(d===1,o,r,m,y);const g=Pe(m,y,{isChanged:!1,parentKeyPath:p});if(d<a&&pe(y))return i(y,d+1,g.fullKeyPath);const E=at(g,s);return u(g.fullKeyPath,E),E}});t=i(n,1,[])}let l=t;return o&&(c?l=n.val:l=le(n,{set:xr,get:(i,f)=>t.val[f]})),_c(r,t),{sharedRoot:t,sharedState:l}}var Pr=null;function cn(){return Pr}function oa(e,t){const n=G();let r=n.globalEmpty;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:Q.GLOGAL_EMPTY}),s=Y(o);n.globalEmpty=o,n.globalEmptyInternal=s}return Pr=r,r}function an(e){const{GID_INSKEYS_MAP:t}=V();return Fe(t,e,[])}function sa(){return G().globalEmptyInternal}function Nr(e,t){if(!e)return;const n=an(e);T(n,t)}function ca(e,t){if(!e)return;const n=an(e);J(n,t)}var{REACTIVE:aa}=j,Ge=new Map;function ua(e){return!!(e&&!e.expired&&e.modified)}function ia(e){const{sharedKey:t}=e;e.expired=!0,oe.del(e.key);const n=Ue.current(t);return Ue.del(t),e.finish(null,{desc:n})}function Ur(e,t){const n=re(e);return t&&Ue.set(n,t),n}function un(e,t){const n=re(e);He(n,t)}function fa(){const e=oe.current();e.isTop&&He(e.sharedKey,e.desc)}function He(e,t){const n=Ge.get(e);ua(n)&&(t&&Ue.set(e,t),ia(n))}function la(e){const t=Ge.get(e)||ot;t.expired=!0}function da(e,t){const n=Ge.get(e)||ot;n.modified=!0,n.nextTickFlush(t)}function pa(e,t){const{from:n=aa,onRead:r}=t,{finish:o,draftRoot:s}=e.setStateFactory({isReactive:!0,from:n,handleCbReturn:!1,enableDep:!0,onRead:r}),c=mr(s,t,o);return c.key=kc(),c.sharedKey=e.sharedKey,c.nextTickFlush=a=>{const{expired:u,hasFlushTask:l}=c;u||(c.data=[a]),l||(c.hasFlushTask=!0,Promise.resolve().then(()=>{const[i]=c.data;He(e.sharedKey,i)}))},c}function Br(e,t,n){const{sharedKey:r}=e,{insKey:o=0,from:s}=t;let c=Ge.get(r)||ot;c.expired&&(c=pa(e,{isTop:!0,from:s}),Ge.set(r,c),oe.set(c.key,c),c.fnKey=Ne.current()),oe.markUsing(c.key),c.onRead=o?t.onRead:void 0,c.insKey=o;const{draft:a}=c;return{val:n?a.val:a,meta:c}}function fn(e,t){let n={},r={};const{rawState:o,deep:s,forAtom:c,isPrimitive:a,sharedKey:u}=e;if(Tt(s)){const l={[ze]:u,[De]:c},i=(d,p,h)=>{const{val:m}=Br(e,t,d);return m[p]=h,!0},f=(d,p,h)=>{const m=h[p];if(m!==void 0)return m;const{val:y,meta:g}=Br(e,t,d);return Xn===p?g:y[p]};if(n=new Proxy(o,{set:(d,p,h)=>i(!1,p,h),get:(d,p)=>f(!1,p,l)}),r=n,c){const d=H(w({},l),{[De]:!1});r=a?o.val:new Proxy(o.val,{set:(p,h,m)=>i(!0,h,m),get:(p,h)=>f(!0,h,d)})}}else n=o,r=o.val;return{draftRoot:n,draft:r}}function ya(e){const{UNMOUNT_INFO_MAP:t}=dr(),{insKey:n,readMap:r,internal:o}=e;o.mapInsCtx(e,n);let s=t.get(n);s?(s.c=2,s.prev=n-1):(s={c:1,t:Date.now(),prev:0},t.set(n,s));const{c}=s;c===2&&Object.keys(r).forEach(a=>{o.recordDep(a,n)})}function Vr(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(o=>r.delDep(o,n)),r.delInsCtx(n)}function ha(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function ma(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function Yr(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:o}=n,s=Zc(o);s&&Qc(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,s)}function ln(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:o}=e;return(t?r:n).concat(o)}function ga(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===Qe){Date.now()-r>zn?Vr(e):e.needEFUpdate=!0;return}t()}function Gr(e){const{internal:t,isReactive:n,insKey:r}=e,{rawState:o,isDeep:s,sharedKey:c,onRead:a,forAtom:u}=t;if(s){const l=i=>{const{isBuiltInFnKey:f,key:d}=i;if(f)return;if(Dt(d))return sn(i,u,c);const{fullKeyPath:p,keyPath:h,parentType:m}=i,y=at(i,a),E={depKey:$(p,c),keyPath:p,parentKeyPath:h,sharedKey:c};Yr(e,E,{parentType:m,rawVal:y})};if(n){const{draft:i,draftRoot:f}=fn(t,{onRead:l,insKey:r});e.proxyState=f,e.proxyStateVal=i}else e.proxyState=(0,X.OA)(o,{onOperate:l,compareVer:!0})}else e.proxyState=le(o,{set:()=>(Ke("changing shared state is invalid"),!0),get:(l,i)=>{const f=l[i];if(Dt(i))return it(!0,u,c,i,f);const d=at(Pe(i,f,{isChanged:!1,parentKeyPath:[]}),a),p=Rt(i,c),h=pe(l)?tt:Zs;return Yr(e,{depKey:p,keyPath:[i],sharedKey:c},{parentType:h,rawVal:d}),d}})}function Ea(e){var k;const{updater:t,sharedState:n,id:r="",globalId:o="",collectType:s="every",deps:c,pure:a=!0,arrDep:u=!0,isReactive:l=!1}=e,i=u&&(k=e.arrIndexDep)!=null?k:!0,f=Y(n);if(!f)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=wc(),{rawState:p,isDeep:h,ver:m,ruleConf:y,level1ArrKeys:g,forAtom:E,sharedKey:A,sharedKeyStr:R,snap:M}=f,{stopDepInfo:I}=y,D={readMap:{},delReadMap:{},pure:a,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:h,isReactive:l,insKey:d,internal:f,rawState:p,sharedState:n,sharedKey:A,proxyState:{},proxyStateVal:{},updater:t,mountStatus:Qe,renderStatus:Ce,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:m,id:r,globalId:o,collectType:s,canCollect:s!=="no",isFirstRender:!0,subscribe:S=>{S()},extra:{},getDeps:()=>ln(D,!0),renderInfo:{isAtom:E,setDraft:f.insSetDraft,time:Date.now(),sn:0,snap:M,insKey:d,getDeps:()=>ln(D,!0),getPrevDeps:()=>ln(D,!1)},recordDep:(S,v,_)=>{let b=S.depKey;Fr(S,{stopDepInfo:I,level1ArrKeys:g,recordCb:Ee=>{b=Ee}});const{renderStatus:K,fixedDepKeys:P}=D;if(K===Ct)return;const{readMap:B,insKey:ms,currentDepKeys:x,delReadMap:C}=D;Te([b],{}),Hc()&&(J(x,b),T(D.fixedDepKeys,b));const ce=()=>{B[b]=1,f.recordDep(b,ms),P.includes(b)||T(x,b)};if(!B[b]&&!C[b]){const{parentKeyPath:Ee}=S;if(a&&v===tt&&Ee){const St=Ee.length?$(Ee,A):R;B[St]&&(delete B[St],C[St]=1,J(x,St))}const vt=Ir(v);if(vt){i&&ce();return}(!_||!vt&&u)&&ce()}}};if(o&&Nr(o,d),Gr(D),f.mapInsCtx(D,d),f.recordId(r,d),O(c)){const S=E?D.proxyState.val:D.proxyState,v=W(c,S),_=D.getDeps().slice();v.includes(S)&&_.push(f.rootValKey),D.fixedDepKeys=_}return D}function Hr(e){const{result:t,forAtom:n}=e;e.proxyResult=le(t,{set:()=>(Ke("changing derived result is invalid"),!1),get:(r,o)=>ke===o?n:(Ce===e.renderStatus&&nn(e),t[o])})}function va(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:o,isReactive:s}=e,{sharedKey:c,sharedKeyStr:a,insSetState:u,forAtom:l}=n;r.snap=n.snap,r.time=Date.now();const i=l?t.val:t;return e.isFirstRender&&(e.rootVal=i,Xt.set(e.rootVal,e)),!l&&o&&e.recordDep({depKey:a,keyPath:[],sharedKey:c},tt),[s?t:i,u,r]}function Sa(e,t){if(t&&!Re(e))throw new Error("useAtom only accept atom")}function Aa(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,Gr(e))}function Ka(e){e.mountStatus=qe;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Nr(n,r),ya(e)}function Da(e){e.mountStatus=Jn;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),ca(n,r),Vr(e)}function _a(e,t){const n=Y(t).sharedKey;return e.internal.sharedKey!==n}function ft(e,t,n,r){if(G().isRootRender)try{const o=r||n;e.react.useSyncExternalStore(t,n,o)}catch(o){console.error(o)}}var Ra=null;function jr(e,t,n){const{hookImpl:r,react:o}=e,s=r.useForceUpdate(),c=o.useRef({ctx:Ra});let a=c.current.ctx;return(!a||_a(a,t))&&(a=Ea(w({updater:s,sharedState:t},n)),c.current.ctx=a),a}function $r(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Xt.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),Ka(t),()=>{Da(t)}),[t])}function Ta(e,t,n,r){n.renderStatus=Ce,ma(n),ft(e,n.subscribe,()=>Y(t).snap),e.react.useEffect(()=>{n.renderStatus=Ct,n.isFirstRender=!1,ha(n)})}function dn(e,t,n={}){const r=jr(e,t,n);return ft(e,r.subscribe,()=>Y(t).snap),$r(e,r),r}function lt(e,t,n={}){const{forAtom:r}=n;Sa(t,r);const o=jr(e,t,n);return Ta(e,t,o,n),$r(e,o),Aa(o),{tuple:va(o),insCtx:o}}function Wr(e,t){const{forAtom:n,label:r,strict:o=!1}=t||{};let s;if(typeof e=="number"?s=xe(e):s=Y(e),!s&&e){const a=e[Xn];s=xe(a==null?void 0:a.sharedKey)}let c=r?`[[${r}]] err:`:"err:";if(!s)if(o)ue(`${c} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!s.forAtom&&ue(`${c} expect a shared but recived a atom`,{throwErr:!0}),!n&&s.forAtom&&ue(`${c} expect a atom but recived a shared`,{throwErr:!0})),s}function ye(e,t){return Wr(e,H(w({},t||{}),{strict:!0}))}var{MUTATE:ba,LOADING:Ia}=j,{GLOGAL_LOADING:wa,PRIVATE_LOADING:Ma}=Q,{PRIVATE:Fa,GLOBAL:ka}=Ft,Xr={},Ca={},Oa={time:0,sn:0,getDeps:Ae,getPrevDeps:Ae,insKey:0,setDraft:F,isAtom:!1},La=[he(Xr,Ca,ba),F,Oa];function xa(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:o,moduleName:s}=n,c={};Object.keys(o).forEach(l=>{c[l]={loading:!1,err:null,ok:!0}});const a=s?`${s}@Loading`:"";return e({apiCtx:r,rawState:c,isLoading:!0,stateType:Ma},{moduleName:a}).state}var zr=null;function Pa(){return zr}function Jr(){return G().globalLoadingInternal}function Na(e,t){const n=G();let r=n.globalLoading;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},stateType:wa},{moduleName:js}),s=Y(o);n.globalLoadingInternal=s,n.globalLoading=o}return zr=r,r}function pn(e,t){let n=t;return Dt(t)&&(n=t.toString()),`${e}>${n}`}function Zr(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(o=>{o[t]=n},{from:Ia}),n.err&&(ar(e,Mt.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function he(e,t,n){let r=e[n];return r||(r=le(t,{get(o,s){const c=pn(n,s);return o[c]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function je(e,t){const{internal:n,from:r}=t,{stateType:o,recordLoading:s}=n,c=Q.USER_STATE===o;let a=he(Xr,{},r),u={};if(c)if(Fa===s)u=n.extra.loadingProxy,u||(u=xa(e,t),n.extra.loadingProxy=u,n.loadingInternal=Y(u)),a=he(n.extra,u,r);else if(ka===s){const l=Jr();u=Pa(),n.loadingInternal=l,a=he(l.extra,u,r)}else u=cn();else u=n.sharedState,a=he(n.extra,u,r);return{loadingState:a,loadingProxy:u}}function Qr(e,t){if(!pe(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?H(w({},e),{internal:ye(r.__sharedKey)}):e}function qr(e,t){const{internal:n,from:r,apiCtx:o}=t,{stateType:s}=n,c=Q.USER_STATE===s;je(e,t);let a=()=>La;return c&&(a=u=>{const l=Qr(t,u),i=je(e,l).loadingProxy,{insCtx:{proxyState:f,internal:d,extra:p,renderInfo:h}}=lt(o,i);return[he(p,f,r),d.setState,h]}),{useLoading:a,getLoading:u=>{const l=Qr(t,u);return je(e,l).loadingState}}}function dt(e){const t=gr();return Object.assign(t,e||{})}function me(){const e=V(),{runningFnKey:t}=e;if(!t)return[];const n=de(t);let r=[];if(n){const{depKeys:o,delPathAoa:s,runningSharedKey:c}=e,{depKeys:a}=n,u={};o.forEach(i=>u[i]=1),o.forEach(i=>{const f=Pn(u,i);f&&f!==i&&delete u[f]}),Object.keys(u).forEach(i=>T(a,i)),s.forEach(i=>{const f=i.length;for(let d=1;d<=f;d++){const p=$(i.slice(0,d),c);J(a,p)}}),r=a.slice()}return e.runningFnKey="",e.depKeys=[],e.delPathAoa=[],e.runningSharedKey=0,r}function yn(e,t){const n=V();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function eo(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:o}=n,s=_r(e,o),c=w({fn:e,fnKey:s},n),a=r?Object.assign(r,c):dt(c);return Jt(o).set(s,a),a}function hn(e){var o;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=V(),{fnKey:r}=e;rn(e),e.extra.deferedWatch=null,t.delete(r),((o=n.get(r))==null?void 0:o.c)===2&&n.delete(r),ta()}function to(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=V(),{prevLevelFnKeys:n,depKeys:r}=e;let o=!1;for(const s of r){const c=t.get(s)||[];if($e(c,n)){o=!0;break}}return o}function Ua(e,t=!0,n=_e){return e.map(r=>{const[o,s]=r.split("/"),c=s.split(_e);return`${t?`${xe(Number(o)).usefulName}/`:""}${c.join(n)}`})}var pt=new Map,yt={WATCH:"1",MUTATE:"2"},Ba={[yt.WATCH]:"watch",[yt.MUTATE]:"mutate fn or task"};function Va(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function no(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function Ya(e){pt.delete(e)}function Ga(e,t,n,r){const o=Ba[r],{desc:s,task:c,fn:a,isFake:u}=t.subFnInfo,l=s?`(${s})`:"",i=`DEAD_CYCLE: found reactive object in ${o}${l} cb is changing module(${e.usefulName})'s some of these dep keys(${Ua(n,!1,".")}), it will cause a infinity loop call!`,f=u?t.fn:c||a;return{err:new Error(`[only-dev-mode alert] ${i}`),tipFn:()=>console.error(` ${i} open the stack to find the below fn: 
`,f)}}function Ha(e,t,n){if(e&&n){const{usefulName:r}=e,o=Fe(pt,r,Va(t));o.sn!==t&&(o.descs=[],o.errs=[]);const{descs:s}=o;if(s.length>1&&s[0]===n){const c=s.slice();throw o.cycle=c,s.length=0,no(r,c,n)}T(s,n)}}function mn(e,t){t.tipFn(),ue(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function ge(e,t,n){const{depKeys:r,subFnInfo:o}=t;let s=t.depKeys,c=n;r.length>n.length&&(s=n,c=r);let a=!1;if($e(s,c)){const u=o.desc?yt.MUTATE:yt.WATCH,l=Ga(e,t,n,u);mn(e,l),t.dcErrorInfo=l,a=!0}return a}function ja(e,t){const n=pt.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function $a(e,t,n=!0){const r=pt.get(e);if(!r)return;const{timer:o,errs:s}=r;s.push(t),o&&clearTimeout(o),r.timer=setTimeout(()=>{let c=null;for(const a of s)c?a.data.length>c.data.length&&(c=a):c=a;c&&ue(c,{alertErr:n}),s.length=0},0)}function gn(e,t=0){const n=de(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:Wa}=et;function Xa(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:o=0,from:s,internal:c=Sr,desc:a,fromFnKey:u}=t;if(e.dcErrorInfo.err){mn(c,e.dcErrorInfo);return}if(e.fnKey===u){ge(c,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:o});if(j.MUTATE===s&&Ha(c,o,a),e.isRunning&&ge(c,e,t.depKeys||[]))return;const l=oe.current();if(l.fnKey===e.fnKey&&ge(c,e,l.writeKeys)||(He(l.sharedKey,l.desc),e.isRunning===!0&&l.isTop&&ge(c,e,l.writeKeys)))return;e.isRunning=!0,Ne.set(e.fnKey);const f=e.fn({isFirstCall:n,triggerReasons:r,sn:o});Ne.del();const d=oe.current();if(!(d.isTop&&d.fnKey===e.fnKey&&ge(c,e,d.writeKeys))&&!(f&&f.task&&d.from===j.MUTATE&&ge(c,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,f}function ro(e,t,n){let r=t.val;return n||(r=t),{input:W(e,{state:r,stateRoot:t,isAtom:n}),state:r,stateRoot:t}}function be(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:o=!1,throwErr:s=!1,triggerReasons:c=[],watchFnKeys:a=[],skipWatch:u=!1,sn:l=0,err:i,unbox:f=!1,internal:d=Sr}=t,p=de(e),h=(x=null)=>{if(x&&s)throw x;const C=p||Ar;return f?[C.result.val,x]:[C.result,x]};if(!p)return h(new Error(`not a valid watch or derive cb for key ${e}`));if(p.fnType===Qn)return u?T(a,p.fnKey):Xa(p,t);const{isAsync:m,fn:y,task:g,isAsyncTransfer:E,forAtom:A,result:R,depKeys:M}=p;p.remainRunCount>0&&(p.remainRunCount-=1);const I=x=>{const C=A?{val:x}:x;!p.returnUpstreamResult&&C&&Object.assign(p.result,C),p.shouldReplaceResult=!0},D=()=>{p.renderInfo.sn=l,p.updater()},k=x=>{const{data:C,err:ce=null}=x;ce?p.setLoading(!1,ce):(I(C),n?m&&p.status.loading&&!to(p)&&p.setLoading(!1,ce):p.remainRunCount===0&&p.setLoading(!1,ce)),D();const Ee={isFirstCall:n,sn:l,triggerReasons:c,err:ce,watchFnKeys:a,skipWatch:u};p.nextLevelFnKeys.forEach(vt=>{be(vt,Ee)})},S=A?R:R.val,{deps:v,isStateAtom:_}=p,{input:b,state:K,stateRoot:P}=ro(v,p.stateRoot,_),B={isAtom:p.isStateAtom,state:K,stateRoot:P,isFirstCall:n,prevResult:S,triggerReasons:c,input:b,sn:l};if(!m||r||m&&!g){const x=y(B);return k({data:x}),h()}if(m&&n&&p.nextLevelFnKeys.forEach(x=>gn(x,0)),E)return k({err:i}),h();if(p.asyncType===Wa){const x=y(B);return k({data:x}),h()}if(g){let x=Ks;return n?(M.forEach(C=>Bc(C,e)),x=()=>M.forEach(C=>Vc(C,e))):o&&p.nextLevelFnKeys.forEach(C=>gn(C)),Promise.resolve(()=>{const C=g(B);return _t(C)?C:(ue("ERR_NON_FN: derive task arg should be async function!",{throwErr:s}),null)}).then(C=>C()).then(C=>(x(),k({data:C}),h())).catch(C=>{if(x(),k({err:C}),s)throw C;return ur(d,C),h(C)})}return h(i)}function ht(e,t){const n=Ve(e);if(!n)throw new Error("[Helux]: not a derived result");return be(n.fnKey,w({},t||{}))}function za(e,t){return ht(e,{forceFn:!0,throwErr:t})}function Ja(e,t){return Promise.resolve(ht(e,{forceTask:!0,throwErr:t}))}function Za(e,t){return ht(e,{forceFn:!0,throwErr:t,unbox:!0})}function Qa(e,t){return Promise.resolve(ht(e,{forceTask:!0,throwErr:t,unbox:!0}))}function qa(e){const t=Ve(e);return t?t.status:{loading:!1,err:null,ok:!0}}function En(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,ga(r))}function eu(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:o,depKeys:s,triggerReasons:c,isFirstCall:a,from:u,sn:l,desc:i,fnKey:f}=t,{key2InsKeys:d,id2InsKeys:p,insCtxMap:h,rootValKey:m}=n;let y=[],g=[],E=[],A=[];const R={};if(a){const v=me();Be.set(v)}const M=(v,_=!1)=>{const{firstLevelFnKeys:b,asyncFnKeys:K}=ea(n,v,R,_);E=E.concat(b),A=A.concat(K)},I=v=>{if(!ut(n,v))return;const _=d[v]||[],b=[];for(const K of _){if(y.includes(K))continue;const P=h.get(K);if(!P)continue;const B=P.getDeps();if(B[0]===m){ut(n,m)&&b.push(K);continue}kr(n,B,v)&&b.push(K)}y=y.concat(b),M(v)};s.forEach(v=>I(v)),s.includes(m)||I(m),M(m,!0),qc(),r.forEach(v=>{y=y.concat(p[v]||[])}),o.forEach(v=>{an(v).forEach(_=>T(g,_))}),y=ve(y),E=ve(E),A=ve(A),A.forEach(v=>gn(v,R[v]));const D=[],k={depKeys:s,sn:l,from:u,triggerReasons:c,watchFnKeys:D,skipWatch:!0,internal:n,desc:i,isFirstCall:a,fromFnKey:f};E.forEach(v=>be(v,k));const S={depKeys:s,sn:l,from:u,triggerReasons:c,internal:n,desc:i,isFirstCall:a,fromFnKey:f};if(D.forEach(v=>be(v,S)),y.forEach(v=>En(h,v,l)),g.length){const v=sa().insCtxMap;g.forEach(_=>En(v,_,l))}}function tu(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:o,isDeep:s,ver:c,snap:a}=n;s?(n.prevSnap=c===0?w({},a):a,n.snap=t,Object.assign(o,t)):n.snap=w({},o),n.ver+=1,n.sn=r.sn,eu(e)}var{MUTATE:oo}=j;function so(e,t){const{writeKey:n,ids:r,internal:o,opParams:s}=t,{snap:c}=o,{fullKeyPath:a,value:u}=s;Object.keys(e).forEach(l=>{n.startsWith(l)&&ie(c,a)!==u&&e[l].forEach(i=>T(r,i))})}function co(e,t){const{isChanged:n,fullKeyPath:r,keyPath:o,parentType:s,value:c}=e,{internal:a,mutateCtx:u}=t,{arrKeyDict:l,isReactive:i,readKeys:f,from:d}=u,{sharedKey:p}=a,h=Ir(s),m=oe.current();if(e.op==="get"){h&&(l[$(o,p)]=1);const K=$(r,p);f[K]=1,u.enableDep&&(m.onRead?m.onRead(e):(Ye().fnCtx&&Te([K],{sharedKey:p}),i&&(en([K]),on(p,c,a.sharedState,K,r))));return}if(oo===d){const{delPathAoa:K,fnCtx:P}=Ye();P&&K.push(o)}if(!n)return;const{moduleName:y,ruleConf:g,level1ArrKeys:E}=a,{writeKeyPathInfo:A,ids:R,globalIds:M,writeKeys:I}=u,D=$(r,p);if(m.key&&(m.isTop?T(m.writeKeys,D):m.from===oo&&T(Zt(m.fnKey).subFnInfo.writeKeys||[],D)),h){const K=$(o,p);A[K]={sharedKey:p,moduleName:y,keyPath:o},I[K]=1}const{hasIds:k,hasGlobalIds:S,stopDepInfo:v}=g;A[D]={sharedKey:p,moduleName:y,keyPath:r};const _=Pn(l,D);_&&(I[_]=1),Fr({sharedKey:p,keyPath:r,depKey:D},{stopDepInfo:v,level1ArrKeys:E,recordCb:K=>{I[K]=1}})||(I[D]=1),k&&so(g.idsDict,{ids:R,writeKey:D,internal:a,opParams:e}),S&&so(g.globalIdsDict,{ids:M,writeKey:D,internal:a,opParams:e}),i?da(p,m.desc):la(p)}function ao(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function mt(e,t){if(!t)return e;tn(!0);const n=e.val;return tn(!1),n}function uo(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:o}=e;if(!t)return;if(!n){pe(t)&&ao(o,t);return}const s=t.val;if(pe(o)){pe(s)?ao(o,s):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=s}function nu(e,t){const{internal:n,mutateCtx:r}=e,o=mt(t,n.forAtom),{from:s,sn:c,desc:a}=r;n.before({from:s,draftRoot:t,draft:o,desc:a,sn:c}),uc(n,t,o,c)}function io(e,t,n,r){const{mutateCtx:o,internal:s}=e,{writeKeys:c,writeKeyPathInfo:a,handleCbReturn:u}=o,{forAtom:l}=s;u&&uo({partial:r,forAtom:l,draftRoot:t,draftNode:n}),nu(e,t),o.depKeys=Object.keys(c),ct.del(),zt.del(),e.state=(0,X._x)(t),e.state!==s.rawState&&(o.triggerReasons=Object.values(a),tu(e),dc(s,o))}function fo(e,t){const{ids:n,globalIds:r,from:o,desc:s,fnKey:c}=t;n&&n.forEach(a=>T(e.ids,a)),r&&r.forEach(a=>T(e.globalIds,a)),o&&(e.from=o),s&&(e.desc=s),c&&(e.fnKey=c)}function ru(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:o}=t,s=Nt(n),c=(0,X.P2)(o,{customKeys:Je,onOperate:u=>{if(u.isCustom)return sn(u,r,t.sharedKey);co(u,{internal:t,mutateCtx:s})}});ct.set(c,r),zt.set(s);const a=mt(c,r);return r&&(s.readKeys={}),{draftRoot:c,draftNode:a,finishMutate(u,l={}){fo(s,l),io({state:{},mutateCtx:s,internal:t},c,a,u)}}}function ou(e){return ir(e),Dc(e)}function su(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function cu(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=O(n);let o=!1;if(t)n=r?{val:n()}:{val:n},o=!n.val||!xn(n.val);else{if(n=r?n():n,!z(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(re(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:o,rawState:n}}function lo(e,t,n){let r=null,o=t||"";if(O(e)&&e!==F)r={[Wn]:1,fn:e,deps:Ae,oriDesc:o,onlyDeps:!1,desc:o,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}};else if(z(e)){const{fn:s,desc:c,deps:a,task:u,immediate:l,checkDeadCycle:i,onlyDeps:f=!1}=e,d=t||c||"",p=O(s)?s:void 0,h=O(u)?u:void 0,m=O(a)?a:Ae;(s||u)&&(r={[Wn]:1,checkDeadCycle:i,fn:p,watchKey:"",desc:d,oriDesc:d,deps:m,task:h,onlyDeps:f,immediate:l,depKeys:[],writeKeys:[],isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}})}if(r&&n){const{oriDesc:s}=r;(!s||n[s])&&(r.desc=Pt(j.MUTATE))}return r}function po(e,t,n=!0){const r={},o=t||{};if(!e)return r;const s=(c,a)=>{const u=lo(c,a,o);u&&(u.enabled=n,r[u.desc]=u,o[u.desc]=u)};if(Array.isArray(e))if(e.length===1){const c=e[0],a=(z(c)?c.desc:"")||Ze;s(e[0],a)}else e.forEach(c=>s(c));else O(e)?s(e,Ze):z(e)&&Object.keys(e).forEach(c=>{s(e[c],c)});return r}function au(e,t={}){var k,S,v,_,b;const{forAtom:n=!1,forGlobal:r=!1,stateType:o=Q.USER_STATE}=e,{rawState:s,isPrimitive:c}=cu(e),a=ou(s),u=t.moduleName||"",l=(k=t.alertDeadCycleErr)!=null?k:ae(),i=(S=t.deep)!=null?S:!0,f=(v=t.checkDeadCycle)!=null?v:!0,d=(_=t.enableMutate)!=null?_:!0,p=t.recordLoading||Ft.PRIVATE,h=t.rules||[],m=t.before||F,y=t.mutate||F,g=(b=t.stopArrDep)!=null?b:!0,E=t.stopDepth||$s,A=`${a}`,R=n?`${a}/val`:A,M=u||A,I=$c(u),D=po(y,{},d);return{isDestroyed:!1,alertDeadCycleErr:l,checkDeadCycle:f,rawState:s,sharedKey:a,sharedKeyStr:A,rootValKey:R,moduleName:u,usefulName:M,forAtom:n,forGlobal:r,loc:I,deep:i,rules:h,before:m,mutate:y,mutateFnDict:D,onRead:null,enableMutate:d,stateType:o,recordLoading:p,stopArrDep:g,stopDepth:E,isPrimitive:c}}function uu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:o,rules:s,stopDepth:c,stopArrDep:a,forAtom:u}=e,l={},i={},f={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:c,stopArrDep:a},d={},p=Tt(o);s.forEach(y=>{const g=[],{when:E,ids:A=[],globalIds:R=[],stopDep:M}=y;let I;if(p){let _="";I=(0,X.OA)(t,{onOperate:({fullKeyPath:b,value:K,isBuiltInFnKey:P})=>{if(P)return;const B=$(b,n);_&&B.includes(_)&&g.pop(),g.push(B),d[B]=Array.isArray(K),_=B}})}else I=le(t,{set:ws,get:(_,b)=>{const K=$([b],n);g.push(K);const P=_[b];return d[K]=Array.isArray(P),P}});const D=u?I.val:I,k=W(E,D),S=(_,b,K)=>{const P=Me(_,K,[]);b.forEach(B=>T(P,B))},v=_=>{S(l,A,_),S(i,R,_);let b;d[_]?(b=M!=null?M:Ws,f.arrKeyStopDcit[_]=b,f.isArrDict[_]=d[_]):b=M!=null?M:!1,b&&T(f.keys,_)};g.forEach(v),k.includes(D)&&v(r)});const h=Object.keys(l).length>0,m=Object.keys(i).length>0;return{hasIds:h,idsDict:l,hasGlobalIds:m,globalIdsDict:i,stopDepInfo:f}}function iu(e){const{desc:t=Ze,strict:n=!1,throwErr:r=!1}={};return typeof e=="string"?{desc:e,strict:n,throwErr:r}:H(w({desc:t,strict:n},e),{throwErr:r})}function yo(e,t){var o;let n=F,r=!1;return O(t)?n=t:z(t)&&(n=t.deps||F,r=(o=t.immediate)!=null?o:!1),r=e?!0:r,{immediate:r,deps:n}}function fu(e){return e?typeof e=="boolean"?{enableStatus:e}:z(e)?e:{}:{}}function lu(e){Array.isArray(e)&&e.forEach(t=>{const n=Xt.current(t),r=Y(t)||(n==null?void 0:n.internal);if(r){const{depKey:o,sharedKey:s}=br(r);Te([o],{sharedKey:s})}n&&n.recordDep(br(r))})}function ho(e,t,n){const{deps:r,immediate:o}=yo(e,n),s=gt(t,{scopeType:te.STATIC,deps:r,immediate:o});return{run:c=>be(s.fnKey,{throwErr:c}),unwatch:()=>rn(s)}}function gt(e,t){const{scopeType:n,fnCtxBase:r,immediate:o,deps:s=F,label:c="watch",sharedState:a,isSimpleWatch:u}=t;if(!O(e))throw new Error(`ERR_NON_FN: pass an non-function to ${c}!`);const l=eo(e,{specificProps:{scopeType:n,fnType:Qn,isSimpleWatch:u},fnCtxBase:r});yn(l.fnKey,re(a));const i=s()||[];return lu(i),o&&e({isFirstCall:!0}),me(),l}function du(e,t){return ho(!1,e,t)}function pu(e,t){return ho(!0,e,t)}var mo=()=>{},vn=new Map;function go(e,t){const{forAtom:n,rawState:r}=e,{deps:o,extraBound:s}=t;return n?W(o,r.val,s):W(o,r,s)}function yu(e){var t;return(t=vn.get(e))!=null?t:!1}function Sn(e,t){const{sn:n,getArgs:r=F,from:o,throwErr:s,isFirstCall:c,fnItem:a,mergeReturn:u}=t,{desc:l="",depKeys:i,task:f=mo,extraBound:d}=a,p=Y(e),{sharedKey:h}=p,m={desc:l,sn:n,from:o},y=pn(o,l),{draft:g,draftRoot:E}=fn(p,{depKeys:i,desc:l,from:o}),A=K=>{He(h,K)},R=K=>{A(l);const{finish:P}=p.setStateFactory(m);return P(K)},M=j.MUTATE===o?go(p,a):[],I={isFirstCall:c,desc:l,setState:R,input:M,draft:g,draftRoot:E,flush:A,extraBound:d},D=r(I)||[I],k=vn.get(f),S=k===void 0,v=(K,P,B)=>{(S||k)&&Zr(p,y,{loading:K,err:P,ok:B})};v(!0,null,!1);const _=K=>{if(Be.del(),v(!1,K,!1),s)throw K;return{snap:p.snap,err:K,result:null}},b=K=>(u&&K&&R(K),v(!1,null,!0),A(l),{snap:p.snap,err:null,result:K});try{const K=f(...D),P=_t(K);return vn.set(f,P),P?Promise.resolve(K).then(b).catch(_):b(K)}catch(K){return _(K)}}function Eo(e,t){const{sn:n,getArgs:r=F,from:o,throwErr:s,isFirstCall:c=!1,fnItem:a}=t,{desc:u="",watchKey:l,fn:i=mo,extraBound:f}=a,d=j.MUTATE===o;d&&Ne.set(l);const p=Y(e),{setStateFactory:h,forAtom:m,sharedRoot:y}=p,E={desc:u,sn:n,from:o,isFirstCall:c,enableDep:d&&c},A=v=>{const{finish:_}=h(E);return _(v)},R=mt(y,m),M=d?go(p,a):[],{draftNode:I,draftRoot:D,finish:k}=h(E),S=r({draft:I,draftRoot:D,setState:A,desc:u,input:M})||[I,{input:M,state:R,draftRoot:D,isFirstCall:c,extraBound:f}];try{const v=Zt(a.watchKey);if(v.dcErrorInfo.err)return mn(p,v.dcErrorInfo),{snap:p.snap,err:null,result:null};const _=i(...S);return k(_,{fnKey:v.fnKey}),vo(p,a,c),{snap:p.snap,err:null,result:null}}catch(v){if(vo(p,a,c),s)throw v;return{snap:p.snap,err:v,result:null}}}function vo(e,t,n){n&&!t.onlyDeps&&(Ye().fnCtx?t.depKeys=me():t.depKeys=Be.current(),Be.del());const r=oe.current();r.isTop&&r.fnKey===t.watchKey&&ge(e,Zt(t.watchKey),r.writeKeys),Ne.del()}function hu(e,t){var r;fa(),Be.del(),tn(!1);const n=Ye().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=me())}function An(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const o=Y(t),{mutateFnDict:s,usefulName:c,forAtom:a,sharedRoot:u}=o,l=i=>ur(o,i);r.forEach(i=>{const f=s[i];gt(({sn:d,isFirstCall:p})=>{if(p&&hu(o,f),!o.enableMutate)return;const{desc:h,fn:m,task:y,immediate:g}=f,E=ja(c,h);try{if(E.isIn)throw no(c,E.cycle,h);const A={sn:d,throwErr:!0,isFirstCall:p,fnItem:f,from:j.MUTATE};if(m&&(p||!y)&&Eo(t,A),y){p&&(f.depKeys=me());const R=p&&(g!=null?g:!m);(!p||R)&&Sn(t,A).catch(l)}return f}catch(A){A.cause==="DeadCycle"&&$a(c,A,o.alertDeadCycleErr),l(A)}},{deps:()=>f.deps?f.deps(mt(u,a),f.extraBound)||[]:[],sharedState:t,scopeType:te.STATIC,immediate:!0})})}var{ACTION:So}=j;function mu(e,t){const{label:n,throwErr:r,desc:o="",task:s,mergeReturn:c=!0}=t,a=Qt(r,!1),u=ye(e,{label:n}),{forAtom:l}=u,i=(f,d)=>{const p=Qt(d,a),h=Ut({desc:o,task:s,depKeys:[]}),m=(y,g)=>y.__action?y.__action(g):y(g);return Sn(e,{fnItem:h,from:So,mergeReturn:c,throwErr:p,getArgs:({draft:y,draftRoot:g,setState:E,desc:A,flush:R})=>[{draft:y,draftRoot:g,setState:E,desc:A,payload:f,flush:R,merge:I=>{uo({partial:I,forAtom:l,draftRoot:g,draftNode:y})},dispatch:m}]})};return Zr(u,pn(So,o),{loading:!1,ok:!0,err:null}),i.__sharedKey=u.sharedKey,i.__fnName=o,i.__task=s,s.__action=i,i}function Ao(e){return t=>(n,r="",o)=>mu(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:o})}var{TASK:Ko}=et,{STATIC:gu,HOOK:Eu}=te;function Do(e,t,n){if(!n&&(!z(t)||_t(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:o}=e;if(r&&!o){const s=Rr(t),c=re(t);if(s&&e.fnKey!==s||c)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function vu(e,t){const n=le(e.result,{set:()=>(Ke("changing derived result is invalid"),!1),get:(r,o)=>{if(o===ke)return t;const s=r[o];return Te(e.depKeys,{belongCtx:e}),en(e.depKeys,n),on(0,s,n,"",[o],!0,t),s}});return e.proxyResult=n,n}function _o(e,t){const{result:n,isUpstream:r}=t,o=Ve(n);o&&(e.depKeys=ve(e.depKeys.concat(o.depKeys)),T(o.nextLevelFnKeys,e.fnKey),T(e.prevLevelFnKeys,o.fnKey),e.isFirstLevel=!1,r==null||r())}function Su(e){var k,S;const{scopeType:t=gu,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:o=Ko,returnUpstreamResult:s,runAsync:c=!0,forAtom:a=!1,immediate:u}=e;if(!O(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:l=F,deps:i=F,task:f,stateRoot:d={}}=e,p=Re(d),h=(k=e.isAsync)!=null?k:O(f),m=(S=e.showLoading)!=null?S:h,y=eo(l,{specificProps:{forAtom:a,scopeType:t,stateRoot:d,isStateAtom:p,fnType:Zn,task:f,deps:i,isAsync:h,asyncType:o,isAsyncTransfer:r,showLoading:m},fnCtxBase:n});yn(y.fnKey,0);const{input:g,state:E}=ro(i,d,p);g.forEach(v=>_o(y,{result:v}));let R=l({isFirstCall:!0,prevResult:null,triggerReasons:[],input:g,sn:0,state:E,stateRoot:d,isAtom:p});me();const M=Ve(R);a&&!M&&(R={val:R,z__is_atom_result__:!0});const I=y.fnKey;Do(y,R),_o(y,{result:R,isUpstream:()=>{y.returnUpstreamResult=s!=null?s:!h}}),nn(y),y.returnUpstreamResult||_r(R,t,I);const D=c&&o===Ko&&(u!=null?u:!e.fn);return f&&D&&be(I,{isFirstCall:!0,sn:y.renderInfo.sn+1}).then(v=>{Do(y,v[0],a)}).catch(v=>ue(v)),y.result=R,t===Eu&&to(y)&&y.setLoading(!0),y.returnUpstreamResult?y.proxyResult=R:vu(y,a),y}function Kn(e,t){const n=O(e)?{fn:e}:e||{};return Su(w(w({},t||{}),n))}function Ro(e,t){return Kn(e,{forAtom:!0,stateRoot:t}).proxyResult}function Au(e,t){return Kn(e,{stateRoot:t}).proxyResult}function Ku(e){return t=>H(w({},t),{deps:e})}function Du(e){return e}var Et=e=>[e.snap,e.err];function Dn(e){const{target:t,desc:n="",forTask:r=!1,throwErr:o}=e,{mutateFnDict:s,snap:c}=Y(t),a=n||Ze,u=s[a];if(!u)return{snap:c,err:new Error(`mutate fn ${a} not defined`),result:null};if(r&&!u.task)return{snap:c,err:new Error(`mutate task ${a} not defined`),result:null};const l=Qt(o,!1),i={sn:0,fnItem:u,from:j.MUTATE,throwErr:l};return r?Sn(t,i):Eo(t,i)}function To(e,t,n,r){return{run:o=>{const s=Dn({target:e,desc:t,throwErr:o});return Et(s)},runTask:o=>Promise.resolve(Dn({target:e,desc:t,forTask:!0,throwErr:o})).then(Et),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function _u(e){const{target:t,fnItem:n,label:r,extraTarget:o}=e,s=ye(t,{label:r}),c=lo(n,"",s.mutateFnDict);if(!c)throw new Error("not a fn or fnItem { fn }");o&&(c.extraBound=xt(o)),s.mutateFnDict[c.desc]=c,c.enabled=s.enableMutate;const a={[c.desc]:c};return s.enableMutate&&An({target:t,dict:a}),To(t,c.desc,c.oriDesc,s)}function Ru(e){const{target:t,fnDict:n,label:r}=e,o=ye(t,{label:r}),s=po(n,o.mutateFnDict,o.enableMutate);if(e.extraTarget){const a=xt(e.extraTarget);Object.keys(s).forEach(u=>s[u].extraBound=a)}o.enableMutate&&An({target:t,dict:s});const c={};return Object.keys(s).forEach(a=>{c[a]=To(t,a,a,o)}),c}function Tu(e,t){const{label:n,descOrOptions:r,forTask:o=!1}=t,{desc:s,strict:c,throwErr:a}=iu(r);return s?Wr(e,{label:n,strict:c})?{ok:!0,desc:s,forTask:o,throwErr:a,err:null}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("miss desc")}}function bo(e,t){const{ok:n,desc:r,forTask:o,err:s,throwErr:c}=Tu(e,t);if(!n){if(c)throw s;return o?Promise.resolve([e,s]):[e,s]}const a=Dn({target:e,desc:r,forTask:o,throwErr:c});return o?Promise.resolve(a).then(Et):Et(a)}function Io(e,t){return bo(e,{descOrOptions:t,label:"runMutate"})}function wo(e,t){return bo(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function Mo(e,t){return n=>_u({target:e,extraTarget:t,fnItem:n,label:"mutate"})}function _n(e,t){return n=>Ru({target:e,extraTarget:t,fnDict:n,label:"mutateDict"})}function bu(e){return e}function Fo(e,t,n={}){const{tuple:r}=lt(e,t,n);return r}function ko(e,t,n={}){const{tuple:r}=lt(e,t,n),[o,s,c]=r;return H(w({},c),{state:o,setState:s})}var Iu="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",wu="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function Mu(e,t,n){return e.isExpired?(e.isExpired=!1,!0):O(n)?!1:n!==t}function Fu(e){hn(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function ku(e,t){const{result:n,forAtom:r,showLoading:o}=t,{fnCtx:s,input:c,deriveFn:a}=e;let u=!1;if(a)if(Mu(s,c,n))u=!0,Fu(s);else return;e.input=n;const l=Ve(n);if(!l)throw new Error(Iu);if(r&&!fe(n))throw new Error(wu);e.deriveFn=()=>l.result,Kn({fn:()=>l.result,deps:()=>[],task:()=>As(this,null,function*(){return l.result})},{isAsync:l.isAsync,scopeType:te.HOOK,fnCtxBase:s,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:et.MAY_TRANSFER,showLoading:o}),Hr(s),u&&s.updater()}function Co(e,t){const{result:n,forAtom:r}=t,{hookImpl:o,react:s}=e,c=o.useForceUpdate(),{current:a}=s.useRef({input:n,deriveFn:null,fnCtx:null});a.fnCtx||(a.fnCtx=dt({updater:c,scopeType:te.HOOK,forAtom:r}));const u=a.fnCtx;return u.renderStatus=Ce,ku(a,t),u}function Cu(e,t){t.shouldReplaceResult&&(Hr(t),t.shouldReplaceResult=!1),ft(e,t.subscribe,()=>Or(t)),e.react.useEffect(()=>{t.renderStatus=Ct})}function Oo(e,t){e.react.useEffect(()=>(t.mountStatus=qe,Cr(t),()=>{hn(t)}),[t])}function Rn(e,t){const n=Co(e,t);return ft(e,n.subscribe,()=>Or(n)),Oo(e,n),n}function Ou(e,t){const n=Co(e,t);return Cu(e,n),Oo(e,n),n}function Tn(e,t,n){const r=Ou(e,w({result:t},n||{})),{proxyResult:o,status:s,renderInfo:c}=r;return[fe(t)?o.val:o,s,c]}function Lo(e,t,n){if(t===null)return n;if(!O(t))return null;const{sharedState:r,forAtom:o}=e,s=o?r.val:r,c={};Wt.set(u=>c[u[0]]=1);const a=W(t,s);return Wt.del(),a.includes(s)?e.key2InsKeys:c}function xo(e,t,n){const r=ye(t),[o]=e.react.useState(()=>Lo(r,n,null));return s=>{const{insCtxMap:c,key2InsKeys:a}=r,u=Lo(r,s,a)||o||a,l={};if(Object.keys(u).forEach(f=>{(a[f]||[]).forEach(p=>l[p]=1)}),Object.keys(l).length){r.sn+=1;const f=r.sn;Object.keys(l).forEach(d=>{En(c,Number(d),f)})}}}function Lu(e,t){Mn(e);const n=cn();return dn(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:Po,MUTATE:No}=j;function bn(e,t){Mn(e);const{target:n,from:r="Mutate"}=t||{};let o=Jr();n&&(o=ye(n));const{loadingProxy:s,loadingState:c}=je(se,{apiCtx:e,internal:o,from:r});return{loadingProxy:s,loadingState:c,internal:o,from:r}}function Uo(e,t){const{loadingProxy:n,internal:r,from:o}=bn(e,t),{proxyState:s,extra:c,renderInfo:a}=dn(e,n);return[he(c,s,o),r.setState,a]}function xu(e,t){const{loadingProxy:n}=bn(e,{target:t,from:No});return n}function Pu(e,t){return Uo(e,{target:t,from:No})}function Nu(e,t){const{loadingProxy:n}=bn(e,{target:t,from:Po});return n}function Uu(e,t){return Uo(e,{target:t,from:Po})}function Bo(e){return e.hookImpl.useForceUpdate()}function Vo(e,t){const n=(r,o)=>{let s=null;if(O(r)){const c=(0,X.P2)(o),a=r(c);s=(0,X._x)(c),z(a)&&Object.assign(s,a)}else z(r)&&(s=w(w({},o),r));return s};return e.hookImpl.useObjectLogic(t,n,!0)}function Bu(e,t,n){const{useRef:r,useMemo:o,useEffect:s}=e.react,c=r({fn:n,wrap:null});c.current.fn=o(()=>n,[n]),c.current.wrap||(c.current.wrap=(...a)=>{c.current.fn(...a)}),s(()=>{const a=yc(),u=c.current.wrap;return a.on(t,u),()=>a.off(t,u)},[t,c])}function In(e,t,n={}){const r=Re(t),{insCtx:o}=lt(e,t,H(w({},n),{forAtom:r,isReactive:!0}));return[o.proxyStateVal,o.proxyState,o.renderInfo]}function Yo(e,t,n={}){const[r,o,s]=In(e,t,n);return H(w({},s),{state:r,stateRoot:o})}function Vu(e,t,n){const r=z(n)?n:{};e.react.useEffect(()=>{const{srvRef:o}=r;O(o)&&o(t)},[])}function Yu(e,t,n){const r=e.hookImpl.useStable(t);return Vu(e,r,n),r}function Gu(e){return t=>e.current=t}var{HOOK:Go}=te;function Ho(e,t){e(()=>{var n,r;return t.mountStatus=qe,Cr(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{hn(t)}},[t])}function jo(e,t){const{useRef:n,useState:r,useMemo:o,useEffect:s}=e.react,{label:c,forEffect:a,watchFn:u,watchOptions:l}=t,i=n({fn:u,wrap:null,fnKey:"",isDeferMarked:!1}),[f]=r(()=>dt());if(i.current.fn=o(()=>u,[u]),!i.current.wrap){const{deps:d,immediate:p}=yo(a,l);i.current.wrap=m=>{if(f.mountStatus===qe){i.current.fn(m);return}f.extra.deferedWatch=()=>{if(i.current.isDeferMarked){i.current.fn(m);return}i.current.isDeferMarked=!0,yn(i.current.fnKey,0),i.current.fn(m),me()}};const{fnKey:h}=gt(i.current.wrap,{scopeType:Go,fnCtxBase:f,deps:d,immediate:p,label:c});i.current.fnKey=h}Ho(s,f)}function Hu(e,t,n){const{useState:r,useEffect:o}=e.react,[s]=r(()=>dt());if(s.fn===F){const{manualDepKeys:c=[]}=n;gt(t,{scopeType:Go,fnCtxBase:s,deps:()=>c.map(u=>{const{sharedKey:l,keyPath:i}=Tr(u),f=Rc(l);return ie(f,i)}),isSimpleWatch:!0})}Ho(o,s)}function ju(e,t,n){jo(e,{label:"useWatch",forEffect:!1,watchFn:t,watchOptions:n})}function $u(e,t,n){jo(e,{label:"useWatchEffect",forEffect:!0,watchFn:t,watchOptions:n})}function Wu(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:o,stopDepth:s,sharedKey:c}=t,a=Nt(n),u=w({},r),l=(p,h,m,y)=>{const g=Pe(h,m,{parentType:wr(p),parentKeyPath:y});co(g,{internal:t,mutateCtx:a}),Un(u,g.fullKeyPath,m)},i=(p,h,m)=>Oe(p,{set:(y,g,E)=>(l(y,g,E,m),!0),get:(y,g)=>{const E=y[g];if(Je.includes(g))return it(h===1,o,c,g,E);const A=Pe(g,E,{isChanged:!1,parentKeyPath:m,op:"get",parentType:wr(y)});return h<s&&pe(E)?i(E,h+1,A.fullKeyPath):ie(u,A.fullKeyPath)}}),f=i(u,1,[]);ct.set(f,o),zt.set(a);const d=o?f.val:f;return{draftRoot:f,draftNode:d,finishMutate(p,h={}){fo(a,h);const m=w({state:{},mutateCtx:a},e);io(m,f,d,p)}}}function Xu(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function zu(e){let t=[];return{target:Xc(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function $o(e,t,n){return o=>{let s=Xu(o);e(c=>{const{isAtom:a,draftRoot:u}=ct.current(),l={draft:c,draftRoot:u,path:t,isAtom:a,UNDEFINED:Hs},i=n==null?void 0:n(s,l);Un(u,t,i!==void 0?i:s)},{from:j.SYNC})}}function wn(e,t){const{sharedKey:n,innerSetState:r}=t;let o=$(e,n),s=Wo.get(o);return s||(s=$o(r,e),Wo.set(o,s)),s}var Wo=new Map;function Xo(e){const{forAtom:t,rawState:n}=e;return t?xn(n.val)?Oe(n.val,{get:(r,o)=>wn(["val",o],e)}):wn(["val"],e):Oe(n,{get:(r,o)=>wn([o],e)})}var zo=new Map;function Jo(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:o}=e,s=zu(o);return(c,a)=>{let u=[];if(Array.isArray(c))u=t?["val",...c]:c;else{const{target:f,getPath:d}=s;c(t?f.val:f),u=d()}let l=$(u,n);a&&(l+=`${a.toString()}`);let i=zo.get(l);return i||(i=$o(r,u,a),zo.set(l,i)),i}}function Ju(e,t,n){const{deep:r,forAtom:o,sharedKey:s}=n,c=uu(n),a=Tt(r),u=(g={})=>{const E={internal:y,setFactoryOpts:g},{finishMutate:A,draftRoot:R,draftNode:M}=a?ru(E):Wu(E);return{finish:(I,D={})=>{const k=y.snap;if(I===k)return k;const S=Jc(o,I,M);return A(S,D),y.snap},draftRoot:R,draftNode:M}},l=(g={})=>u(g),i=(g,E={})=>u().finish(g,E),f=(g,E)=>{const[A,R,M]=E;return un(e,Ue.current(s)),u({handleCbReturn:A,enableDep:R}).finish(g,su(M))},y=hr(n,{sharedRoot:e,sharedState:t,setState:(g,E)=>f(g,[!0,!0,E]),setDraft:(g,E)=>f(g,[!1,!0,E]),insSetState:(g,E)=>f(g,[!0,!1,E]),insSetDraft:(g,E)=>f(g,[!1,!1,E]),setStateFactory:l,innerSetState:i,ruleConf:c,isDeep:a});return y.sync=Jo(y),y.syncer=Xo(y),Ac(e,y),y}function Zu(e,t){const n=au(e,t),{sharedRoot:r,sharedState:o}=ra(n),s=Ju(r,o,n);Tc(r,n),Gc(),An({target:r,dict:n.mutateFnDict});const{draft:c,draftRoot:a}=fn(s,{isTop:!0});return s.reactive=c,s.reactiveRoot=a,Sc(n.moduleName,s.loc),Ya(s.usefulName),pc(s),{sharedRoot:r,sharedState:o,internal:s,parsedOptions:n}}var{USER_STATE:Zo}=Q,{MUTATE:Qu,ACTION:Qo}=j;function Mn(e,t){Zo===(t||Zo)&&!cn()&&(oa(e,se),Na(e,se))}function qo(e,t){const{createFn:n,ldAction:r,actionDict:o,actionCreator:s,internal:c,apiCtx:a,forTp:u=!1}=e;je(n,{internal:c,from:Qo,apiCtx:a});const l={},i={};return Object.keys(o).forEach(f=>{const d=o[f],p=u?d.__task:d,h=s(!1)(p,f,t);h.__fnName=f,i[f]=h;const m=(...y)=>{const g=h(...y);return yu(p)?Promise.resolve(g).then(E=>E.result):g.result};m.__fnName=f,l[f]=m}),{actions:l,eActions:i,getLoading:()=>r.getLoading(l),useLoading:()=>r.useLoading(l)[0],useLoadingInfo:()=>r.useLoading(l)}}function es(e,t,n){const{state:r,stateRoot:o,isAtom:s}=e,c=xt(n);return O(t)?t({state:r,stateRoot:o,isAtom:s,extraBound:c}):t}function ts(e){const{common:t,ldMutate:n,mutateFnDict:r,extra:o}=e,s=es(t,r,o),c=_n(t.stateRoot,o)(s);return{witnessDict:c,getLoading:()=>n.getLoading(c),useLoading:()=>n.useLoading(c)[0],useLoadingInfo:()=>n.useLoading(c)}}function qu(e){const{common:t,ldMutate:n,inital:r,mutateFnDict:o}=e,{stateRoot:s,useState:c,state:a,isAtom:u}=rs(t.apiCtx,r),l=H(w({},t),{stateRoot:s,state:a,isAtom:u,internal:Y(s)}),i=ts({common:l,ldMutate:n,mutateFnDict:o,extra:t.stateRoot});return w({derivedState:s,useDerivedState:c},i)}function ei(e){const{common:t,deriveFnDict:n,throwErr:r}=e,o=es(t,n),{apiCtx:s,stateRoot:c}=t,a={},u={};return Object.keys(o).forEach(i=>{const f=Ro(o[i],c);a[i]=f,u[i]={runDerive:d=>Za(f,d!=null?d:r),runDeriveTask:d=>Qa(f,d!=null?d:r),useDerived:d=>Tn(s,f,d)[0],useDerivedInfo:d=>Tn(s,f,d)}}),{result:new Proxy(a,{get:(i,f)=>a[f].val}),helper:u}}function ti(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(o=>{const s=n[o];s.enabled||(s.enabled=!0,r[o]=s)}),_n(t.sharedState)(r)}}function ni(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}}function se(e,t){const{stateType:n,apiCtx:r}=e;Mn(r,n);const{sharedRoot:o,sharedState:s,internal:c}=Zu(e,t),{syncer:a,sync:u,forAtom:l,setState:i,setDraft:f,sharedKey:d,sharedKeyStr:p,rootValKey:h,reactive:m,reactiveRoot:y}=c,g=Ao(o),E=g(),A={internal:c,from:Qu,apiCtx:r},R=se,M=qr(R,H(w({},A),{from:Qo})),I=qr(R,A),D={createFn:R,internal:c,apiCtx:r,state:s,stateRoot:o,isAtom:l},k=H(w({},D),{ldAction:M,actionCreator:g});return{state:s,stateVal:s,stateRoot:o,setState:i,setDraft:f,setEnableMutate:S=>ti(S,c),getOptions:()=>ni(c),setOnReadHook:S=>c.onRead=S,defineActions:S=>v=>qo(H(w({},k),{actionDict:v}),S),defineTpActions:S=>v=>qo(H(w({},k),{actionDict:v,forTp:!0}),S),defineMutateDerive:S=>v=>qu({common:D,ldMutate:I,inital:S,mutateFnDict:v}),defineMutateSelf:()=>S=>ts({common:D,ldMutate:I,mutateFnDict:S}),defineFullDerive:S=>v=>ei({common:D,deriveFnDict:v,throwErr:S}),mutate:Mo(o),runMutate:S=>Io(o,S),runMutateTask:S=>wo(o,S),action:g,call:(S,v,_,b)=>E(S,_,b)(v),useState:S=>Fo(r,o,S),useStateX:S=>ko(r,o,S),useForceUpdate:S=>xo(r,o,S),useLocalState:S=>Vo(r,S),useLocalForceUpdate:()=>Bo(r),getMutateLoading:I.getLoading,useMutateLoading:I.useLoading,getActionLoading:M.getLoading,useActionLoading:M.useLoading,getSnap:S=>yr(o,S),sync:u,syncer:a,sharedKey:d,sharedKeyStr:p,rootValKey:h,reactive:m,reactiveRoot:y,reactiveDesc:S=>Ur(o,S),useReactive:S=>In(r,o,S),useReactiveX:S=>Yo(r,o,S),flush:S=>un(o,S),isAtom:l}}function ns(e,t,n){const r=se({apiCtx:e,rawState:t},n);return[r.stateRoot,r.setState,r]}function rs(e,t,n){return se({apiCtx:e,rawState:t},n)}function ri(e,t,n){const r=se({apiCtx:e,rawState:t,forAtom:!0},n);return[r.stateRoot,r.setState,r]}function oi(e,t,n){return se({apiCtx:e,rawState:t,forAtom:!0},n)}function os(e,t){const{label:n,isSyncer:r}=t,o=ye(e,{label:n});return(r?Xo:Jo)(o)}function si(e){return os(e,{label:"sync"})}function ci(e){return os(e,{label:"syncer",isSyncer:!0})}var ai=100,ui=5e3;function ii(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function fi(e,t=!1){const n=q();e&&(n.initCount+=1);const r=Mc(),o=ii(r,t);return Lr(e).set(r,o),o}function li(e){const t=q();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function di(e,t){const n=q(),r=Lr(t);if(r.delete(e),t&&r.size===ai&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const o=Date.now();r.forEach((s,c)=>{!s.mounted&&o-s.time>ui&&r.delete(c)})}}function pi(e,t){const n=q();n.runningKey=e.key,n.isDynamic=t}function yi(e){const t=q();t.runningKey="",t.isDynamic=!1,e.collected=!0}function hi(e,t,n){Hu(e,n,{manualDepKeys:t.depKeys})}function ss(e,t,n){let r={loading:!1,err:null,ok:!0};return hi(e,t,n),t.results.forEach(o=>{const s=Rn(e,{result:o,forAtom:fe(o),showLoading:t.enableStatus});s.status.ok||(r=s.status)}),r}function cs(e,t,n){e.react.useEffect(()=>(t.mounted||li(t),()=>{di(t.key,n)}),[t])}var mi=()=>!0,Fn=e=>e;function gi(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function kn(e,t,n,r,o){const s=t;return s.displayName=n,r?e.react.memo(s,o):s}function as(e,t){const{sharedState:n,depKey:r,keyPath:o,compare:s,sharedKey:c,format:a=Fn}=t;return kn(e,function(){const l=dn(e,n,{arrDep:!0});l.isFirstRender&&(o.length>=2?gi(o).forEach(d=>{l.recordDep({sharedKey:c,depKey:$(d,c),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},tt)}):l.recordDep({sharedKey:c,depKey:r,keyPath:o}));const i=ie(l.internal.rawState,o);return a(i)},"HeluxSignal",!0,s)}function Cn(e,t){return kn(e,function(){const{result:r,format:o=Fn}=t,s=Rn(e,{result:r,forAtom:!0});return o(s.proxyResult.val)},"HeluxDerivedAtomSignal",!0,t.compare)}function Ei(e,t){return kn(e,function(){const{result:r,keyPath:o,format:s=Fn}=t;return Rn(e,{result:r,forAtom:!1}),s(ie(r,o))},"HeluxDerivedSignal",!0,t.compare)}function us(e,t){const{isDynamic:n,cb:r,props:o,ref:s}=t,{collected:c,status:a}=e;c||pi(e,n);const l=r(o,{props:o,status:a,read:Ds,ref:s})||"";return c||yi(e),l}function is(e,t,n){const r=fe(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const o=Cn(e,{result:n});return e.react.createElement(o,{status:{loading:!1,err:null,ok:!0}})}return qn(n)}function fs(e,t,n,r){const{memo:o=!0,compare:s}=r||{},{key:c}=t,{react:a}=e,u=a.forwardRef||F,l=n();let i=u(l);ae()&&(l.displayName="HeluxKeyedBlockForHMR",i=u((d,p)=>(p&&Is(p,"current")&&(t.ref=p),a.createElement(l,H(w({},d),{key:c})))));const f=o?a.memo(i,s):i;return f.displayName="HeluxBlock",f[kt]=!0,f}function vi(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,{useForceUpdate:c}=o.hookImpl,a=r?cs:F;return fs(o,s,()=>(u,l)=>{const i=s.ref||l,f=us(s,{isDynamic:r,cb:n,props:u,ref:i}),d=c();return ss(o,s,d),a(o,s,r),is(o,s,f)},t)}function Si(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,c=r?cs:F,{useForceUpdate:a}=o.hookImpl,{useEffect:u}=o.react;return fs(o,s,()=>(l,i)=>{const f=s.ref||i,d=us(s,{isDynamic:r,cb:n,props:l,ref:f}),p=a(),h=ss(o,s,p);c(o,s,r);const m=s.status.loading,y=h.loading;return u(()=>{m!==y&&p()},[m,y]),s.status=h,is(o,s,d)},t)}function ls(e,t){const n=fu(t),{enableStatus:r}=n,o=H(w({},e),{blockCtx:fi(e.isDynamic,r)});return r?Si(o,n):vi(o,n)}function Ai(e,t,n){return ls({apiCtx:e,isDynamic:!1,cb:t},n)}function ds(e,t,n){return ls({apiCtx:e,isDynamic:!0,cb:t},n)}function ps(e,t,n){const{react:r}=e;if(t&&t[kt])return r.createElement(t);const o=mi;if(O(t)){const d=ds(e,t,{compare:o});return r.createElement(d)}if(fe(t)){const d=Cn(e,{result:t,compare:o,format:n});return r.createElement(d)}if(Re(t)){const d=re(t),p=Rt("val",d),m=as(e,{sharedKey:d,sharedState:t,depKey:p,keyPath:["val"],compare:o,format:n});return r.createElement(m)}const s=na(),{sharedKey:c,val:a,stateOrResult:u,depKey:l,keyPath:i,isDerivedResult:f}=s;if(t===a&&u){if(s.isDerivedAtom){const p=Cn(e,{result:u,compare:o,format:n});return r.createElement(p)}if(f){const p=Ei(e,{result:u,keyPath:i,compare:o,format:n});return r.createElement(p)}const d=as(e,{sharedKey:c,sharedState:u,depKey:l,keyPath:i,compare:o,format:n});return r.createElement(d)}return t}var{shallowCompare:Ki,isDiff:Di,isDraft:_i}=X.limuUtils,Ri=ns,Ti=ps,bi={EVENT_NAME:Mt,RECORD_LOADING:Ft,VER:Hn,LIMU_VER:Bs};function ys(e,t,n){return t(e,n)}function Ii(e,t){return ys(e,t)}function wi(e,t){return{build:n=>ys(e,t,n)}}var Mi=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function Fi(e){return e.startsWith("use")||Mi.includes(e)}function ki(e){return Object.assign({useSyncExternalStore:F},e)}function Ci(e,t){const n=Ps(e),r=w({},n),o={react:ki(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,a]=e.useState({});return()=>t(()=>a({}))});const s=Gn;return Object.keys(s).forEach(a=>{const u=s[a];Fi(a)?r[a]=u.bind(null,o):r[a]=u}),Object.assign({model:a=>Ii(r,a),modelFactory:a=>wi(r,a)},r)}function Oi(e){const{inited:t,API:n}=sc();if(t)return n;const{heluxCtxKey:r,standalone:o,transfer:s,reactLib:c,act:a}=e,u=Z[r],l=(i,f)=>{const d=f||tr(),p=Ci(c,a);return sr({ROOT:d,inited:!0,api:p}),Z[i]=d,p};if(!u)return l(r);if(o)return l(`${String(r)}_${Date.now()}`);if(s){const i=tr();sr({ROOT:i,inited:!0}),s(u,i)}return l(r,u)}var Li=L(70079),xi=L.t(Li,2),hs=Oi({heluxCtxKey:"__HELUX__",reactLib:xi}),Pi=hs.share,{atom:Ni,atomx:Ui,share:Bi,sharex:Vi,derive:Yi,deriveDict:Gi,defineDeriveTask:Hi,defineDeriveFnItem:ji,runDerive:$i,runDeriveTask:Wi,watch:Xi,watchEffect:zi,useAtom:Ji,useAtomX:Zi,useReactive:Qi,useReactiveX:qi,useDerived:ef,useWatch:tf,useWatchEffect:nf,useGlobalId:rf,useService:of,useOnEvent:sf,useMutable:cf,useMutateLoading:af,useActionLoading:uf,useEffect:ff,useLayoutEffect:lf,useStable:df,useObject:pf,useLocalForceUpdate:yf,useGlobalForceUpdate:hf,action:mf,signal:gf,block:Ef,dynamicBlock:vf,$:Sf,mutate:Af,mutateDict:Kf,runMutate:Df,runMutateTask:_f,defineMutateFnItem:Rf,sync:Tf,syncer:bf,model:If,modelFactory:wf,emit:Mf,on:Ff,init:kf,reactiveDesc:Cf,flush:Of,isAtom:Lf,isSharedState:xf,isDerivedAtom:Pf,isDerivedResult:Nf,isDraft:Uf,storeSrv:Bf,shallowCompare:Vf,markRaw:Yf,isDiff:Gf,produce:Hf,getMutateLoading:jf,getActionLoading:$f,getDeriveLoading:Wf,getRawState:Xf,getSnap:zf,getAtom:Jf,addMiddleware:Zf,addPlugin:Qf,cst:qf}=hs}}]);
}());