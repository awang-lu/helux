!(function(){"use strict";var el=Object.defineProperty,tl=Object.defineProperties;var nl=Object.getOwnPropertyDescriptors;var Kt=Object.getOwnPropertySymbols;var Es=Object.prototype.hasOwnProperty,vs=Object.prototype.propertyIsEnumerable;var gs=(U,B,P)=>B in U?el(U,B,{enumerable:!0,configurable:!0,writable:!0,value:P}):U[B]=P,w=(U,B)=>{for(var P in B||(B={}))Es.call(B,P)&&gs(U,P,B[P]);if(Kt)for(var P of Kt(B))vs.call(B,P)&&gs(U,P,B[P]);return U},j=(U,B)=>tl(U,nl(B));var Ss=(U,B)=>{var P={};for(var b in U)Es.call(U,b)&&B.indexOf(b)<0&&(P[b]=U[b]);if(U!=null&&Kt)for(var b of Kt(U))B.indexOf(b)<0&&vs.call(U,b)&&(P[b]=U[b]);return P};var As=(U,B,P)=>new Promise((b,J)=>{var ve=W=>{try{Se(P.next(W))}catch(Z){J(Z)}},$e=W=>{try{Se(P.throw(W))}catch(Z){J(Z)}},Se=W=>W.done?b(W.value):Promise.resolve(W.value).then(ve,$e);Se((P=P.apply(U,B)).next())});(self.webpackChunkhelux_docs=self.webpackChunkhelux_docs||[]).push([[3649],{73649:function(U,B,P){P.r(B),P.d(B,{$:function(){return Sf},action:function(){return mf},addMiddleware:function(){return Zf},addPlugin:function(){return Qf},atom:function(){return Ni},atomx:function(){return Ui},block:function(){return Ef},createShared:function(){return Pi},cst:function(){return qf},defineDeriveFnItem:function(){return Hi},defineDeriveTask:function(){return ji},defineMutateFnItem:function(){return Rf},derive:function(){return Yi},deriveDict:function(){return Gi},dynamicBlock:function(){return vf},emit:function(){return Mf},flush:function(){return Of},getActionLoading:function(){return $f},getAtom:function(){return Jf},getDeriveLoading:function(){return Wf},getMutateLoading:function(){return Hf},getRawState:function(){return Xf},getSnap:function(){return zf},init:function(){return kf},isAtom:function(){return xf},isDerivedAtom:function(){return Pf},isDerivedResult:function(){return Nf},isDiff:function(){return Gf},isDraft:function(){return Uf},isSharedState:function(){return Lf},markRaw:function(){return Yf},model:function(){return If},modelFactory:function(){return wf},mutate:function(){return Af},mutateDict:function(){return Kf},on:function(){return Ff},produce:function(){return jf},reactiveDesc:function(){return Cf},runDerive:function(){return $i},runDeriveTask:function(){return Wi},runMutate:function(){return Df},runMutateTask:function(){return _f},shallowCompare:function(){return Vf},share:function(){return Bi},sharex:function(){return Vi},signal:function(){return gf},storeSrv:function(){return Bf},sync:function(){return Tf},syncer:function(){return bf},useActionLoading:function(){return uf},useAtom:function(){return Ji},useAtomX:function(){return Zi},useDerived:function(){return ef},useEffect:function(){return ff},useGlobalForceUpdate:function(){return hf},useGlobalId:function(){return rf},useLayoutEffect:function(){return lf},useLocalForceUpdate:function(){return yf},useMutable:function(){return cf},useMutateLoading:function(){return af},useObject:function(){return pf},useOnEvent:function(){return sf},useReactive:function(){return Qi},useReactiveX:function(){return qi},useService:function(){return of},useStable:function(){return df},useWatch:function(){return tf},useWatchEffect:function(){return nf},watch:function(){return Xi},watchEffect:function(){return zi}});function b(e,t){e.includes(t)||e.push(t)}function J(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function ve(e){return Array.from(new Set(e))}function $e(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function Se(e,t){let n="";const r=e.length;for(let o=0;o<r;o++){const s=e[o];if(t.startsWith(s)){n=s;break}}return n}function W(e,t,n){if(!e)return[];const r=e(t,n);return Array.isArray(r)?r:[r]}var Z=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),xn=!1;function F(...e){}var Ks=F;function Ds(...e){return e}function Ae(...e){return[]}function rl(...e){}var _s=Object.prototype.toString,Rs="[object Map]";function ol(){return!(typeof window!="undefined"&&window.document)}function Dt(e){return _s.call(e)===Rs}function Ln(e){return e===Number.MAX_SAFE_INTEGER}function ae(){return!(!xn&&Z.name!=="previewFrame"&&!Z.BrowserFS)}function z(e){return e&&typeof e=="object"&&!Array.isArray(e)}function Pn(e){return e&&typeof e=="object"}function O(e){return typeof e=="function"}function sl(e){return xn?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function _t(e){return typeof e=="symbol"}function Rt(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&O(e.then)}function cl(e){try{return e.test,!1}catch(t){return!0}}function Ie(){return typeof Proxy=="function"}function ue(e,t){const{throwErr:n=!1,prefixLabel:r="",suffixLabel:o=", see details in console.",logErr:s=!0,alertErr:c}=t||{};let a=e,u=!1;if(e instanceof Error&&(u=!0,a=e.message),(typeof c=="boolean"?c:ae())&&Z.alert&&e&&Z.alert(`${r}${a}${o}`),s&&console.error(e),n)throw u?e:new Error(String(e))}function Ke(e,t=0){t===0?(console.error(e),ae()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function we(e){return Ln(e)?1:e+1}var Ts=!!Reflect,bs=Object.prototype.hasOwnProperty;function Is(e,t){return Ts?Reflect.has(e,t):bs.call(e,t)}function Me(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function Fe(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function Nn(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function Un(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function ie(e,t){let n,r=e;return t.forEach(o=>{n=Dt(r)?Un(r,o):r[o],r=n}),n}function Bn(e,t,n){let r=e;const o=t.length-1;t.forEach((s,c)=>{const a=Dt(r);if(c===o)return void(a?r.set(s,n):r[s]=n);r=a?Un(r,s):r[s]})}function ws(){return Ke("changing shared state is invalid"),!0}function al(e){return e}function Tt(e,t){return`${t}/${e}`}function bt(e){return e&&Ie()}var Ms=Object.defineProperty,It={};((e,t)=>{for(var n in t)Ms(e,n,{get:t[n],enumerable:!0})})(It,{useEffect:()=>Os,useEffectLogic:()=>Mt,useForceUpdate:()=>Vn,useLayoutEffect:()=>Cs,useObject:()=>Ls,useObjectLogic:()=>Gn,useStable:()=>Yn});var Fs=0,We=new Map,wt=0;function ks(e,t){const n=()=>{const r=t();return()=>{We.delete(e),r&&r()}};if(function(r){wt||(wt=r)}(e),function(r){const o=We.get(r);o?o.count+=1:We.set(r,{count:1})}(e),wt%2!=0)return n();{const r=function(o){return We.get(o)}(e);if(r&&r.count>1)return n()}}function Mt(e,t,n){const{useState:r,useLayoutEffect:o,useEffect:s}=e.react,{isLayout:c,deps:a}=n,[u]=r(()=>++Fs);(c?o:s)(()=>ks(u,t),a)}function Cs(e,t,n){Mt(e,t,{isLayout:!0,deps:n})}function Os(e,t,n){Mt(e,t,{deps:n})}function Vn(e){const[,t]=e.react.useState({});return()=>t({})}function xs(e){const{data:t}=e.current;O(t)?e.current.wrap=(...n)=>e.current.data(...n):z(t)?e.current.wrap=function(n,r){if(!Ie()){const s={};return Object.keys(n).forEach(c=>{const a=n[c];O(a)?s[c]=(...u)=>r.current.data[c](...u):Object.defineProperty(s,c,{get:()=>r.current.data[c],set(u){r.current.data[c]=u}})}),s}const o={};return new Proxy(n,{get(s,c){const a=s[c];return O(a)?Me(o,c,(...u)=>r.current.data[c](...u)):a}})}(t,e):e.current.wrap=t}function Yn(e,t){const{useRef:n,useMemo:r}=e.react,o=n({data:t,wrap:{},inited:!1});return o.current.data=r(()=>t,[t]),o.current.inited||(xs(o),o.current.inited=!0),o.current.wrap}function Gn(e,t,n,r){const{useState:o,useRef:s,useEffect:c}=e.react,[a]=o(t),u=Vn(e),l=s({state:null,unmount:!1,shouldCopy:!0}),i=Yn(e,{setState(f){const d=l.current;if(d.unmount)return;let p;const{state:y}=d;n?(p=n(f,d.state||a),r&&p?(d.state=p,d.shouldCopy=!1):d.shouldCopy=!0):(p=(O(f)?f(y):f)||{},d.shouldCopy=!0),Object.assign(a,p||{}),u()},getLatestState(){const f=l.current;return f.shouldCopy&&(f.state=w({},a),f.shouldCopy=!1),f.state}});return c(()=>{const f=l.current;return f.unmount=!1,()=>{f.unmount=!0}},[l]),[a,i.setState,i]}function Ls(e,t){return Gn(e,t)}function Ps(e){const t={},n={react:e},r=It;return Object.keys(It).forEach(o=>{t[o]=r[o].bind(null,n)}),t}var X=P(2312),Ns=Object.defineProperty,Us=(e,t)=>{for(var n in t)Ns(e,n,{get:t[n],enumerable:!0})},jn={};Us(jn,{$:()=>Ti,action:()=>Ko,addMiddleware:()=>ac,addPlugin:()=>lc,atom:()=>ri,atomx:()=>oi,block:()=>Ai,createShared:()=>Ri,cst:()=>bi,currentDraftRoot:()=>Uc,defineDeriveFnItem:()=>Du,defineDeriveTask:()=>Ku,defineMutateFnItem:()=>bu,derive:()=>To,deriveDict:()=>Au,dynamicBlock:()=>ps,emit:()=>hc,flush:()=>fn,getActionLoading:()=>Nu,getAtom:()=>er,getDeriveLoading:()=>qa,getMutateLoading:()=>Lu,getRawState:()=>Kc,getSnap:()=>hr,init:()=>cc,isAtom:()=>Re,isDerivedAtom:()=>fe,isDerivedResult:()=>qs,isDiff:()=>Di,isDraft:()=>_i,isSharedState:()=>Qs,markRaw:()=>X.Xl,mutate:()=>Fo,mutateDict:()=>Rn,on:()=>mc,produce:()=>X.Uy,reactiveDesc:()=>Br,runDerive:()=>za,runDeriveTask:()=>Ja,runMutate:()=>wo,runMutateTask:()=>Mo,shallowCompare:()=>Ki,share:()=>rs,sharex:()=>os,signal:()=>ys,storeSrv:()=>Gu,sync:()=>si,syncer:()=>ci,useActionLoading:()=>Uu,useAtom:()=>ko,useAtomX:()=>Co,useDerived:()=>bn,useGlobalForceUpdate:()=>Po,useGlobalId:()=>xu,useLocalForceUpdate:()=>Vo,useMutable:()=>Yo,useMutateLoading:()=>Pu,useOnEvent:()=>Bu,useReactive:()=>wn,useReactiveX:()=>Go,useService:()=>Yu,useWatch:()=>Hu,useWatchEffect:()=>$u,watch:()=>du,watchEffect:()=>pu});var Hn="4.2.7",Bs=X.TT,Ft={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},kt={NO:"no",PRIVATE:"private",GLOBAL:"global"},$n=0,Wn=Symbol,Vs=typeof Wn=="function";function ee(e){return Vs?Wn(e):($n+=1,`__HELUX_SYMBOL_${$n}__`)}var Ys="__proto__",Gs=Ie(),js=ee("HeluxUndefined"),Xn=ee("HeluxMutateFnItem"),Xe=ee("HeluxFnKey"),ze=ee("HeluxSharedKey"),zn=ee("HeluxReactiveMeta"),Ct=ee("HeluxIsBlock"),De=ee("HeluxIsAtom"),ke=ee("HeluxIsDerivedAtom"),Je=[ze,De,ke,Ct],Ze="SingleMutate",Hs="HeluxGlobalLoading",$s=6,Ws=!0,Jn=2e3,Xs=20,Ce="1",Ot="2",Qe=1,qe=2,Zn=3,_e="|",et={TASK:"task",MAY_TRANSFER:"may_transfer"},te={STATIC:"static",HOOK:"hook"},Q={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},Qn="derive",qn="watch",tt="Object",zs="Map",Js="Array",Zs="Other",H={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function Re(e){var t;return e&&(t=e[De])!=null?t:!1}function Qs(e){return e?e[De]!==void 0:!1}function fe(e){return e&&e[ke]||!1}function qs(e){return e?e[ke]!==void 0:!1}function er(e){return Re(e)||fe(e)?e.val:e}function ec(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],delPathAoa:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,SKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function tc(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function nc(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function rc(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function tr(){const e={};return{on:(t,n)=>{Me(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(o=>o(...n))},off:(t,n)=>{const r=e[t]||[],o=r.findIndex(s=>s===n);o>=0&&r.splice(o,1)},canEmit:t=>e[t]}}function nr(){const e={VER:Hn,LIMU_VER:X.TT,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:tr(),userBus:tr(),mod:{},middlewares:[],plugins:[],sharedScope:rc(),fnScope:ec(),insScope:nc(),blockScope:tc(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var nt={},rr=!1,or=null,sr=!1;function G(){return nt.ctx||{}}function oc(){return nt}function cr(e){nt=e.ROOT,or=e.api,rr=e.inited}function sc(){return{ROOT:nt,inited:rr,API:or}}function cc(e){if(sr)return!1;sr=!0;const{isRootRender:t=!0}=e;return G().isRootRender=t,!0}function ac(e){const{middlewares:t}=G();t.push(e)}function uc(e,t,n,r){const{middlewares:o}=G();if(!o.length)return;const s={},{sharedKey:c,moduleName:a,forAtom:u}=e,i={forAtom:u,draftRoot:t,draft:n,sharedKey:c,moduleName:a,setData:(f,d)=>s[f]=d,data:s,idx:0,sn:r};o.forEach((f,d)=>{f(j(w({},i),{idx:d}))})}var{ON_DATA_CHANGED:xt,ON_SHARE_CREATED:ar,ON_ERROR_OCCURED:ic}=Ft,fc=[Q.GLOGAL_LOADING,Q.PRIVATE_LOADING];function lc(e){const{plugins:t,bus:n}=G();t.push(e);const r={on:(o,s)=>n.on(o,s),onStateChanged:o=>n.on(xt,o)};e.install(r)}function dc(e,t){const{bus:n}=G();if(n.canEmit(xt)){const{from:r,desc:o}=t,{forAtom:s,sharedKey:c,moduleName:a,snap:u,usefulName:l,stateType:i}=e;let f;fc.includes(i)?f=`${l}/setState`:f=`${l}@${r||"Api"}/${o}`,n.emit(xt,{forAtom:s,snap:u,sharedKey:c,moduleName:a,usefulName:l,type:f})}}function pc(e){const{bus:t}=G();if(t.canEmit(ar)){const{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c}=e,a=`${c}@FactoryApi/createShared`;t.emit(ar,{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c,type:a})}}function ur(e,t,n){const{bus:r}=G();if(!r.canEmit(t))return!1;const{sharedKey:o,moduleName:s}=e;return r.emit(t,{moduleName:s,sharedKey:o,data:n}),!0}function ir(e,t){ur(e,ic,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function yc(){const{userBus:e}=G();return e}function hc(e,...t){const{userBus:n}=G();n.emit(e,...t)}function mc(e,t){const{userBus:n}=G();return n.on(e,t),()=>n.off(e,t)}function gc(e,t){return e.__proto__=t,e}function Ec(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var Lt=Object.setPrototypeOf||({__proto__:[]}instanceof Array?gc:Ec);function vc(e){const t=Object.create(null);return Lt(t,w({},Object.prototype)),e&&Object.assign(t,e),t}function fr(e){if(O(e))return;const t=Object.create(null);return Lt(t,Object.prototype),Lt(e,t),e}function lr(e,t,n){return e[t]=n,!0}function dr(e,t){return e[t]}function Oe(e,t){const{set:n=lr,get:r=dr,obj:o={}}=t||{};return Object.keys(e).forEach(s=>{Object.defineProperty(o,s,{enumerable:!0,configurable:!1,set:function(c){return n(e,s,c)},get:function(){return r(e,s)}})}),o}function le(e,t){const{set:n=lr,get:r=dr}=t||{};if(Ie())return new Proxy(e,{set(c,a,u){return n(c,a,u)},get(c,a){return r(c,a)}});const o=vc();return Oe(o,{obj:o,set:n,get:r})}var xe=G();function rt(e){const n=G()[e];return xe[e]=n,n}function q(){return xe.blockScope||rt("blockScope")}function V(){return xe.fnScope||rt("fnScope")}function ne(){return xe.sharedScope||rt("sharedScope")}function pr(){return xe.insScope||rt("insScope")}function yr(){const{INTERMAL_MAP:e}=ne();return e}function Sc(e,t){if(!e||!ae()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:o}=ne();let s=[],c=!1;if(n.forEach(a=>{a.moduleName===e&&a.loc===t&&a.stateType===Q.USER_STATE&&s.push(a.sharedKey)}),s.length>1){const a=s[0],u=n.get(a);n.delete(a),u&&(r.delete(u.sharedKey),o.delete(u.rawState))}return c}function Le(e){return yr().get(e)}function Y(e){const t=re(e);return Le(t)}function Ac(e,t){const n=yr(),r=re(e);n.set(r,t)}function Kc(e){return Y(e).rawState}function hr(e,t=!0){const n=Y(e);return t?n.prevSnap:n.snap}function re(e){return e&&(e[ze]||ne().STATE_SHARED_KEY_MAP.get(e))||0}function Pt(e){let t={state:{},stateRoot:{},isAtom:!1};if(!e)return t;const n=Y(e);if(n){const{sharedState:r,sharedRoot:o}=n;t={state:r,stateRoot:o,isAtom:n.forAtom}}return t}function Dc(e){const t=ne(),{STATE_SHARED_KEY_MAP:n}=t,r=we(t.keySeed);return n.set(e,r),t.keySeed=r,r}function _c(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=ne();n.set(e,t),r.set(t,e)}function Rc(e){return ne().SHARED_KEY_STATE_MAP.get(e)}function Tc(e,t){const{rootState:n,ctx:r}=oc(),{moduleName:o,usefulName:s}=t,c=n[s],a=Y(c);if(o&&a&&a.loc!==t.loc){const u=`
loc1:${a.loc} 
loc2:${t.loc}`;return Ke(`only-dev-mode tip: moduleName ${o} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+u)}n[s]=e,r.mod[s]=Y(e)}var bc={innerSetState:F};function mr(e,t){const{rawState:n,forAtom:r}=e,o=new Map,s={},c={},a=[],u=w({},n);let l=u;return r&&(l=n.val),j(w(w({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:F,syncer:F,snap:u,prevSnap:u,rawStateVal:l},e),t),{insCtxMap:o,key2InsKeys:s,id2InsKeys:c,recordId(i,f){if(!i)return;const d=Me(c,i,[]);b(d,f)},delId(i,f){i&&J(c[i]||[],f)},recordDep(i,f){const d=Me(s,i,[]);b(d,f)},delDep(i,f){J(s[i]||[],f)},mapInsCtx(i,f){o.set(f,i)},delInsCtx(i){o.delete(i)},extra:{},loadingInternal:bc,level1ArrKeys:a})}var Ic={Mutate:"",Reactive:"r",[te.STATIC]:"s",[te.HOOK]:"h"};function wc(){const e=pr(),t=we(e.keySeed);return e.keySeed=t,t}function Mc(){const e=q(),{keySeed:t,keyPrefix:n}=e,r=we(t);e.keySeed=r;let o=n;return Ln(t)&&(o=we(n),e.keyPrefix=o),`${o}_${r}`}function Fc(){const e=G(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function Nt(e){const t=Ic[e],r=V().keySeed,o=we(r[e]);return r[e]=o,`${t}${o}`}function kc(){return Nt("Reactive")}var{MAY_TRANSFER:Cc}=et,{SET_STATE:Oc,REACTIVE:xc}=H,Lc=()=>({isReplaced:!1,replacedValue:null}),Pc=()=>{},Nc=Bt({isFake:!0});function gr(e,t,n=F){const{desc:r="",onRead:o,from:s=xc,depKeys:c=[],isTop:a=!1,expired:u=!1,insKey:l=0}=t;return{draft:e,finish:n,modified:!1,expired:u,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:F,data:[],isTop:a,key:"",fnKey:"",depKeys:c,writeKeys:[],desc:r,onRead:o,from:s,insKey:l}}function Ut(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:o=Oc,enableDep:s=!1,handleCbReturn:c=!0,sn:a=Fc(),isFirstCall:u=!1,desc:l=""}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:c,draftVal:null,from:o,isReactive:r,enableDep:s,sn:a,isFirstCall:u,desc:l}}function Pe(e,t,n){const{isChanged:r=!0,parentKeyPath:o=[],op:s="set",parentType:c="Object"}=n,a=o.slice();return a.push(e),{isChanged:r,isCustom:!1,op:s,immutBase:!1,key:e,value:t,proxyValue:t,parentType:c,keyPath:o,fullKeyPath:a,isBuiltInFnKey:!1,replaceValue:F,getReplaced:Lc}}function Bt(e){const f=e||{},{desc:t="",fn:n=F,task:r=Pc,depKeys:o=[],writeKeys:s=[],deps:c=Ae,isFake:a=!1,onlyDeps:u=!1}=f,l=Ss(f,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return w({fn:n,task:r,deps:c,oriDesc:"",onlyDeps:u,desc:t,depKeys:o,writeKeys:s,checkDeadCycle:void 0,watchKey:"",isFake:a,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}},l)}function Er(){const e={fnKey:"",fn:F,subFnInfo:Nc,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:F,deps:Ae,status:{loading:!1,err:null,ok:!0},stateRoot:{},isStateAtom:!1,forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:Qe,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:Ce,proxyResult:{},updater:F,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:F},asyncType:Cc,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var vr={draftRoot:{val:null},isFake:!0,isAtom:!0},Sr=Ut({}),ot=gr(!0,{expired:!0}),ul=Bt(),Ar=mr({rawState:{},forAtom:!1,usefulName:""},{}),Kr=Er(),st=vr,Vt=Sr,Dr="",Yt=new Map,Gt=new Map,jt=new Map,Ht=F,$t=[],Wt="";function Uc(){return st}var Ne={current:()=>Wt,set:e=>Wt=e,del:()=>Wt=""},Xt={current:()=>Ht,set:e=>Ht=e,del:()=>Ht=F},Ue={current:e=>Gt.get(e)||"SetState",set:(e,t)=>Gt.set(e,t),del:e=>Gt.delete(e)},Be={current:()=>$t,set:e=>$t=e,del:()=>$t=[]},oe={current:()=>jt.get(Dr)||ot,markUsing:e=>Dr=e,set:(e,t)=>jt.set(e,t),del:e=>jt.delete(e)},zt={current:e=>Yt.get(e),set:(e,t)=>Yt.set(e,t),del:e=>Yt.delete(e)},ct={current:()=>st,set:(e,t)=>{Object.assign(st,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>st=vr},Jt={current:()=>Vt,set:e=>Vt=e,del:()=>Vt=Sr};function Zt(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=V();return e[0]==="s"?t:n}function Bc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=V();Fe(n,e,[]).push(t)}function Vc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=V(),r=n.get(e);r&&J(r,t)}function Yc(e){const{DEPKEY_FNKEYS_MAP:t}=V(),{depKeys:n,fnKey:r}=e;n.forEach(o=>{const s=t.get(o)||[];J(s,r)})}function _r(e,t){const{FNKEY_STATIC_CTX_MAP:n}=V(),{fnKey:r,prevLevelFnKeys:o}=e;o.forEach(s=>{var a;const c=(a=n.get(s))==null?void 0:a.nextLevelFnKeys;c&&(t?b(c,r):J(c,r))})}function Gc(){const{FNKEY_HOOK_CTX_MAP:e}=V();ae()&&e.forEach(t=>{t.isExpired=!0})}function Rr(e,t,n){const r=n||Nt(t);return O(e)?e[Xe]=r:(fr(e),e.__proto__[Xe]=r),r}function Tr(e){return O(e)?e[Xe]||"":z(e)&&e.__proto__[Xe]||""}function de(e){return Zt(e).get(e)}function Qt(e){return Zt(e).get(e)||Kr}function Ve(e){const t=Tr(e);return de(t)||null}function Ye(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r,delPathAoa:o}=V();return{fnCtx:e?de(e):null,depKeys:t,delPathAoa:o,isIgnore:r,runningSharedKey:n}}function jc(){return V().runningFnKey}var{USER_STATE:Hc}=Q;function $c(e,t=8){let n="";if(ae()&&e)try{throw new Error("loc")}catch(r){const o=r.stack.split(`
`),s=o[1]||"";s.includes("webpack-internal")||s.includes("/node_modules/")?n=o.slice(0,16).join(" -> "):n=o.map(a=>a.substring(0,a.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function br(e){const[t,n]=e.split("/"),r=n.split(_e);return{sharedKey:Number(t),keyPath:r,depKey:e}}function Ir(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",o=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:o,sharedKey:t}}function $(e,t){try{return Tt(e.join(_e),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Wc(e,t){const{snap:n,prevSnap:r,stateType:o}=e;if(Hc!==o)return!0;const{keyPath:s}=br(t);try{const c=ie(n,s),a=ie(r,s);return c!==a}catch(c){return!0}}function Xc(e,t){return Ie()?(0,X.OA)(e,{onOperate:t,compareVer:!0}):le(e,{get(n,r){const o=n[r],s=Pe(r,o,{isChanged:!1,parentKeyPath:[]});return t(s),o}})}function zc(e,t){if(t!==void 0){if(e)return{val:t};if(z(t))return t}}function Jc(e,t,n){const r=O(t)?t(n):t;return zc(e,r)}function at(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:o}=e.getReplaced();o&&(n=r)}return n}function wr(e){return[Js,zs].includes(e)}function Zc(e){return Array.isArray(e)||Dt(e)}var{isObject:pe,getDataType:Mr}=X.limuUtils;function qt(e,t){return typeof e=="boolean"?e:t}function Fr(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(_e);return`${e}${_e}${r[0]}`}function Qc(e,t){Se(e,t)||b(e,t)}var en=new Map;function kr(e,t){let n=!1;const{depKey:r,keyPath:o,sharedKey:s}=e,{stopDepInfo:c,level1ArrKeys:a,recordCb:u}=t,l=en.get(r);if(l)return u(l),!0;const{keys:i,isArrDict:f,depth:d,arrKeyStopDcit:p,stopArrDep:y}=c,m=Se(a,r),h=o.length>d;if(h||m){let E="",K=d;return m&&(K=d+1,p[m]===!1||y&&(h?E=$(o.slice(0,K),s):E=Fr(m,r))),E||(E=$(o.slice(0,K),s)),m||en.set(r,E),u(E),!0}const g=String(s);for(const E of i){if(!r.startsWith(E)||E===g)continue;const K=f[E],_=K?Fr(E,r):E;K||en.set(r,_),u(_),n=!0;break}return n}function tn(e,t){const n=q(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:o,KEY_CTX_MAP:s,isDynamic:c}=n,u=(c?o:s).get(r);if(u){const{results:l,depKeys:i}=u;t?b(l,t):e.forEach(f=>b(i,f))}}}function ut(e,t){const n=ne(),{COMPARE_MAP:r}=n;let o=r.get(t);return o!==void 0?o:e.sharedKeyStr===t?n.isStateChanged:(o=Wc(e,t),r.set(t,o),o&&(n.isStateChanged=!0),o)}function Cr(e,t,n){if(t.includes(n)&&ut(e,n))return!0;let r=!1;for(const o of t)o.startsWith(n)&&ut(e,o)&&(r=!0);return r}function qc(){const e=ne();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function nn(e=!0){const t=V();t.isIgnore=e}function Te(e,t){const{fnCtx:n,depKeys:r,isIgnore:o}=Ye(),s=t.specificCtx||n;if(!s){Xt.current()(e);return}const{DEPKEY_FNKEYS_MAP:c,SKEY_FNKEYS_MAP:a}=V(),{belongCtx:u,sharedKey:l}=t;if(l&&b(s.depSharedKeys,l),n&&u){n.isFirstLevel=!1,u.isAsync&&(n.isAsync=!0);const f=u.fnKey;b(s.prevLevelFnKeys,f),b(u.nextLevelFnKeys,n.fnKey)}const{fnKey:i}=s;e.forEach(f=>{if(Ys===f||o)return;n&&b(r,f);const d=Fe(c,f,[]);b(d,i);const[p]=f.split("/"),y=Fe(a,p,[]);b(y,i)})}function rn(e){e&&e.depKeys.forEach(t=>Te([t],{specificCtx:e}))}function Or(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=V(),{fnKey:r}=e;t.set(r,e),_r(e,!0);let o=n.get(r);o?o.c=2:(o={c:1,t:Date.now(),prev:0},n.set(r,o));const{c:s}=o;if(s===2){const c=de(r);rn(c)}}function xr(e){let t="";return e.depSharedKeys.forEach(n=>{var o;const r=((o=Le(n))==null?void 0:o.ver)||0;t+=`${r}_`}),t}function ea(e,t,n,r=!1){const{DEPKEY_FNKEYS_MAP:o,SKEY_FNKEYS_MAP:s}=V(),a=(r?s:o).get(t)||[],u=[],l=[];return a.forEach(i=>{const f=de(i);if(f&&Cr(e,f.depKeys,t)){f.isFirstLevel&&u.push(i),f.isAsync&&f.fnType===Qn&&l.push(i);const d=n[i];d===void 0?n[i]=1:r||(n[i]=d+1)}}),{firstLevelFnKeys:u,asyncFnKeys:l}}function on(e){Yc(e),_r(e)}function ta(){const{FNKEY_HOOK_CTX_MAP:e}=V();if(e.size>=Xs){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:o,fnKey:s}=n;[Qe,Zn].includes(r)&&t-o>Jn&&(on(n),e.delete(s))})}}function sn(e,t,n,r,o,s=!1,c=!1){const a=q();a.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:o,isDerivedResult:s,isDerivedAtom:c}}function na(){return q().latest}function Lr(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=q();return e?t:n}function Pr(){return Ke("changing shared state is invalid"),!0}function it(e,t,n,r,o){return r===De?e?t:!1:r===ze?n:o}function cn(e,t,n){e.replaceValue(it(e.keyPath.length===0,t,n,e.key,e.value))}function ra(e){let t={};const{rawState:n,sharedKey:r,forAtom:o,onRead:s,isPrimitive:c,stopDepth:a}=e,u=(i,f)=>{const d=$(i,r);Te([d],{sharedKey:r}),tn([d]),sn(r,f,t,d,i)};if(Gs)t=(0,X.OA)(n,{customKeys:Je,onOperate:i=>{const{isBuiltInFnKey:f,isCustom:d}=i;if(d)return cn(i,o,r);if(!f){const{fullKeyPath:p}=i,y=at(i,s);u(p,y)}},compareVer:!0});else{const i=(f,d,p)=>Oe(f,{set:Pr,get:(y,m)=>{const h=y[m];if(Je.includes(m))return it(d===1,o,r,m,h);const g=Pe(m,h,{isChanged:!1,parentKeyPath:p});if(d<a&&pe(h))return i(h,d+1,g.fullKeyPath);const E=at(g,s);return u(g.fullKeyPath,E),E}});t=i(n,1,[])}let l=t;return o&&(c?l=n.val:l=le(n,{set:Pr,get:(i,f)=>t.val[f]})),_c(r,t),{sharedRoot:t,sharedState:l}}var Nr=null;function an(){return Nr}function oa(e,t){const n=G();let r=n.globalEmpty;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:Q.GLOGAL_EMPTY}),s=Y(o);n.globalEmpty=o,n.globalEmptyInternal=s}return Nr=r,r}function un(e){const{GID_INSKEYS_MAP:t}=V();return Fe(t,e,[])}function sa(){return G().globalEmptyInternal}function Ur(e,t){if(!e)return;const n=un(e);b(n,t)}function ca(e,t){if(!e)return;const n=un(e);J(n,t)}var{REACTIVE:aa}=H,Ge=new Map;function ua(e){return!!(e&&!e.expired&&e.modified)}function ia(e){const{sharedKey:t}=e;e.expired=!0,oe.del(e.key);const n=Ue.current(t);return Ue.del(t),e.finish(null,{desc:n})}function Br(e,t){const n=re(e);return t&&Ue.set(n,t),n}function fn(e,t){const n=re(e);je(n,t)}function fa(){const e=oe.current();e.isTop&&je(e.sharedKey,e.desc)}function je(e,t){const n=Ge.get(e);ua(n)&&(t&&Ue.set(e,t),ia(n))}function la(e){const t=Ge.get(e)||ot;t.expired=!0}function da(e,t){const n=Ge.get(e)||ot;n.modified=!0,n.nextTickFlush(t)}function pa(e,t){const{from:n=aa}=t,{finish:r,draftRoot:o}=e.setStateFactory({isReactive:!0,from:n,handleCbReturn:!1,enableDep:!0}),s=gr(o,t,r);return s.key=kc(),s.sharedKey=e.sharedKey,s.nextTickFlush=c=>{const{expired:a,hasFlushTask:u}=s;a||(s.data=[c]),u||(s.hasFlushTask=!0,Promise.resolve().then(()=>{const[l]=s.data;je(e.sharedKey,l)}))},s}function Vr(e,t,n){const{sharedKey:r}=e,{insKey:o=0,from:s}=t;let c=Ge.get(r)||ot;c.expired&&(c=pa(e,{isTop:!0,from:s}),Ge.set(r,c),oe.set(c.key,c),c.fnKey=Ne.current()),oe.markUsing(c.key),c.onRead=o?t.onRead:void 0,c.insKey=o;const{draft:a}=c;return{val:n?a.val:a,meta:c}}function ln(e,t){let n={},r={};const{rawState:o,deep:s,forAtom:c,isPrimitive:a,sharedKey:u}=e;if(bt(s)){const l={[ze]:u,[De]:c},i=(d,p,y)=>{const{val:m}=Vr(e,t,d);return m[p]=y,!0},f=(d,p,y)=>{const m=y[p];if(m!==void 0)return m;const{val:h,meta:g}=Vr(e,t,d);return zn===p?g:h[p]};if(n=new Proxy(o,{set:(d,p,y)=>i(!1,p,y),get:(d,p)=>f(!1,p,l)}),r=n,c){const d=j(w({},l),{[De]:!1});r=a?o.val:new Proxy(o.val,{set:(p,y,m)=>i(!0,y,m),get:(p,y)=>f(!0,y,d)})}}else n=o,r=o.val;return{draftRoot:n,draft:r}}function ya(e){const{UNMOUNT_INFO_MAP:t}=pr(),{insKey:n,readMap:r,internal:o}=e;o.mapInsCtx(e,n);let s=t.get(n);s?(s.c=2,s.prev=n-1):(s={c:1,t:Date.now(),prev:0},t.set(n,s));const{c}=s;c===2&&Object.keys(r).forEach(a=>{o.recordDep(a,n)})}function Yr(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(o=>r.delDep(o,n)),r.delInsCtx(n)}function ha(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function ma(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function Gr(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:o}=n,s=Zc(o);s&&Qc(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,s)}function dn(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:o}=e;return(t?r:n).concat(o)}function ga(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===Qe){Date.now()-r>Jn?Yr(e):e.needEFUpdate=!0;return}t()}function jr(e){const{internal:t,isReactive:n,insKey:r}=e,{rawState:o,isDeep:s,sharedKey:c,onRead:a,forAtom:u}=t;if(s){const l=i=>{const{isBuiltInFnKey:f,key:d}=i;if(f)return;if(_t(d))return cn(i,u,c);const{fullKeyPath:p,keyPath:y,parentType:m}=i,h=at(i,a),E={depKey:$(p,c),keyPath:p,parentKeyPath:y,sharedKey:c};Gr(e,E,{parentType:m,rawVal:h})};if(n){const{draft:i,draftRoot:f}=ln(t,{onRead:l,insKey:r});e.proxyState=f,e.proxyStateVal=i}else e.proxyState=(0,X.OA)(o,{onOperate:l,compareVer:!0})}else e.proxyState=le(o,{set:()=>(Ke("changing shared state is invalid"),!0),get:(l,i)=>{const f=l[i];if(_t(i))return it(!0,u,c,i,f);const d=at(Pe(i,f,{isChanged:!1,parentKeyPath:[]}),a),p=Tt(i,c),y=pe(l)?tt:Zs;return Gr(e,{depKey:p,keyPath:[i],sharedKey:c},{parentType:y,rawVal:d}),d}})}function Ea(e){var k;const{updater:t,sharedState:n,id:r="",globalId:o="",collectType:s="every",deps:c,pure:a=!0,arrDep:u=!0,isReactive:l=!1}=e,i=u&&(k=e.arrIndexDep)!=null?k:!0,f=Y(n);if(!f)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=wc(),{rawState:p,isDeep:y,ver:m,ruleConf:h,level1ArrKeys:g,forAtom:E,sharedKey:K,sharedKeyStr:_,snap:M}=f,{stopDepInfo:I}=h,D={readMap:{},delReadMap:{},pure:a,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:y,isReactive:l,insKey:d,internal:f,rawState:p,sharedState:n,sharedKey:K,proxyState:{},proxyStateVal:{},updater:t,mountStatus:Qe,renderStatus:Ce,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:m,id:r,globalId:o,collectType:s,canCollect:s!=="no",isFirstRender:!0,subscribe:v=>{v()},extra:{},getDeps:()=>dn(D,!0),renderInfo:{isAtom:E,setDraft:f.insSetDraft,time:Date.now(),sn:0,snap:M,insKey:d,getDeps:()=>dn(D,!0),getPrevDeps:()=>dn(D,!1)},recordDep:(v,S,A)=>{let T=v.depKey;kr(v,{stopDepInfo:I,level1ArrKeys:g,recordCb:Ee=>{T=Ee}});const{renderStatus:L,fixedDepKeys:R}=D;if(L===Ot)return;const{readMap:x,insKey:vt,currentDepKeys:N,delReadMap:C}=D;Te([T],{}),jc()&&(J(N,T),b(D.fixedDepKeys,T));const ce=()=>{x[T]=1,f.recordDep(T,vt),R.includes(T)||b(N,T)};if(!x[T]&&!C[T]){const{parentKeyPath:Ee}=v;if(a&&S===tt&&Ee){const At=Ee.length?$(Ee,K):_;x[At]&&(delete x[At],C[At]=1,J(N,At))}const St=wr(S);if(St){i&&ce();return}(!A||!St&&u)&&ce()}}};if(o&&Ur(o,d),jr(D),f.mapInsCtx(D,d),f.recordId(r,d),O(c)){const v=E?D.proxyState.val:D.proxyState,S=W(c,v),A=D.getDeps().slice();S.includes(v)&&A.push(f.rootValKey),D.fixedDepKeys=A}return D}function Hr(e){const{result:t,forAtom:n}=e;e.proxyResult=le(t,{set:()=>(Ke("changing derived result is invalid"),!1),get:(r,o)=>ke===o?n:(Ce===e.renderStatus&&rn(e),t[o])})}function va(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:o,isReactive:s}=e,{sharedKey:c,sharedKeyStr:a,insSetState:u,forAtom:l}=n;r.snap=n.snap,r.time=Date.now();const i=l?t.val:t;return e.isFirstRender&&(e.rootVal=i,zt.set(e.rootVal,e)),!l&&o&&e.recordDep({depKey:a,keyPath:[],sharedKey:c},tt),[s?t:i,u,r]}function Sa(e,t){if(t&&!Re(e))throw new Error("useAtom only accept atom")}function Aa(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,jr(e))}function Ka(e){e.mountStatus=qe;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Ur(n,r),ya(e)}function Da(e){e.mountStatus=Zn;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),ca(n,r),Yr(e)}function _a(e,t){const n=Y(t).sharedKey;return e.internal.sharedKey!==n}function ft(e,t,n,r){if(G().isRootRender)try{const o=r||n;e.react.useSyncExternalStore(t,n,o)}catch(o){console.error(o)}}var Ra=null;function $r(e,t,n){const{hookImpl:r,react:o}=e,s=r.useForceUpdate(),c=o.useRef({ctx:Ra});let a=c.current.ctx;return(!a||_a(a,t))&&(a=Ea(w({updater:s,sharedState:t},n)),c.current.ctx=a),a}function Wr(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,zt.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),Ka(t),()=>{Da(t)}),[t])}function Ta(e,t,n,r){n.renderStatus=Ce,ma(n),ft(e,n.subscribe,()=>Y(t).snap),e.react.useEffect(()=>{n.renderStatus=Ot,n.isFirstRender=!1,ha(n)})}function pn(e,t,n={}){const r=$r(e,t,n);return ft(e,r.subscribe,()=>Y(t).snap),Wr(e,r),r}function lt(e,t,n={}){const{forAtom:r}=n;Sa(t,r);const o=$r(e,t,n);return Ta(e,t,o,n),Wr(e,o),Aa(o),{tuple:va(o),insCtx:o}}function Xr(e,t){const{forAtom:n,label:r,strict:o=!1}=t||{};let s;if(typeof e=="number"?s=Le(e):s=Y(e),!s&&e){const a=e[zn];s=Le(a==null?void 0:a.sharedKey)}let c=r?`[[${r}]] err:`:"err:";if(!s)if(o)ue(`${c} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!s.forAtom&&ue(`${c} expect a shared but recived a atom`,{throwErr:!0}),!n&&s.forAtom&&ue(`${c} expect a atom but recived a shared`,{throwErr:!0})),s}function ye(e,t){return Xr(e,j(w({},t||{}),{strict:!0}))}var{MUTATE:ba,LOADING:Ia}=H,{GLOGAL_LOADING:wa,PRIVATE_LOADING:Ma}=Q,{PRIVATE:Fa,GLOBAL:ka}=kt,zr={},Ca={},Oa={time:0,sn:0,getDeps:Ae,getPrevDeps:Ae,insKey:0,setDraft:F,isAtom:!1},xa=[he(zr,Ca,ba),F,Oa];function La(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:o,moduleName:s}=n,c={};Object.keys(o).forEach(l=>{c[l]={loading:!1,err:null,ok:!0}});const a=s?`${s}@Loading`:"";return e({apiCtx:r,rawState:c,isLoading:!0,stateType:Ma},{moduleName:a}).state}var Jr=null;function Pa(){return Jr}function Zr(){return G().globalLoadingInternal}function Na(e,t){const n=G();let r=n.globalLoading;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},stateType:wa},{moduleName:Hs}),s=Y(o);n.globalLoadingInternal=s,n.globalLoading=o}return Jr=r,r}function yn(e,t){let n=t;return _t(t)&&(n=t.toString()),`${e}>${n}`}function Qr(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(o=>{o[t]=n},{from:Ia}),n.err&&(ur(e,Ft.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function he(e,t,n){let r=e[n];return r||(r=le(t,{get(o,s){const c=yn(n,s);return o[c]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function He(e,t){const{internal:n,from:r}=t,{stateType:o,recordLoading:s}=n,c=Q.USER_STATE===o;let a=he(zr,{},r),u={};if(c)if(Fa===s)u=n.extra.loadingProxy,u||(u=La(e,t),n.extra.loadingProxy=u,n.loadingInternal=Y(u)),a=he(n.extra,u,r);else if(ka===s){const l=Zr();u=Pa(),n.loadingInternal=l,a=he(l.extra,u,r)}else u=an();else u=n.sharedState,a=he(n.extra,u,r);return{loadingState:a,loadingProxy:u}}function qr(e,t){if(!pe(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?j(w({},e),{internal:ye(r.__sharedKey)}):e}function eo(e,t){const{internal:n,from:r,apiCtx:o}=t,{stateType:s}=n,c=Q.USER_STATE===s;He(e,t);let a=()=>xa;return c&&(a=u=>{const l=qr(t,u),i=He(e,l).loadingProxy,{insCtx:{proxyState:f,internal:d,extra:p,renderInfo:y}}=lt(o,i);return[he(p,f,r),d.setState,y]}),{useLoading:a,getLoading:u=>{const l=qr(t,u);return He(e,l).loadingState}}}function dt(e){const t=Er();return Object.assign(t,e||{})}function me(){const e=V(),{runningFnKey:t}=e;if(!t)return[];const n=de(t);let r=[];if(n){const{depKeys:o,delPathAoa:s,runningSharedKey:c}=e,{depKeys:a}=n,u={};o.forEach(i=>u[i]=1),o.forEach(i=>{const f=Nn(u,i);f&&f!==i&&delete u[f]}),Object.keys(u).forEach(i=>b(a,i)),s.forEach(i=>{const f=i.length;for(let d=1;d<=f;d++){const p=$(i.slice(0,d),c);J(a,p)}}),r=a.slice()}return e.runningFnKey="",e.depKeys=[],e.delPathAoa=[],e.runningSharedKey=0,r}function hn(e,t){const n=V();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function to(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:o}=n,s=Rr(e,o),c=w({fn:e,fnKey:s},n),a=r?Object.assign(r,c):dt(c);return Zt(o).set(s,a),a}function mn(e){var o;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=V(),{fnKey:r}=e;on(e),e.extra.deferedWatch=null,t.delete(r),((o=n.get(r))==null?void 0:o.c)===2&&n.delete(r),ta()}function no(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=V(),{prevLevelFnKeys:n,depKeys:r}=e;let o=!1;for(const s of r){const c=t.get(s)||[];if($e(c,n)){o=!0;break}}return o}function Ua(e,t=!0,n=_e){return e.map(r=>{const[o,s]=r.split("/"),c=s.split(_e);return`${t?`${Le(Number(o)).usefulName}/`:""}${c.join(n)}`})}var pt=new Map,yt={WATCH:"1",MUTATE:"2"},Ba={[yt.WATCH]:"watch",[yt.MUTATE]:"mutate fn or task"};function Va(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function ro(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function Ya(e){pt.delete(e)}function Ga(e,t,n,r){const o=Ba[r],{desc:s,task:c,fn:a,isFake:u}=t.subFnInfo,l=s?`(${s})`:"",i=`DEAD_CYCLE: found reactive object in ${o}${l} cb is changing module(${e.usefulName})'s some of these dep keys(${Ua(n,!1,".")}), it will cause a infinity loop call!`,f=u?t.fn:c||a;return{err:new Error(`[only-dev-mode alert] ${i}`),tipFn:()=>console.error(` ${i} open the stack to find the below fn: 
`,f)}}function ja(e,t,n){if(e&&n){const{usefulName:r}=e,o=Fe(pt,r,Va(t));o.sn!==t&&(o.descs=[],o.errs=[]);const{descs:s}=o;if(s.length>1&&s[0]===n){const c=s.slice();throw o.cycle=c,s.length=0,ro(r,c,n)}b(s,n)}}function gn(e,t){t.tipFn(),ue(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function ge(e,t,n){const{depKeys:r,subFnInfo:o}=t;let s=t.depKeys,c=n;r.length>n.length&&(s=n,c=r);let a=!1;if($e(s,c)){const u=o.desc?yt.MUTATE:yt.WATCH,l=Ga(e,t,n,u);gn(e,l),t.dcErrorInfo=l,a=!0}return a}function Ha(e,t){const n=pt.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function $a(e,t,n=!0){const r=pt.get(e);if(!r)return;const{timer:o,errs:s}=r;s.push(t),o&&clearTimeout(o),r.timer=setTimeout(()=>{let c=null;for(const a of s)c?a.data.length>c.data.length&&(c=a):c=a;c&&ue(c,{alertErr:n}),s.length=0},0)}function En(e,t=0){const n=de(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:Wa}=et;function Xa(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:o=0,from:s,internal:c=Ar,desc:a,fromFnKey:u}=t;if(e.dcErrorInfo.err){gn(c,e.dcErrorInfo);return}if(e.fnKey===u){ge(c,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:o});if(H.MUTATE===s&&ja(c,o,a),e.isRunning&&ge(c,e,t.depKeys||[]))return;const l=oe.current();if(l.fnKey===e.fnKey&&ge(c,e,l.writeKeys)||(je(l.sharedKey,l.desc),e.isRunning===!0&&l.isTop&&ge(c,e,l.writeKeys)))return;e.isRunning=!0,Ne.set(e.fnKey);const f=e.fn({isFirstCall:n,triggerReasons:r,sn:o});Ne.del();const d=oe.current();if(!(d.isTop&&d.fnKey===e.fnKey&&ge(c,e,d.writeKeys))&&!(f&&f.task&&d.from===H.MUTATE&&ge(c,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,f}function oo(e,t,n){let r=t.val;return n||(r=t),{input:W(e,{state:r,stateRoot:t,isAtom:n}),state:r,stateRoot:t}}function be(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:o=!1,throwErr:s=!1,triggerReasons:c=[],watchFnKeys:a=[],skipWatch:u=!1,sn:l=0,err:i,unbox:f=!1,internal:d=Ar}=t,p=de(e),y=(N=null)=>{if(N&&s)throw N;const C=p||Kr;return f?[C.result.val,N]:[C.result,N]};if(!p)return y(new Error(`not a valid watch or derive cb for key ${e}`));if(p.fnType===qn)return u?b(a,p.fnKey):Xa(p,t);const{isAsync:m,fn:h,task:g,isAsyncTransfer:E,forAtom:K,result:_,depKeys:M}=p;p.remainRunCount>0&&(p.remainRunCount-=1);const I=N=>{const C=K?{val:N}:N;!p.returnUpstreamResult&&C&&Object.assign(p.result,C),p.shouldReplaceResult=!0},D=()=>{p.renderInfo.sn=l,p.updater()},k=N=>{const{data:C,err:ce=null}=N;ce?p.setLoading(!1,ce):(I(C),n?m&&p.status.loading&&!no(p)&&p.setLoading(!1,ce):p.remainRunCount===0&&p.setLoading(!1,ce)),D();const Ee={isFirstCall:n,sn:l,triggerReasons:c,err:ce,watchFnKeys:a,skipWatch:u};p.nextLevelFnKeys.forEach(St=>{be(St,Ee)})},v=K?_:_.val,{deps:S,isStateAtom:A}=p,{input:T,state:L,stateRoot:R}=oo(S,p.stateRoot,A),x={isAtom:p.isStateAtom,state:L,stateRoot:R,isFirstCall:n,prevResult:v,triggerReasons:c,input:T,sn:l};if(!m||r||m&&!g){const N=h(x);return k({data:N}),y()}if(m&&n&&p.nextLevelFnKeys.forEach(N=>En(N,0)),E)return k({err:i}),y();if(p.asyncType===Wa){const N=h(x);return k({data:N}),y()}if(g){let N=Ks;return n?(M.forEach(C=>Bc(C,e)),N=()=>M.forEach(C=>Vc(C,e))):o&&p.nextLevelFnKeys.forEach(C=>En(C)),Promise.resolve(()=>{const C=g(x);return Rt(C)?C:(ue("ERR_NON_FN: derive task arg should be async function!",{throwErr:s}),null)}).then(C=>C()).then(C=>(N(),k({data:C}),y())).catch(C=>{if(N(),k({err:C}),s)throw C;return ir(d,C),y(C)})}return y(i)}function ht(e,t){const n=Ve(e);if(!n)throw new Error("[Helux]: not a derived result");return be(n.fnKey,w({},t||{}))}function za(e,t){return ht(e,{forceFn:!0,throwErr:t})}function Ja(e,t){return Promise.resolve(ht(e,{forceTask:!0,throwErr:t}))}function Za(e,t){return ht(e,{forceFn:!0,throwErr:t,unbox:!0})}function Qa(e,t){return Promise.resolve(ht(e,{forceTask:!0,throwErr:t,unbox:!0}))}function qa(e){const t=Ve(e);return t?t.status:{loading:!1,err:null,ok:!0}}function vn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,ga(r))}function eu(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:o,depKeys:s,triggerReasons:c,isFirstCall:a,from:u,sn:l,desc:i,fnKey:f}=t,{key2InsKeys:d,id2InsKeys:p,insCtxMap:y,rootValKey:m}=n;let h=[],g=[],E=[],K=[];const _={};if(a){const S=me();Be.set(S)}const M=(S,A=!1)=>{const{firstLevelFnKeys:T,asyncFnKeys:L}=ea(n,S,_,A);E=E.concat(T),K=K.concat(L)},I=S=>{if(!ut(n,S))return;const A=d[S]||[],T=[];for(const L of A){if(h.includes(L))continue;const R=y.get(L);if(!R)continue;const x=R.getDeps();if(x[0]===m){ut(n,m)&&T.push(L);continue}Cr(n,x,S)&&T.push(L)}h=h.concat(T),M(S)};s.forEach(S=>I(S)),s.includes(m)||I(m),M(m,!0),qc(),r.forEach(S=>{h=h.concat(p[S]||[])}),o.forEach(S=>{un(S).forEach(A=>b(g,A))}),h=ve(h),E=ve(E),K=ve(K),K.forEach(S=>En(S,_[S]));const D=[],k={depKeys:s,sn:l,from:u,triggerReasons:c,watchFnKeys:D,skipWatch:!0,internal:n,desc:i,isFirstCall:a,fromFnKey:f};E.forEach(S=>be(S,k));const v={depKeys:s,sn:l,from:u,triggerReasons:c,internal:n,desc:i,isFirstCall:a,fromFnKey:f};if(D.forEach(S=>be(S,v)),h.forEach(S=>vn(y,S,l)),g.length){const S=sa().insCtxMap;g.forEach(A=>vn(S,A,l))}}function tu(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:o,isDeep:s,ver:c,snap:a}=n;s?(n.prevSnap=c===0?w({},a):a,n.snap=t,Object.assign(o,t)):n.snap=w({},o),n.ver+=1,n.sn=r.sn,eu(e)}var{MUTATE:so}=H;function co(e,t){const{writeKey:n,ids:r,internal:o,opParams:s}=t,{snap:c}=o,{fullKeyPath:a,value:u}=s;Object.keys(e).forEach(l=>{n.startsWith(l)&&ie(c,a)!==u&&e[l].forEach(i=>b(r,i))})}function ao(e,t){var L;const{isChanged:n,fullKeyPath:r,keyPath:o,parentType:s,value:c}=e,{internal:a,mutateCtx:u}=t,{arrKeyDict:l,isReactive:i,readKeys:f,from:d}=u,{sharedKey:p}=a,y=wr(s),m=oe.current();if(e.op==="get"){y&&(l[$(o,p)]=1);const R=$(r,p);f[R]=1,u.enableDep&&(m.onRead?m.onRead(e):(Ye().fnCtx&&Te([R],{sharedKey:p}),i&&(tn([R]),sn(p,c,a.sharedState,R,r)),(L=a.onRead)==null||L.call(a,e)));return}if(so===d){const{delPathAoa:R,fnCtx:x}=Ye();x&&R.push(o)}if(!n)return;const{moduleName:h,ruleConf:g,level1ArrKeys:E}=a,{writeKeyPathInfo:K,ids:_,globalIds:M,writeKeys:I}=u,D=$(r,p);if(m.key&&(m.isTop?b(m.writeKeys,D):m.from===so&&b(Qt(m.fnKey).subFnInfo.writeKeys||[],D)),y){const R=$(o,p);K[R]={sharedKey:p,moduleName:h,keyPath:o},I[R]=1}const{hasIds:k,hasGlobalIds:v,stopDepInfo:S}=g;K[D]={sharedKey:p,moduleName:h,keyPath:r};const A=Nn(l,D);A&&(I[A]=1),kr({sharedKey:p,keyPath:r,depKey:D},{stopDepInfo:S,level1ArrKeys:E,recordCb:R=>{I[R]=1}})||(I[D]=1),k&&co(g.idsDict,{ids:_,writeKey:D,internal:a,opParams:e}),v&&co(g.globalIdsDict,{ids:M,writeKey:D,internal:a,opParams:e}),i?da(p,m.desc):la(p)}function uo(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function mt(e,t){if(!t)return e;nn(!0);const n=e.val;return nn(!1),n}function io(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:o}=e;if(!t)return;if(!n){pe(t)&&uo(o,t);return}const s=t.val;if(pe(o)){pe(s)?uo(o,s):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=s}function nu(e,t){const{internal:n,mutateCtx:r}=e,o=mt(t,n.forAtom),{from:s,sn:c,desc:a}=r;n.before({from:s,draftRoot:t,draft:o,desc:a,sn:c}),uc(n,t,o,c)}function fo(e,t,n,r){const{mutateCtx:o,internal:s}=e,{writeKeys:c,writeKeyPathInfo:a,handleCbReturn:u}=o,{forAtom:l}=s;u&&io({partial:r,forAtom:l,draftRoot:t,draftNode:n}),nu(e,t),o.depKeys=Object.keys(c),ct.del(),Jt.del(),e.state=(0,X._x)(t),e.state!==s.rawState&&(o.triggerReasons=Object.values(a),tu(e),dc(s,o))}function lo(e,t){const{ids:n,globalIds:r,from:o,desc:s,fnKey:c}=t;n&&n.forEach(a=>b(e.ids,a)),r&&r.forEach(a=>b(e.globalIds,a)),o&&(e.from=o),s&&(e.desc=s),c&&(e.fnKey=c)}function ru(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:o}=t,s=Ut(n),c=(0,X.P2)(o,{customKeys:Je,onOperate:u=>{if(u.isCustom)return cn(u,r,t.sharedKey);ao(u,{internal:t,mutateCtx:s})}});ct.set(c,r),Jt.set(s);const a=mt(c,r);return r&&(s.readKeys={}),{draftRoot:c,draftNode:a,finishMutate(u,l={}){lo(s,l),fo({state:{},mutateCtx:s,internal:t},c,a,u)}}}function ou(e){return fr(e),Dc(e)}function su(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function cu(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=O(n);let o=!1;if(t)n=r?{val:n()}:{val:n},o=!n.val||!Pn(n.val);else{if(n=r?n():n,!z(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(re(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:o,rawState:n}}function po(e,t,n){let r=null,o=t||"";if(O(e)&&e!==F)r={[Xn]:1,fn:e,deps:Ae,oriDesc:o,onlyDeps:!1,desc:o,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}};else if(z(e)){const{fn:s,desc:c,deps:a,task:u,immediate:l,checkDeadCycle:i,onlyDeps:f=!1}=e,d=t||c||"",p=O(s)?s:void 0,y=O(u)?u:void 0,m=O(a)?a:Ae;(s||u)&&(r={[Xn]:1,checkDeadCycle:i,fn:p,watchKey:"",desc:d,oriDesc:d,deps:m,task:y,onlyDeps:f,immediate:l,depKeys:[],writeKeys:[],isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}})}if(r&&n){const{oriDesc:s}=r;(!s||n[s])&&(r.desc=Nt(H.MUTATE))}return r}function yo(e,t,n=!0){const r={},o=t||{};if(!e)return r;const s=(c,a)=>{const u=po(c,a,o);u&&(u.enabled=n,r[u.desc]=u,o[u.desc]=u)};if(Array.isArray(e))if(e.length===1){const c=e[0],a=(z(c)?c.desc:"")||Ze;s(e[0],a)}else e.forEach(c=>s(c));else O(e)?s(e,Ze):z(e)&&Object.keys(e).forEach(c=>{s(e[c],c)});return r}function au(e,t={}){var v,S,A,T,L;const{forAtom:n=!1,forGlobal:r=!1,stateType:o=Q.USER_STATE}=e,{rawState:s,isPrimitive:c}=cu(e),a=ou(s),u=t.moduleName||"",l=(v=t.alertDeadCycleErr)!=null?v:ae(),i=(S=t.deep)!=null?S:!0,f=(A=t.checkDeadCycle)!=null?A:!0,d=(T=t.enableMutate)!=null?T:!0,p=t.recordLoading||kt.PRIVATE,y=t.rules||[],m=t.before||F,h=t.mutate||F,g=t.onRead||void 0,E=(L=t.stopArrDep)!=null?L:!0,K=t.stopDepth||$s,_=`${a}`,M=n?`${a}/val`:_,I=u||_,D=$c(u),k=yo(h,{},d);return{isDestroyed:!1,alertDeadCycleErr:l,checkDeadCycle:f,rawState:s,sharedKey:a,sharedKeyStr:_,rootValKey:M,moduleName:u,usefulName:I,forAtom:n,forGlobal:r,loc:D,deep:i,rules:y,before:m,mutate:h,mutateFnDict:k,onRead:g,enableMutate:d,stateType:o,recordLoading:p,stopArrDep:E,stopDepth:K,isPrimitive:c}}function uu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:o,rules:s,stopDepth:c,stopArrDep:a,forAtom:u}=e,l={},i={},f={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:c,stopArrDep:a},d={},p=bt(o);s.forEach(h=>{const g=[],{when:E,ids:K=[],globalIds:_=[],stopDep:M}=h;let I;if(p){let A="";I=(0,X.OA)(t,{onOperate:({fullKeyPath:T,value:L,isBuiltInFnKey:R})=>{if(R)return;const x=$(T,n);A&&x.includes(A)&&g.pop(),g.push(x),d[x]=Array.isArray(L),A=x}})}else I=le(t,{set:ws,get:(A,T)=>{const L=$([T],n);g.push(L);const R=A[T];return d[L]=Array.isArray(R),R}});const D=u?I.val:I,k=W(E,D),v=(A,T,L)=>{const R=Me(A,L,[]);T.forEach(x=>b(R,x))},S=A=>{v(l,K,A),v(i,_,A);let T;d[A]?(T=M!=null?M:Ws,f.arrKeyStopDcit[A]=T,f.isArrDict[A]=d[A]):T=M!=null?M:!1,T&&b(f.keys,A)};g.forEach(S),k.includes(D)&&S(r)});const y=Object.keys(l).length>0,m=Object.keys(i).length>0;return{hasIds:y,idsDict:l,hasGlobalIds:m,globalIdsDict:i,stopDepInfo:f}}function iu(e){const{desc:t=Ze,strict:n=!1,throwErr:r=!1,extraArgs:o}={};return typeof e=="string"?{desc:e,strict:n,throwErr:r,extraArgs:o}:w({desc:t,strict:n,throwErr:r,extraArgs:o},e)}function ho(e,t){var o;let n=F,r=!1;return O(t)?n=t:z(t)&&(n=t.deps||F,r=(o=t.immediate)!=null?o:!1),r=e?!0:r,{immediate:r,deps:n}}function fu(e){return e?typeof e=="boolean"?{enableStatus:e}:z(e)?e:{}:{}}function lu(e){Array.isArray(e)&&e.forEach(t=>{const n=zt.current(t),r=Y(t)||(n==null?void 0:n.internal);if(r){const{depKey:o,sharedKey:s}=Ir(r);Te([o],{sharedKey:s})}n&&n.recordDep(Ir(r))})}function mo(e,t,n){const{deps:r,immediate:o}=ho(e,n),s=gt(t,{scopeType:te.STATIC,deps:r,immediate:o});return{run:c=>be(s.fnKey,{throwErr:c}),unwatch:()=>on(s)}}function gt(e,t){const{scopeType:n,fnCtxBase:r,immediate:o,deps:s=F,label:c="watch",sharedState:a,isSimpleWatch:u}=t;if(!O(e))throw new Error(`ERR_NON_FN: pass an non-function to ${c}!`);const l=to(e,{specificProps:{scopeType:n,fnType:qn,isSimpleWatch:u},fnCtxBase:r});hn(l.fnKey,re(a));const i=s()||[];return lu(i),o&&e({isFirstCall:!0}),me(),l}function du(e,t){return mo(!1,e,t)}function pu(e,t){return mo(!0,e,t)}var go=()=>{},Sn=new Map;function Eo(e,t){const{forAtom:n,rawState:r}=e,{deps:o,extraBound:s}=t;return n?W(o,r.val,s):W(o,r,s)}function yu(e){var t;return(t=Sn.get(e))!=null?t:!1}function An(e,t){const{sn:n,getArgs:r=F,from:o,throwErr:s,isFirstCall:c,fnItem:a,mergeReturn:u,extraArgs:l}=t,{desc:i="",depKeys:f,task:d=go,extraBound:p}=a,y=Y(e),{sharedKey:m}=y,h={desc:i,sn:n,from:o},g=yn(o,i),{draft:E,draftRoot:K}=ln(y,{depKeys:f,desc:i,from:o}),_=R=>{je(m,R)},M=R=>{_(i);const{finish:x}=y.setStateFactory(h);return x(R)},I=H.MUTATE===o?Eo(y,a):[],D={isFirstCall:c,desc:i,setState:M,input:I,draft:E,draftRoot:K,flush:_,extraBound:p,extraArgs:l},k=r(D)||[D],v=Sn.get(d),S=v===void 0,A=(R,x,vt)=>{(S||v)&&Qr(y,g,{loading:R,err:x,ok:vt})};A(!0,null,!1);const T=R=>{if(Be.del(),A(!1,R,!1),s)throw R;return{snap:y.snap,err:R,result:null}},L=R=>(u&&R&&M(R),A(!1,null,!0),_(i),{snap:y.snap,err:null,result:R});try{const R=d(...k),x=Rt(R);return Sn.set(d,x),x?Promise.resolve(R).then(L).catch(T):L(R)}catch(R){return T(R)}}function vo(e,t){const{sn:n,getArgs:r=F,from:o,throwErr:s,isFirstCall:c=!1,fnItem:a,extraArgs:u}=t,{desc:l="",watchKey:i,fn:f=go,extraBound:d}=a,p=H.MUTATE===o;p&&Ne.set(i);const y=Y(e),{setStateFactory:m,forAtom:h,sharedRoot:g}=y,K={desc:l,sn:n,from:o,isFirstCall:c,enableDep:p&&c},_=A=>{const{finish:T}=m(K);return T(A)},M=mt(g,h),I=p?Eo(y,a):[],{draftNode:D,draftRoot:k,finish:v}=m(K),S=r({draft:D,draftRoot:k,setState:_,desc:l,input:I,extraArgs:u})||[D,{input:I,state:M,draftRoot:k,isFirstCall:c,extraBound:d,extraArgs:u}];try{const A=Qt(a.watchKey);if(A.dcErrorInfo.err)return gn(y,A.dcErrorInfo),{snap:y.snap,err:null,result:null};const T=f(...S);return v(T,{fnKey:A.fnKey}),So(y,a,c),{snap:y.snap,err:null,result:null}}catch(A){if(So(y,a,c),s)throw A;return{snap:y.snap,err:A,result:null}}}function So(e,t,n){n&&!t.onlyDeps&&(Ye().fnCtx?t.depKeys=me():t.depKeys=Be.current(),Be.del());const r=oe.current();r.isTop&&r.fnKey===t.watchKey&&ge(e,Qt(t.watchKey),r.writeKeys),Ne.del()}function hu(e,t){var r;fa(),Be.del(),nn(!1);const n=Ye().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=me())}function Kn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const o=Y(t),{mutateFnDict:s,usefulName:c,forAtom:a,sharedRoot:u}=o,l=i=>ir(o,i);r.forEach(i=>{const f=s[i];gt(({sn:d,isFirstCall:p})=>{if(p&&hu(o,f),!o.enableMutate)return;const{desc:y,fn:m,task:h,immediate:g}=f,E=Ha(c,y);try{if(E.isIn)throw ro(c,E.cycle,y);const K={sn:d,throwErr:!0,isFirstCall:p,fnItem:f,from:H.MUTATE};if(m&&(p||!h)&&vo(t,K),h){p&&(f.depKeys=me());const _=p&&(g!=null?g:!m);(!p||_)&&An(t,K).catch(l)}return f}catch(K){K.cause==="DeadCycle"&&$a(c,K,o.alertDeadCycleErr),l(K)}},{deps:()=>f.deps?f.deps(mt(u,a),f.extraBound)||[]:[],sharedState:t,scopeType:te.STATIC,immediate:!0})})}var{ACTION:Ao}=H;function mu(e,t){const{label:n,throwErr:r,desc:o="",task:s,mergeReturn:c=!0}=t,a=qt(r,!1),u=ye(e,{label:n}),{forAtom:l}=u,i=(f,d)=>{const p=qt(d,a),y=Bt({desc:o,task:s,depKeys:[]}),m=(h,g)=>h.__action?h.__action(g):h(g);return An(e,{fnItem:y,from:Ao,mergeReturn:c,throwErr:p,getArgs:({draft:h,draftRoot:g,setState:E,desc:K,flush:_})=>[{draft:h,draftRoot:g,setState:E,desc:K,payload:f,flush:_,merge:I=>{io({partial:I,forAtom:l,draftRoot:g,draftNode:h})},dispatch:m}]})};return Qr(u,yn(Ao,o),{loading:!1,ok:!0,err:null}),i.__sharedKey=u.sharedKey,i.__fnName=o,i.__task=s,s.__action=i,i}function Ko(e){return t=>(n,r="",o)=>mu(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:o})}var{TASK:Do}=et,{STATIC:gu,HOOK:Eu}=te;function _o(e,t,n){if(!n&&(!z(t)||Rt(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:o}=e;if(r&&!o){const s=Tr(t),c=re(t);if(s&&e.fnKey!==s||c)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function vu(e,t){const n=le(e.result,{set:()=>(Ke("changing derived result is invalid"),!1),get:(r,o)=>{if(o===ke)return t;const s=r[o];return Te(e.depKeys,{belongCtx:e}),tn(e.depKeys,n),sn(0,s,n,"",[o],!0,t),s}});return e.proxyResult=n,n}function Ro(e,t){const{result:n,isUpstream:r}=t,o=Ve(n);o&&(e.depKeys=ve(e.depKeys.concat(o.depKeys)),b(o.nextLevelFnKeys,e.fnKey),b(e.prevLevelFnKeys,o.fnKey),e.isFirstLevel=!1,r==null||r())}function Su(e){var k,v;const{scopeType:t=gu,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:o=Do,returnUpstreamResult:s,runAsync:c=!0,forAtom:a=!1,immediate:u}=e;if(!O(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:l=F,deps:i=F,task:f,stateRoot:d={}}=e,p=Re(d),y=(k=e.isAsync)!=null?k:O(f),m=(v=e.showLoading)!=null?v:y,h=to(l,{specificProps:{forAtom:a,scopeType:t,stateRoot:d,isStateAtom:p,fnType:Qn,task:f,deps:i,isAsync:y,asyncType:o,isAsyncTransfer:r,showLoading:m},fnCtxBase:n});hn(h.fnKey,0);const{input:g,state:E}=oo(i,d,p);g.forEach(S=>Ro(h,{result:S}));let _=l({isFirstCall:!0,prevResult:null,triggerReasons:[],input:g,sn:0,state:E,stateRoot:d,isAtom:p});me();const M=Ve(_);a&&!M&&(_={val:_,z__is_atom_result__:!0});const I=h.fnKey;_o(h,_),Ro(h,{result:_,isUpstream:()=>{h.returnUpstreamResult=s!=null?s:!y}}),rn(h),h.returnUpstreamResult||Rr(_,t,I);const D=c&&o===Do&&(u!=null?u:!e.fn);return f&&D&&be(I,{isFirstCall:!0,sn:h.renderInfo.sn+1}).then(S=>{_o(h,S[0],a)}).catch(S=>ue(S)),h.result=_,t===Eu&&no(h)&&h.setLoading(!0),h.returnUpstreamResult?h.proxyResult=_:vu(h,a),h}function Dn(e,t){const n=O(e)?{fn:e}:e||{};return Su(w(w({},t||{}),n))}function To(e,t){return Dn(e,{forAtom:!0,stateRoot:t}).proxyResult}function Au(e,t){return Dn(e,{stateRoot:t}).proxyResult}function Ku(e){return t=>j(w({},t),{deps:e})}function Du(e){return e}var Et=e=>[e.snap,e.err];function _n(e){const{target:t,desc:n="",forTask:r=!1,throwErr:o,extraArgs:s}=e,{mutateFnDict:c,snap:a}=Y(t),u=n||Ze,l=c[u];if(!l)return{snap:a,err:new Error(`mutate fn ${u} not defined`),result:null};if(r&&!l.task)return{snap:a,err:new Error(`mutate task ${u} not defined`),result:null};const i=qt(o,!1),f={sn:0,fnItem:l,from:H.MUTATE,throwErr:i,extraArgs:s};return r?An(t,f):vo(t,f)}function bo(e,t,n,r){return{run:o=>{const s=_n({target:e,desc:t,throwErr:o});return Et(s)},runTask:o=>Promise.resolve(_n({target:e,desc:t,forTask:!0,throwErr:o})).then(Et),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function _u(e){const{target:t,fnItem:n,label:r,extraTarget:o}=e,s=ye(t,{label:r}),c=po(n,"",s.mutateFnDict);if(!c)throw new Error("not a fn or fnItem { fn }");o&&(c.extraBound=Pt(o)),s.mutateFnDict[c.desc]=c,c.enabled=s.enableMutate;const a={[c.desc]:c};return s.enableMutate&&Kn({target:t,dict:a}),bo(t,c.desc,c.oriDesc,s)}function Ru(e){const{target:t,fnDict:n,label:r}=e,o=ye(t,{label:r}),s=yo(n,o.mutateFnDict,o.enableMutate);if(e.extraTarget){const a=Pt(e.extraTarget);Object.keys(s).forEach(u=>s[u].extraBound=a)}o.enableMutate&&Kn({target:t,dict:s});const c={};return Object.keys(s).forEach(a=>{c[a]=bo(t,a,a,o)}),c}function Tu(e,t){const{label:n,descOrOptions:r,forTask:o=!1}=t,{desc:s,strict:c,throwErr:a,extraArgs:u}=iu(r);return s?Xr(e,{label:n,strict:c})?{ok:!0,desc:s,forTask:o,throwErr:a,extraArgs:u,err:null}:{ok:!1,desc:s,forTask:o,throwErr:a,extraArgs:u,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("miss desc")}}function Io(e,t){const{ok:n,desc:r,forTask:o,err:s,throwErr:c,extraArgs:a}=Tu(e,t);if(!n){if(c)throw s;return o?Promise.resolve([e,s]):[e,s]}const u=_n({target:e,desc:r,forTask:o,throwErr:c,extraArgs:a});return o?Promise.resolve(u).then(Et):Et(u)}function wo(e,t){return Io(e,{descOrOptions:t,label:"runMutate"})}function Mo(e,t){return Io(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function Fo(e,t){return n=>_u({target:e,extraTarget:t,fnItem:n,label:"mutate"})}function Rn(e,t){return n=>Ru({target:e,extraTarget:t,fnDict:n,label:"mutateDict"})}function bu(e){return e}function ko(e,t,n={}){const{tuple:r}=lt(e,t,n);return r}function Co(e,t,n={}){const{tuple:r}=lt(e,t,n),[o,s,c]=r;return j(w({},c),{state:o,setState:s})}var Iu="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",wu="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function Mu(e,t,n){return e.isExpired?(e.isExpired=!1,!0):O(n)?!1:n!==t}function Fu(e){mn(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function ku(e,t){const{result:n,forAtom:r,showLoading:o}=t,{fnCtx:s,input:c,deriveFn:a}=e;let u=!1;if(a)if(Mu(s,c,n))u=!0,Fu(s);else return;e.input=n;const l=Ve(n);if(!l)throw new Error(Iu);if(r&&!fe(n))throw new Error(wu);e.deriveFn=()=>l.result,Dn({fn:()=>l.result,deps:()=>[],task:()=>As(this,null,function*(){return l.result})},{isAsync:l.isAsync,scopeType:te.HOOK,fnCtxBase:s,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:et.MAY_TRANSFER,showLoading:o}),Hr(s),u&&s.updater()}function Oo(e,t){const{result:n,forAtom:r}=t,{hookImpl:o,react:s}=e,c=o.useForceUpdate(),{current:a}=s.useRef({input:n,deriveFn:null,fnCtx:null});a.fnCtx||(a.fnCtx=dt({updater:c,scopeType:te.HOOK,forAtom:r}));const u=a.fnCtx;return u.renderStatus=Ce,ku(a,t),u}function Cu(e,t){t.shouldReplaceResult&&(Hr(t),t.shouldReplaceResult=!1),ft(e,t.subscribe,()=>xr(t)),e.react.useEffect(()=>{t.renderStatus=Ot})}function xo(e,t){e.react.useEffect(()=>(t.mountStatus=qe,Or(t),()=>{mn(t)}),[t])}function Tn(e,t){const n=Oo(e,t);return ft(e,n.subscribe,()=>xr(n)),xo(e,n),n}function Ou(e,t){const n=Oo(e,t);return Cu(e,n),xo(e,n),n}function bn(e,t,n){const r=Ou(e,w({result:t},n||{})),{proxyResult:o,status:s,renderInfo:c}=r;return[fe(t)?o.val:o,s,c]}function Lo(e,t,n){if(t===null)return n;if(!O(t))return null;const{sharedState:r,forAtom:o}=e,s=o?r.val:r,c={};Xt.set(u=>c[u[0]]=1);const a=W(t,s);return Xt.del(),a.includes(s)?e.key2InsKeys:c}function Po(e,t,n){const r=ye(t),[o]=e.react.useState(()=>Lo(r,n,null));return s=>{const{insCtxMap:c,key2InsKeys:a}=r,u=Lo(r,s,a)||o||a,l={};if(Object.keys(u).forEach(f=>{(a[f]||[]).forEach(p=>l[p]=1)}),Object.keys(l).length){r.sn+=1;const f=r.sn;Object.keys(l).forEach(d=>{vn(c,Number(d),f)})}}}function xu(e,t){Fn(e);const n=an();return pn(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:No,MUTATE:Uo}=H;function In(e,t){Fn(e);const{target:n,from:r="Mutate"}=t||{};let o=Zr();n&&(o=ye(n));const{loadingProxy:s,loadingState:c}=He(se,{apiCtx:e,internal:o,from:r});return{loadingProxy:s,loadingState:c,internal:o,from:r}}function Bo(e,t){const{loadingProxy:n,internal:r,from:o}=In(e,t),{proxyState:s,extra:c,renderInfo:a}=pn(e,n);return[he(c,s,o),r.setState,a]}function Lu(e,t){const{loadingProxy:n}=In(e,{target:t,from:Uo});return n}function Pu(e,t){return Bo(e,{target:t,from:Uo})}function Nu(e,t){const{loadingProxy:n}=In(e,{target:t,from:No});return n}function Uu(e,t){return Bo(e,{target:t,from:No})}function Vo(e){return e.hookImpl.useForceUpdate()}function Yo(e,t){const n=(r,o)=>{let s=null;if(O(r)){const c=(0,X.P2)(o),a=r(c);s=(0,X._x)(c),z(a)&&Object.assign(s,a)}else z(r)&&(s=w(w({},o),r));return s};return e.hookImpl.useObjectLogic(t,n,!0)}function Bu(e,t,n){const{useRef:r,useMemo:o,useEffect:s}=e.react,c=r({fn:n,wrap:null});c.current.fn=o(()=>n,[n]),c.current.wrap||(c.current.wrap=(...a)=>{c.current.fn(...a)}),s(()=>{const a=yc(),u=c.current.wrap;return a.on(t,u),()=>a.off(t,u)},[t,c])}function wn(e,t,n={}){const r=Re(t),{insCtx:o}=lt(e,t,j(w({},n),{forAtom:r,isReactive:!0}));return[o.proxyStateVal,o.proxyState,o.renderInfo]}function Go(e,t,n={}){const[r,o,s]=wn(e,t,n);return j(w({},s),{state:r,stateRoot:o})}function Vu(e,t,n){const r=z(n)?n:{};e.react.useEffect(()=>{const{srvRef:o}=r;O(o)&&o(t)},[])}function Yu(e,t,n){const r=e.hookImpl.useStable(t);return Vu(e,r,n),r}function Gu(e){return t=>e.current=t}var{HOOK:jo}=te;function Ho(e,t){e(()=>{var n,r;return t.mountStatus=qe,Or(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{mn(t)}},[t])}function $o(e,t){const{useRef:n,useState:r,useMemo:o,useEffect:s}=e.react,{label:c,forEffect:a,watchFn:u,watchOptions:l}=t,i=n({fn:u,wrap:null,fnKey:"",isDeferMarked:!1}),[f]=r(()=>dt());if(i.current.fn=o(()=>u,[u]),!i.current.wrap){const{deps:d,immediate:p}=ho(a,l);i.current.wrap=m=>{if(f.mountStatus===qe){i.current.fn(m);return}f.extra.deferedWatch=()=>{if(i.current.isDeferMarked){i.current.fn(m);return}i.current.isDeferMarked=!0,hn(i.current.fnKey,0),i.current.fn(m),me()}};const{fnKey:y}=gt(i.current.wrap,{scopeType:jo,fnCtxBase:f,deps:d,immediate:p,label:c});i.current.fnKey=y}Ho(s,f)}function ju(e,t,n){const{useState:r,useEffect:o}=e.react,[s]=r(()=>dt());if(s.fn===F){const{manualDepKeys:c=[]}=n;gt(t,{scopeType:jo,fnCtxBase:s,deps:()=>c.map(u=>{const{sharedKey:l,keyPath:i}=br(u),f=Rc(l);return ie(f,i)}),isSimpleWatch:!0})}Ho(o,s)}function Hu(e,t,n){$o(e,{label:"useWatch",forEffect:!1,watchFn:t,watchOptions:n})}function $u(e,t,n){$o(e,{label:"useWatchEffect",forEffect:!0,watchFn:t,watchOptions:n})}function Wu(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:o,stopDepth:s,sharedKey:c}=t,a=Ut(n),u=w({},r),l=(p,y,m,h)=>{const g=Pe(y,m,{parentType:Mr(p),parentKeyPath:h});ao(g,{internal:t,mutateCtx:a}),Bn(u,g.fullKeyPath,m)},i=(p,y,m)=>Oe(p,{set:(h,g,E)=>(l(h,g,E,m),!0),get:(h,g)=>{const E=h[g];if(Je.includes(g))return it(y===1,o,c,g,E);const K=Pe(g,E,{isChanged:!1,parentKeyPath:m,op:"get",parentType:Mr(h)});return y<s&&pe(E)?i(E,y+1,K.fullKeyPath):ie(u,K.fullKeyPath)}}),f=i(u,1,[]);ct.set(f,o),Jt.set(a);const d=o?f.val:f;return{draftRoot:f,draftNode:d,finishMutate(p,y={}){lo(a,y);const m=w({state:{},mutateCtx:a},e);fo(m,f,d,p)}}}function Xu(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function zu(e){let t=[];return{target:Xc(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function Wo(e,t,n){return o=>{let s=Xu(o);e(c=>{const{isAtom:a,draftRoot:u}=ct.current(),l={draft:c,draftRoot:u,path:t,isAtom:a,UNDEFINED:js},i=n==null?void 0:n(s,l);Bn(u,t,i!==void 0?i:s)},{from:H.SYNC})}}function Mn(e,t){const{sharedKey:n,innerSetState:r}=t;let o=$(e,n),s=Xo.get(o);return s||(s=Wo(r,e),Xo.set(o,s)),s}var Xo=new Map;function zo(e){const{forAtom:t,rawState:n}=e;return t?Pn(n.val)?Oe(n.val,{get:(r,o)=>Mn(["val",o],e)}):Mn(["val"],e):Oe(n,{get:(r,o)=>Mn([o],e)})}var Jo=new Map;function Zo(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:o}=e,s=zu(o);return(c,a)=>{let u=[];if(Array.isArray(c))u=t?["val",...c]:c;else{const{target:f,getPath:d}=s;c(t?f.val:f),u=d()}let l=$(u,n);a&&(l+=`${a.toString()}`);let i=Jo.get(l);return i||(i=Wo(r,u,a),Jo.set(l,i)),i}}function Ju(e,t,n){const{deep:r,forAtom:o,sharedKey:s}=n,c=uu(n),a=bt(r),u=(g={})=>{const E={internal:h,setFactoryOpts:g},{finishMutate:K,draftRoot:_,draftNode:M}=a?ru(E):Wu(E);return{finish:(I,D={})=>{const k=h.snap;if(I===k)return k;const v=Jc(o,I,M);return K(v,D),h.snap},draftRoot:_,draftNode:M}},l=(g={})=>u(g),i=(g,E={})=>u().finish(g,E),f=(g,E)=>{const[K,_,M]=E;return fn(e,Ue.current(s)),u({handleCbReturn:K,enableDep:_}).finish(g,su(M))},h=mr(n,{sharedRoot:e,sharedState:t,setState:(g,E)=>f(g,[!0,!0,E]),setDraft:(g,E)=>f(g,[!1,!0,E]),insSetState:(g,E)=>f(g,[!0,!1,E]),insSetDraft:(g,E)=>f(g,[!1,!1,E]),setStateFactory:l,innerSetState:i,ruleConf:c,isDeep:a});return h.sync=Zo(h),h.syncer=zo(h),Ac(e,h),h}function Zu(e,t){const n=au(e,t),{sharedRoot:r,sharedState:o}=ra(n),s=Ju(r,o,n);Tc(r,n),Gc(),Kn({target:r,dict:n.mutateFnDict});const{draft:c,draftRoot:a}=ln(s,{isTop:!0});return s.reactive=c,s.reactiveRoot=a,Sc(n.moduleName,s.loc),Ya(s.usefulName),pc(s),{sharedRoot:r,sharedState:o,internal:s,parsedOptions:n}}var{USER_STATE:Qo}=Q,{MUTATE:Qu,ACTION:qo}=H;function Fn(e,t){Qo===(t||Qo)&&!an()&&(oa(e,se),Na(e,se))}function es(e,t){const{createFn:n,ldAction:r,actionDict:o,actionCreator:s,internal:c,apiCtx:a,forTp:u=!1}=e;He(n,{internal:c,from:qo,apiCtx:a});const l={},i={};return Object.keys(o).forEach(f=>{const d=o[f],p=u?d.__task:d,y=s(!1)(p,f,t);y.__fnName=f,i[f]=y;const m=(...h)=>{const g=y(...h);return yu(p)?Promise.resolve(g).then(E=>E.result):g.result};m.__fnName=f,l[f]=m}),{actions:l,eActions:i,getLoading:()=>r.getLoading(l),useLoading:()=>r.useLoading(l)[0],useLoadingInfo:()=>r.useLoading(l)}}function ts(e,t,n){const{state:r,stateRoot:o,isAtom:s}=e,c=Pt(n);return O(t)?t({state:r,stateRoot:o,isAtom:s,extraBound:c}):t}function ns(e){const{common:t,ldMutate:n,mutateFnDict:r,extra:o}=e,s=ts(t,r,o),c=Rn(t.stateRoot,o)(s);return{witnessDict:c,getLoading:()=>n.getLoading(c),useLoading:()=>n.useLoading(c)[0],useLoadingInfo:()=>n.useLoading(c)}}function qu(e){const{common:t,ldMutate:n,inital:r,mutateFnDict:o}=e,{stateRoot:s,useState:c,state:a,isAtom:u}=os(t.apiCtx,r),l=j(w({},t),{stateRoot:s,state:a,isAtom:u,internal:Y(s)}),i=ns({common:l,ldMutate:n,mutateFnDict:o,extra:t.stateRoot});return w({derivedState:s,useDerivedState:c},i)}function ei(e){const{common:t,deriveFnDict:n,throwErr:r}=e,o=ts(t,n),{apiCtx:s,stateRoot:c}=t,a={},u={};return Object.keys(o).forEach(i=>{const f=To(o[i],c);a[i]=f,u[i]={runDerive:d=>Za(f,d!=null?d:r),runDeriveTask:d=>Qa(f,d!=null?d:r),useDerived:d=>bn(s,f,d)[0],useDerivedInfo:d=>bn(s,f,d)}}),{result:new Proxy(a,{get:(i,f)=>a[f].val}),helper:u}}function ti(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(o=>{const s=n[o];s.enabled||(s.enabled=!0,r[o]=s)}),Rn(t.sharedState)(r)}}function ni(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}}function se(e,t){const{stateType:n,apiCtx:r}=e;Fn(r,n);const{sharedRoot:o,sharedState:s,internal:c}=Zu(e,t),{syncer:a,sync:u,forAtom:l,setState:i,setDraft:f,sharedKey:d,sharedKeyStr:p,rootValKey:y,reactive:m,reactiveRoot:h}=c,g=Ko(o),E=g(),K={internal:c,from:Qu,apiCtx:r},_=se,M=eo(_,j(w({},K),{from:qo})),I=eo(_,K),D={createFn:_,internal:c,apiCtx:r,state:s,stateRoot:o,isAtom:l},k=j(w({},D),{ldAction:M,actionCreator:g});return{state:s,stateVal:s,stateRoot:o,setState:i,setDraft:f,setEnableMutate:v=>ti(v,c),getOptions:()=>ni(c),defineActions:v=>S=>es(j(w({},k),{actionDict:S}),v),defineTpActions:v=>S=>es(j(w({},k),{actionDict:S,forTp:!0}),v),defineMutateDerive:v=>S=>qu({common:D,ldMutate:I,inital:v,mutateFnDict:S}),defineMutateSelf:()=>v=>ns({common:D,ldMutate:I,mutateFnDict:v}),defineFullDerive:v=>S=>ei({common:D,deriveFnDict:S,throwErr:v}),mutate:Fo(o),runMutate:v=>wo(o,v),runMutateTask:v=>Mo(o,v),action:g,call:(v,S,A,T)=>E(v,A,T)(S),useState:v=>ko(r,o,v),useStateX:v=>Co(r,o,v),useForceUpdate:v=>Po(r,o,v),useLocalState:v=>Yo(r,v),useLocalForceUpdate:()=>Vo(r),getMutateLoading:I.getLoading,useMutateLoading:I.useLoading,getActionLoading:M.getLoading,useActionLoading:M.useLoading,getSnap:v=>hr(o,v),sync:u,syncer:a,sharedKey:d,sharedKeyStr:p,rootValKey:y,reactive:m,reactiveRoot:h,reactiveDesc:v=>Br(o,v),useReactive:v=>wn(r,o,v),useReactiveX:v=>Go(r,o,v),flush:v=>fn(o,v),isAtom:l}}function rs(e,t,n){const r=se({apiCtx:e,rawState:t},n);return[r.stateRoot,r.setState,r]}function os(e,t,n){return se({apiCtx:e,rawState:t},n)}function ri(e,t,n){const r=se({apiCtx:e,rawState:t,forAtom:!0},n);return[r.stateRoot,r.setState,r]}function oi(e,t,n){return se({apiCtx:e,rawState:t,forAtom:!0},n)}function ss(e,t){const{label:n,isSyncer:r}=t,o=ye(e,{label:n});return(r?zo:Zo)(o)}function si(e){return ss(e,{label:"sync"})}function ci(e){return ss(e,{label:"syncer",isSyncer:!0})}var ai=100,ui=5e3;function ii(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function fi(e,t=!1){const n=q();e&&(n.initCount+=1);const r=Mc(),o=ii(r,t);return Lr(e).set(r,o),o}function li(e){const t=q();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function di(e,t){const n=q(),r=Lr(t);if(r.delete(e),t&&r.size===ai&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const o=Date.now();r.forEach((s,c)=>{!s.mounted&&o-s.time>ui&&r.delete(c)})}}function pi(e,t){const n=q();n.runningKey=e.key,n.isDynamic=t}function yi(e){const t=q();t.runningKey="",t.isDynamic=!1,e.collected=!0}function hi(e,t,n){ju(e,n,{manualDepKeys:t.depKeys})}function cs(e,t,n){let r={loading:!1,err:null,ok:!0};return hi(e,t,n),t.results.forEach(o=>{const s=Tn(e,{result:o,forAtom:fe(o),showLoading:t.enableStatus});s.status.ok||(r=s.status)}),r}function as(e,t,n){e.react.useEffect(()=>(t.mounted||li(t),()=>{di(t.key,n)}),[t])}var mi=()=>!0,kn=e=>e;function gi(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function Cn(e,t,n,r,o){const s=t;return s.displayName=n,r?e.react.memo(s,o):s}function us(e,t){const{sharedState:n,depKey:r,keyPath:o,compare:s,sharedKey:c,format:a=kn}=t;return Cn(e,function(){const l=pn(e,n,{arrDep:!0});l.isFirstRender&&(o.length>=2?gi(o).forEach(d=>{l.recordDep({sharedKey:c,depKey:$(d,c),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},tt)}):l.recordDep({sharedKey:c,depKey:r,keyPath:o}));const i=ie(l.internal.rawState,o);return a(i)},"HeluxSignal",!0,s)}function On(e,t){return Cn(e,function(){const{result:r,format:o=kn}=t,s=Tn(e,{result:r,forAtom:!0});return o(s.proxyResult.val)},"HeluxDerivedAtomSignal",!0,t.compare)}function Ei(e,t){return Cn(e,function(){const{result:r,keyPath:o,format:s=kn}=t;return Tn(e,{result:r,forAtom:!1}),s(ie(r,o))},"HeluxDerivedSignal",!0,t.compare)}function is(e,t){const{isDynamic:n,cb:r,props:o,ref:s}=t,{collected:c,status:a}=e;c||pi(e,n);const l=r(o,{props:o,status:a,read:Ds,ref:s})||"";return c||yi(e),l}function fs(e,t,n){const r=fe(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const o=On(e,{result:n});return e.react.createElement(o,{status:{loading:!1,err:null,ok:!0}})}return er(n)}function ls(e,t,n,r){const{memo:o=!0,compare:s}=r||{},{key:c}=t,{react:a}=e,u=a.forwardRef||F,l=n();let i=u(l);ae()&&(l.displayName="HeluxKeyedBlockForHMR",i=u((d,p)=>(p&&Is(p,"current")&&(t.ref=p),a.createElement(l,j(w({},d),{key:c})))));const f=o?a.memo(i,s):i;return f.displayName="HeluxBlock",f[Ct]=!0,f}function vi(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,{useForceUpdate:c}=o.hookImpl,a=r?as:F;return ls(o,s,()=>(u,l)=>{const i=s.ref||l,f=is(s,{isDynamic:r,cb:n,props:u,ref:i}),d=c();return cs(o,s,d),a(o,s,r),fs(o,s,f)},t)}function Si(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,c=r?as:F,{useForceUpdate:a}=o.hookImpl,{useEffect:u}=o.react;return ls(o,s,()=>(l,i)=>{const f=s.ref||i,d=is(s,{isDynamic:r,cb:n,props:l,ref:f}),p=a(),y=cs(o,s,p);c(o,s,r);const m=s.status.loading,h=y.loading;return u(()=>{m!==h&&p()},[m,h]),s.status=y,fs(o,s,d)},t)}function ds(e,t){const n=fu(t),{enableStatus:r}=n,o=j(w({},e),{blockCtx:fi(e.isDynamic,r)});return r?Si(o,n):vi(o,n)}function Ai(e,t,n){return ds({apiCtx:e,isDynamic:!1,cb:t},n)}function ps(e,t,n){return ds({apiCtx:e,isDynamic:!0,cb:t},n)}function ys(e,t,n){const{react:r}=e;if(t&&t[Ct])return r.createElement(t);const o=mi;if(O(t)){const d=ps(e,t,{compare:o});return r.createElement(d)}if(fe(t)){const d=On(e,{result:t,compare:o,format:n});return r.createElement(d)}if(Re(t)){const d=re(t),p=Tt("val",d),m=us(e,{sharedKey:d,sharedState:t,depKey:p,keyPath:["val"],compare:o,format:n});return r.createElement(m)}const s=na(),{sharedKey:c,val:a,stateOrResult:u,depKey:l,keyPath:i,isDerivedResult:f}=s;if(t===a&&u){if(s.isDerivedAtom){const p=On(e,{result:u,compare:o,format:n});return r.createElement(p)}if(f){const p=Ei(e,{result:u,keyPath:i,compare:o,format:n});return r.createElement(p)}const d=us(e,{sharedKey:c,sharedState:u,depKey:l,keyPath:i,compare:o,format:n});return r.createElement(d)}return t}var{shallowCompare:Ki,isDiff:Di,isDraft:_i}=X.limuUtils,Ri=rs,Ti=ys,bi={EVENT_NAME:Ft,RECORD_LOADING:kt,VER:Hn,LIMU_VER:Bs};function hs(e,t,n){return t(e,n)}function Ii(e,t){return hs(e,t)}function wi(e,t){return{build:n=>hs(e,t,n)}}var Mi=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function Fi(e){return e.startsWith("use")||Mi.includes(e)}function ki(e){return Object.assign({useSyncExternalStore:F},e)}function Ci(e,t){const n=Ps(e),r=w({},n),o={react:ki(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,a]=e.useState({});return()=>t(()=>a({}))});const s=jn;return Object.keys(s).forEach(a=>{const u=s[a];Fi(a)?r[a]=u.bind(null,o):r[a]=u}),Object.assign({model:a=>Ii(r,a),modelFactory:a=>wi(r,a)},r)}function Oi(e){const{inited:t,API:n}=sc();if(t)return n;const{heluxCtxKey:r,standalone:o,transfer:s,reactLib:c,act:a}=e,u=Z[r],l=(i,f)=>{const d=f||nr(),p=Ci(c,a);return cr({ROOT:d,inited:!0,api:p}),Z[i]=d,p};if(!u)return l(r);if(o)return l(`${String(r)}_${Date.now()}`);if(s){const i=nr();cr({ROOT:i,inited:!0}),s(u,i)}return l(r,u)}var xi=P(70079),Li=P.t(xi,2),ms=Oi({heluxCtxKey:"__HELUX__",reactLib:Li}),Pi=ms.share,{atom:Ni,atomx:Ui,share:Bi,sharex:Vi,derive:Yi,deriveDict:Gi,defineDeriveTask:ji,defineDeriveFnItem:Hi,runDerive:$i,runDeriveTask:Wi,watch:Xi,watchEffect:zi,useAtom:Ji,useAtomX:Zi,useReactive:Qi,useReactiveX:qi,useDerived:ef,useWatch:tf,useWatchEffect:nf,useGlobalId:rf,useService:of,useOnEvent:sf,useMutable:cf,useMutateLoading:af,useActionLoading:uf,useEffect:ff,useLayoutEffect:lf,useStable:df,useObject:pf,useLocalForceUpdate:yf,useGlobalForceUpdate:hf,action:mf,signal:gf,block:Ef,dynamicBlock:vf,$:Sf,mutate:Af,mutateDict:Kf,runMutate:Df,runMutateTask:_f,defineMutateFnItem:Rf,sync:Tf,syncer:bf,model:If,modelFactory:wf,emit:Mf,on:Ff,init:kf,reactiveDesc:Cf,flush:Of,isAtom:xf,isSharedState:Lf,isDerivedAtom:Pf,isDerivedResult:Nf,isDraft:Uf,storeSrv:Bf,shallowCompare:Vf,markRaw:Yf,isDiff:Gf,produce:jf,getMutateLoading:Hf,getActionLoading:$f,getDeriveLoading:Wf,getRawState:Xf,getSnap:zf,getAtom:Jf,addMiddleware:Zf,addPlugin:Qf,cst:qf}=ms}}]);
}());