!(function(){"use strict";var Bf=Object.defineProperty,Gf=Object.defineProperties;var Hf=Object.getOwnPropertyDescriptors;var mt=Object.getOwnPropertySymbols;var io=Object.prototype.hasOwnProperty,fo=Object.prototype.propertyIsEnumerable;var uo=(L,P,C)=>P in L?Bf(L,P,{enumerable:!0,configurable:!0,writable:!0,value:C}):L[P]=C,b=(L,P)=>{for(var C in P||(P={}))io.call(P,C)&&uo(L,C,P[C]);if(mt)for(var C of mt(P))fo.call(P,C)&&uo(L,C,P[C]);return L},N=(L,P)=>Gf(L,Hf(P));var lo=(L,P)=>{var C={};for(var T in L)io.call(L,T)&&P.indexOf(T)<0&&(C[T]=L[T]);if(L!=null&&mt)for(var T of mt(L))P.indexOf(T)<0&&fo.call(L,T)&&(C[T]=L[T]);return C};var po=(L,P,C)=>new Promise((T,W)=>{var he=Y=>{try{ge(C.next(Y))}catch(X){W(X)}},Ve=Y=>{try{ge(C.throw(Y))}catch(X){W(X)}},ge=Y=>Y.done?T(Y.value):Promise.resolve(Y.value).then(he,Ve);ge((C=C.apply(L,P)).next())});(self.webpackChunkhelux_docs=self.webpackChunkhelux_docs||[]).push([[3649],{73649:function(L,P,C){C.r(P),C.d(P,{$:function(){return lf},action:function(){return cf},addMiddleware:function(){return Nf},addPlugin:function(){return Uf},atom:function(){return wi},atomx:function(){return Mi},block:function(){return uf},createShared:function(){return Ii},cst:function(){return Vf},defineDeriveFnItem:function(){return Pi},defineDeriveTask:function(){return Li},derive:function(){return Ci},deriveDict:function(){return Oi},dynamicBlock:function(){return ff},emit:function(){return Sf},flush:function(){return _f},getActionLoading:function(){return Cf},getAtom:function(){return xf},getDeriveLoading:function(){return Of},getMutateLoading:function(){return kf},getRawState:function(){return Lf},getSnap:function(){return Pf},init:function(){return Af},isAtom:function(){return Rf},isDerivedAtom:function(){return Tf},isDiff:function(){return Mf},markRaw:function(){return wf},model:function(){return Ef},modelFactory:function(){return vf},mutate:function(){return df},mutateDict:function(){return pf},on:function(){return Kf},produce:function(){return Ff},reactiveDesc:function(){return Df},runDerive:function(){return xi},runDeriveTask:function(){return Ni},runMutate:function(){return yf},runMutateTask:function(){return hf},shallowCompare:function(){return If},share:function(){return Fi},sharex:function(){return ki},signal:function(){return af},storeSrv:function(){return bf},sync:function(){return gf},syncer:function(){return mf},useActionLoading:function(){return qi},useAtom:function(){return Yi},useAtomX:function(){return Bi},useDerived:function(){return ji},useEffect:function(){return ef},useGlobalForceUpdate:function(){return of},useGlobalId:function(){return Xi},useLayoutEffect:function(){return tf},useLocalForceUpdate:function(){return sf},useMutable:function(){return Zi},useMutateLoading:function(){return Qi},useObject:function(){return rf},useOnEvent:function(){return Ji},useReactive:function(){return Gi},useReactiveX:function(){return Hi},useService:function(){return zi},useStable:function(){return nf},useWatch:function(){return $i},useWatchEffect:function(){return Wi},watch:function(){return Ui},watchEffect:function(){return Vi}});function T(e,t){e.includes(t)||e.push(t)}function W(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function he(e){return Array.from(new Set(e))}function Ve(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function ge(e,t){let n="";const r=e.length;for(let s=0;s<r;s++){const o=e[s];if(t.startsWith(o)){n=o;break}}return n}function Y(e,t){if(!e)return[];const n=e(t);return Array.isArray(n)?n:[n]}var X=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),Mn=!1;function M(...e){}var yo=M;function ho(...e){return e}function me(...e){return[]}function jf(...e){}var go=Object.prototype.toString,mo="[object Map]";function $f(){return!(typeof window!="undefined"&&window.document)}function Et(e){return go.call(e)===mo}function Fn(e){return e===Number.MAX_SAFE_INTEGER}function se(){return!(!Mn&&X.name!=="previewFrame"&&!X.BrowserFS)}function j(e){return e&&typeof e=="object"&&!Array.isArray(e)}function kn(e){return e&&typeof e=="object"}function F(e){return typeof e=="function"}function Wf(e){return Mn?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function vt(e){return typeof e=="symbol"}function St(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&F(e.then)}function Xf(e){try{return e.test,!1}catch(t){return!0}}function Ke(){return typeof Proxy=="function"}function oe(e,t){var i;const{throwErr:n=!1,prefixLabel:r="",suffixLabel:s=", see details in console.",logErr:o=!0,alertErr:c}=t||{};let a=e,u=!1;if(e instanceof Error&&(u=!0,a=e.message),(c!=null?c:se())&&e&&((i=X.alert)==null||i.call(X,`${r}${a}${s}`)),o&&console.error(e),n)throw u?e:new Error(String(e))}function Ee(e,t=0){t===0?(console.error(e),se()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function Ae(e){return Fn(e)?1:e+1}var Eo=!!Reflect,vo=Object.prototype.hasOwnProperty;function So(e,t){return Eo?Reflect.has(e,t):vo.call(e,t)}function De(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function Ye(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function Cn(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function On(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function ce(e,t){let n,r=e;return t.forEach(s=>{n=Et(r)?On(r,s):r[s],r=n}),n}function Ln(e,t,n){let r=e;const s=t.length-1;t.forEach((o,c)=>{const a=Et(r);if(c===s)return void(a?r.set(o,n):r[o]=n);r=a?On(r,o):r[o]})}function Ko(){return Ee("changing shared state is invalid"),!0}function zf(e){return e}function Kt(e,t){return`${t}/${e}`}function At(e){return e&&Ke()}var Ao=Object.defineProperty,Dt={};((e,t)=>{for(var n in t)Ao(e,n,{get:t[n],enumerable:!0})})(Dt,{useEffect:()=>To,useEffectLogic:()=>Rt,useForceUpdate:()=>Pn,useLayoutEffect:()=>Ro,useObject:()=>Io,useObjectLogic:()=>Nn,useStable:()=>xn});var Do=0,Be=new Map,_t=0;function _o(e,t){const n=()=>{const r=t();return()=>{Be.delete(e),r&&r()}};if(function(r){_t||(_t=r)}(e),function(r){const s=Be.get(r);s?s.count+=1:Be.set(r,{count:1})}(e),_t%2!=0)return n();{const r=function(s){return Be.get(s)}(e);if(r&&r.count>1)return n()}}function Rt(e,t,n){const{useState:r,useLayoutEffect:s,useEffect:o}=e.react,{isLayout:c,deps:a}=n,[u]=r(()=>++Do);(c?s:o)(()=>_o(u,t),a)}function Ro(e,t,n){Rt(e,t,{isLayout:!0,deps:n})}function To(e,t,n){Rt(e,t,{deps:n})}function Pn(e){const[,t]=e.react.useState({});return()=>t({})}function bo(e){const{data:t}=e.current;F(t)?e.current.wrap=(...n)=>e.current.data(...n):j(t)?e.current.wrap=function(n,r){if(!Ke()){const o={};return Object.keys(n).forEach(c=>{const a=n[c];F(a)?o[c]=(...u)=>r.current.data[c](...u):Object.defineProperty(o,c,{get:()=>r.current.data[c],set(u){r.current.data[c]=u}})}),o}const s={};return new Proxy(n,{get(o,c){const a=o[c];return F(a)?De(s,c,(...u)=>r.current.data[c](...u)):a}})}(t,e):e.current.wrap=t}function xn(e,t){const{useRef:n,useMemo:r}=e.react,s=n({data:t,wrap:{},inited:!1});return s.current.data=r(()=>t,[t]),s.current.inited||(bo(s),s.current.inited=!0),s.current.wrap}function Nn(e,t,n,r){const{useState:s,useRef:o,useEffect:c}=e.react,[a]=s(t),u=Pn(e),i=o({state:null,unmount:!1,shouldCopy:!0}),l=xn(e,{setState(f){const d=i.current;if(d.unmount)return;let y;const{state:m}=d;n?(y=n(f,d.state||a),r&&y?(d.state=y,d.shouldCopy=!1):d.shouldCopy=!0):(y=(F(f)?f(m):f)||{},d.shouldCopy=!0),Object.assign(a,y||{}),u()},getLatestState(){const f=i.current;return f.shouldCopy&&(f.state=b({},a),f.shouldCopy=!1),f.state}});return c(()=>{const f=i.current;return f.unmount=!1,()=>{f.unmount=!0}},[i]),[a,l.setState,l]}function Io(e,t){return Nn(e,t)}function wo(e){const t={},n={react:e},r=Dt;return Object.keys(Dt).forEach(s=>{t[s]=r[s].bind(null,n)}),t}var G=C(69857),Mo=Object.defineProperty,Fo=(e,t)=>{for(var n in t)Mo(e,n,{get:t[n],enumerable:!0})},Un={};Fo(Un,{$:()=>mi,action:()=>ps,addMiddleware:()=>Qo,addPlugin:()=>nc,atom:()=>zu,atomx:()=>Ju,block:()=>pi,createShared:()=>gi,cst:()=>Ei,currentDraftRoot:()=>Mc,defineDeriveFnItem:()=>hu,defineDeriveTask:()=>yu,derive:()=>ms,deriveDict:()=>pu,dynamicBlock:()=>to,emit:()=>cc,flush:()=>nn,getActionLoading:()=>wu,getAtom:()=>Xn,getDeriveLoading:()=>Ha,getMutateLoading:()=>bu,getRawState:()=>pc,getSnap:()=>ir,init:()=>Zo,isAtom:()=>Te,isDerivedAtom:()=>ae,isDiff:()=>hi,markRaw:()=>G.Xl,mutate:()=>As,mutateDict:()=>En,on:()=>ac,produce:()=>G.Uy,reactiveDesc:()=>Or,runDerive:()=>Va,runDeriveTask:()=>Ya,runMutate:()=>Ss,runMutateTask:()=>Ks,shallowCompare:()=>yi,share:()=>Rn,sharex:()=>Xu,signal:()=>no,storeSrv:()=>Ou,sync:()=>Zu,syncer:()=>Qu,useActionLoading:()=>Mu,useAtom:()=>Ds,useAtomX:()=>_s,useDerived:()=>Sn,useGlobalForceUpdate:()=>Is,useGlobalId:()=>Tu,useLocalForceUpdate:()=>ks,useMutable:()=>Cs,useMutateLoading:()=>Iu,useOnEvent:()=>Fu,useReactive:()=>An,useReactiveX:()=>Os,useService:()=>Cu,useWatch:()=>Pu,useWatchEffect:()=>xu,watch:()=>su,watchEffect:()=>ou});var Vn="4.0.3",ko=G.TT,Tt={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},bt={NO:"no",PRIVATE:"private",GLOBAL:"global"},Yn=0,Bn=Symbol,Co=typeof Bn=="function";function Q(e){return Co?Bn(e):(Yn+=1,`__HELUX_SYMBOL_${Yn}__`)}var Oo="__proto__",Lo=Ke(),Po=Q("HeluxUndefined"),Gn=Q("HeluxMutateFnItem"),Ge=Q("HeluxFnKey"),He=Q("HeluxSharedKey"),Hn=Q("HeluxReactiveMeta"),It=Q("HeluxIsBlock"),_e=Q("HeluxIsAtom"),je=Q("HeluxIsDerivedAtom"),$e=[He,_e,je,It],We="SingleMutate",xo="HeluxGlobalLoading",No=6,Uo=!0,jn=2e3,Vo=20,Re="1",wt="2",Xe=1,ze=2,$n=3,ve="|",Je={TASK:"task",MAY_TRANSFER:"may_transfer"},q={STATIC:"static",HOOK:"hook"},J={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},Yo="derive",Wn="watch",Ze="Object",Bo="Map",Go="Array",Ho="Other",B={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function Te(e){var t;return e&&(t=e[_e])!=null?t:!1}function ae(e){return e&&e[je]||!1}function Xn(e){return Te(e)||ae(e)?e.val:e}function jo(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function $o(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function Wo(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function Xo(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function zn(){const e={};return{on:(t,n)=>{De(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(s=>s(...n))},off:(t,n)=>{const r=e[t]||[],s=r.findIndex(o=>o===n);s>=0&&r.splice(s,1)},canEmit:t=>e[t]}}function Jn(){const e={VER:Vn,LIMU_VER:G.TT,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:zn(),userBus:zn(),mod:{},middlewares:[],plugins:[],sharedScope:Xo(),fnScope:jo(),insScope:Wo(),blockScope:$o(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var Qe={},Zn=!1,Qn=null,qn=!1;function U(){return Qe.ctx||{}}function zo(){return Qe}function er(e){Qe=e.ROOT,Qn=e.api,Zn=e.inited}function Jo(){return{ROOT:Qe,inited:Zn,API:Qn}}function Zo(e){if(qn)return!1;qn=!0;const{isRootRender:t=!0}=e;return U().isRootRender=t,!0}function Qo(e){const{middlewares:t}=U();t.push(e)}function qo(e,t,n,r){const{middlewares:s}=U();if(!s.length)return;const o={},{sharedKey:c,moduleName:a,forAtom:u}=e,l={forAtom:u,draftRoot:t,draft:n,sharedKey:c,moduleName:a,setData:(f,d)=>o[f]=d,data:o,idx:0,sn:r};s.forEach((f,d)=>{f(N(b({},l),{idx:d}))})}var{ON_DATA_CHANGED:Mt,ON_SHARE_CREATED:tr,ON_ERROR_OCCURED:ec}=Tt,tc=[J.GLOGAL_LOADING,J.PRIVATE_LOADING];function nc(e){const{plugins:t,bus:n}=U();t.push(e);const r={on:(s,o)=>n.on(s,o),onStateChanged:s=>n.on(Mt,s)};e.install(r)}function rc(e,t){const{bus:n}=U();if(n.canEmit(Mt)){const{from:r,desc:s}=t,{sharedKey:o,moduleName:c,snap:a,usefulName:u,stateType:i}=e;let l;tc.includes(i)?l=`${u}/setState`:l=`${u}@${r||"Api"}/${s}`,n.emit(Mt,{snap:a,sharedKey:o,moduleName:c,type:l})}}function sc(e){const{bus:t}=U();if(t.canEmit(tr)){const{snap:n,sharedKey:r,moduleName:s,usefulName:o}=e,c=`${o}@FactoryApi/createShared`;t.emit(tr,{snap:n,sharedKey:r,moduleName:s,type:c})}}function nr(e,t,n){const{bus:r}=U();if(!r.canEmit(t))return!1;const{sharedKey:s,moduleName:o}=e;return r.emit(t,{moduleName:o,sharedKey:s,data:n}),!0}function rr(e,t){nr(e,ec,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function oc(){const{userBus:e}=U();return e}function cc(e,...t){const{userBus:n}=U();n.emit(e,...t)}function ac(e,t){const{userBus:n}=U();return n.on(e,t),()=>n.off(e,t)}function uc(e,t){return e.__proto__=t,e}function ic(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var Ft=Object.setPrototypeOf||({__proto__:[]}instanceof Array?uc:ic);function fc(e){const t=Object.create(null);return Ft(t,b({},Object.prototype)),e&&Object.assign(t,e),t}function sr(e){if(F(e))return;const t=Object.create(null);return Ft(t,Object.prototype),Ft(e,t),e}function or(e,t,n){return e[t]=n,!0}function cr(e,t){return e[t]}function be(e,t){const{set:n=or,get:r=cr,obj:s={}}=t||{};return Object.keys(e).forEach(o=>{Object.defineProperty(s,o,{enumerable:!0,configurable:!1,set:function(c){return n(e,o,c)},get:function(){return r(e,o)}})}),s}function ue(e,t){const{set:n=or,get:r=cr}=t||{};if(Ke())return new Proxy(e,{set(c,a,u){return n(c,a,u)},get(c,a){return r(c,a)}});const s=fc();return be(s,{obj:s,set:n,get:r})}var Ie=U();function qe(e){const n=U()[e];return Ie[e]=n,n}function Z(){return Ie.blockScope||qe("blockScope")}function x(){return Ie.fnScope||qe("fnScope")}function ee(){return Ie.sharedScope||qe("sharedScope")}function ar(){return Ie.insScope||qe("insScope")}function ur(){const{INTERMAL_MAP:e}=ee();return e}function lc(e,t){if(!e||!se()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:s}=ee();let o=[],c=!1;if(n.forEach(a=>{a.moduleName===e&&a.loc===t&&a.stateType===J.USER_STATE&&o.push(a.sharedKey)}),o.length>1){const a=o[0],u=n.get(a);n.delete(a),u&&(r.delete(u.sharedKey),s.delete(u.rawState))}return c}function we(e){return ur().get(e)}function V(e){const t=te(e);return we(t)}function dc(e,t){const n=ur(),r=te(e);n.set(r,t)}function pc(e){return V(e).rawState}function ir(e,t=!0){const n=V(e);return t?n.prevSnap:n.snap}function te(e){return e&&(e[He]||ee().STATE_SHARED_KEY_MAP.get(e))||0}function yc(e){const t=ee(),{STATE_SHARED_KEY_MAP:n}=t,r=Ae(t.keySeed);return n.set(e,r),t.keySeed=r,r}function hc(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=ee();n.set(e,t),r.set(t,e)}function gc(e){return ee().SHARED_KEY_STATE_MAP.get(e)}function mc(e,t){const{rootState:n,ctx:r}=zo(),{moduleName:s,usefulName:o}=t,c=n[o],a=V(c);if(s&&a&&a.loc!==t.loc){const u=`
loc1:${a.loc} 
loc2:${t.loc}`;return Ee(`only-dev-mode tip: moduleName ${s} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+u)}n[o]=e,r.mod[o]=V(e)}var Ec={innerSetState:M};function fr(e,t){const{rawState:n,forAtom:r}=e,s=new Map,o={},c={},a=[],u=b({},n);let i=u;return r&&(i=n.val),N(b(b({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:M,syncer:M,snap:u,prevSnap:u,rawStateVal:i},e),t),{insCtxMap:s,key2InsKeys:o,id2InsKeys:c,recordId(l,f){if(!l)return;const d=De(c,l,[]);T(d,f)},delId(l,f){l&&W(c[l]||[],f)},recordDep(l,f){const d=De(o,l,[]);T(d,f)},delDep(l,f){W(o[l]||[],f)},mapInsCtx(l,f){s.set(f,l)},delInsCtx(l){s.delete(l)},extra:{},loadingInternal:Ec,level1ArrKeys:a})}var vc={Mutate:"",Reactive:"r",[q.STATIC]:"s",[q.HOOK]:"h"};function Sc(){const e=ar(),t=Ae(e.keySeed);return e.keySeed=t,t}function Kc(){const e=Z(),{keySeed:t,keyPrefix:n}=e,r=Ae(t);e.keySeed=r;let s=n;return Fn(t)&&(s=Ae(n),e.keyPrefix=s),`${s}_${r}`}function Ac(){const e=U(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function kt(e){const t=vc[e],r=x().keySeed,s=Ae(r[e]);return r[e]=s,`${t}${s}`}function Dc(){return kt("Reactive")}var{MAY_TRANSFER:_c}=Je,{SET_STATE:Rc,REACTIVE:Tc}=B,bc=()=>({isReplaced:!1,replacedValue:null}),Ic=()=>{},wc=Ot({isFake:!0});function lr(e,t,n=M){const{desc:r="",onRead:s,from:o=Tc,depKeys:c=[],isTop:a=!1,expired:u=!1,insKey:i=0}=t;return{draft:e,finish:n,modified:!1,expired:u,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:M,data:[],isTop:a,key:"",fnKey:"",depKeys:c,writeKeys:[],desc:r,onRead:s,from:o,insKey:i}}function Ct(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:s=Rc,enableDep:o=!1,handleCbReturn:c=!0,sn:a=Ac(),isFirstCall:u=!1,desc:i="",onRead:l}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:c,draftVal:null,from:s,isReactive:r,enableDep:o,sn:a,isFirstCall:u,desc:i,onRead:l}}function Me(e,t,n){const{isChanged:r=!0,parentKeyPath:s=[],op:o="set",parentType:c="Object"}=n,a=s.slice();return a.push(e),{isChanged:r,isCustom:!1,op:o,immutBase:!1,key:e,value:t,proxyValue:t,parentType:c,keyPath:s,fullKeyPath:a,isBuiltInFnKey:!1,replaceValue:M,getReplaced:bc}}function Ot(e){const f=e||{},{desc:t="",fn:n=M,task:r=Ic,depKeys:s=[],writeKeys:o=[],deps:c=me,isFake:a=!1,onlyDeps:u=!1}=f,i=lo(f,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return b({fn:n,task:r,deps:c,oriDesc:"",onlyDeps:u,desc:t,depKeys:s,writeKeys:o,checkDeadCycle:void 0,watchKey:"",isFake:a,enabled:!0},i)}function dr(){const e={fnKey:"",fn:M,subFnInfo:wc,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:M,deps:me,status:{loading:!1,err:null,ok:!0},forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:Xe,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:Re,proxyResult:{},updater:M,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:M},asyncType:_c,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var pr={draftRoot:{val:null},isFake:!0,isAtom:!0},yr=Ct({}),et=lr(!0,{expired:!0}),Jf=Ot(),hr=fr({rawState:{},forAtom:!1,usefulName:""},{}),gr=dr(),tt=pr,Lt=yr,mr="",Pt=new Map,xt=new Map,Nt=new Map,Ut=M,Vt=[],Yt="";function Mc(){return tt}var Fe={current:()=>Yt,set:e=>Yt=e,del:()=>Yt=""},Bt={current:()=>Ut,set:e=>Ut=e,del:()=>Ut=M},ke={current:e=>xt.get(e)||"SetState",set:(e,t)=>xt.set(e,t),del:e=>xt.delete(e)},Ce={current:()=>Vt,set:e=>Vt=e,del:()=>Vt=[]},ne={current:()=>Nt.get(mr)||et,markUsing:e=>mr=e,set:(e,t)=>Nt.set(e,t),del:e=>Nt.delete(e)},Gt={current:e=>Pt.get(e),set:(e,t)=>Pt.set(e,t),del:e=>Pt.delete(e)},nt={current:()=>tt,set:(e,t)=>{Object.assign(tt,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>tt=pr},Ht={current:()=>Lt,set:e=>Lt=e,del:()=>Lt=yr};function jt(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=x();return e[0]==="s"?t:n}function Fc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=x();Ye(n,e,[]).push(t)}function kc(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=x(),r=n.get(e);r&&W(r,t)}function Cc(e){const{DEPKEY_FNKEYS_MAP:t}=x(),{depKeys:n,fnKey:r}=e;n.forEach(s=>{const o=t.get(s)||[];W(o,r)})}function Er(e,t){const{FNKEY_STATIC_CTX_MAP:n}=x(),{fnKey:r,prevLevelFnKeys:s}=e;s.forEach(o=>{var a;const c=(a=n.get(o))==null?void 0:a.nextLevelFnKeys;c&&(t?T(c,r):W(c,r))})}function Oc(){const{FNKEY_HOOK_CTX_MAP:e}=x();se()&&e.forEach(t=>{t.isExpired=!0})}function vr(e,t,n){const r=n||kt(t);return F(e)?e[Ge]=r:(sr(e),e.__proto__[Ge]=r),r}function Sr(e){return F(e)?e[Ge]||"":j(e)&&e.__proto__[Ge]||""}function ie(e){return jt(e).get(e)}function $t(e){return jt(e).get(e)||gr}function Oe(e){const t=Sr(e);return ie(t)||null}function rt(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r}=x();return{fnCtx:e?ie(e):null,depKeys:t,isIgnore:r,runningSharedKey:n}}function Lc(){return x().runningFnKey}var{USER_STATE:Pc}=J;function xc(e,t=8){let n="";if(se()&&e)try{throw new Error("loc")}catch(r){const s=r.stack.split(`
`),o=s[1]||"";o.includes("webpack-internal")||o.includes("/node_modules/")?n=s.slice(0,16).join(" -> "):n=s.map(a=>a.substring(0,a.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function Kr(e){const[t,n]=e.split("/"),r=n.split(ve);return{sharedKey:Number(t),keyPath:r,depKey:e}}function Ar(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",s=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:s,sharedKey:t}}function H(e,t){try{return Kt(e.join(ve),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Nc(e,t){const{snap:n,prevSnap:r,stateType:s}=e;if(Pc!==s)return!0;const{keyPath:o}=Kr(t);try{const c=ce(n,o),a=ce(r,o);return c!==a}catch(c){return!0}}function Uc(e,t){return Ke()?(0,G.OA)(e,{onOperate:t,compareVer:!0}):ue(e,{get(n,r){const s=n[r],o=Me(r,s,{isChanged:!1,parentKeyPath:[]});return t(o),s}})}function Vc(e,t){if(t!==void 0){if(e)return{val:t};if(j(t))return t}}function Yc(e,t,n){const r=F(t)?t(n):t;return Vc(e,r)}function st(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:s}=e.getReplaced();s&&(n=r)}return n}function Dr(e){return[Go,Bo].includes(e)}function Bc(e){return Array.isArray(e)||Et(e)}var{isObject:fe,getDataType:_r}=G.limuUtils;function Rr(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(ve);return`${e}${ve}${r[0]}`}function Gc(e,t){ge(e,t)||T(e,t)}var Wt=new Map;function Tr(e,t){let n=!1;const{depKey:r,keyPath:s,sharedKey:o}=e,{stopDepInfo:c,level1ArrKeys:a,recordCb:u}=t,i=Wt.get(r);if(i)return u(i),!0;const{keys:l,isArrDict:f,depth:d,arrKeyStopDcit:y,stopArrDep:m}=c,p=ge(a,r),g=s.length>d;if(g||p){let S="",D=d;return p&&(D=d+1,y[p]===!1||m&&(g?S=H(s.slice(0,D),o):S=Rr(p,r))),S||(S=H(s.slice(0,D),o)),p||Wt.set(r,S),u(S),!0}const v=String(o);for(const S of l){if(!r.startsWith(S)||S===v)continue;const D=f[S],I=D?Rr(S,r):S;D||Wt.set(r,I),u(I),n=!0;break}return n}function Xt(e,t){const n=Z(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:s,KEY_CTX_MAP:o,isDynamic:c}=n,u=(c?s:o).get(r);if(u){const{results:i,depKeys:l}=u;t?T(i,t):e.forEach(f=>T(l,f))}}}function ot(e,t){const n=ee(),{COMPARE_MAP:r}=n;let s=r.get(t);return s!==void 0?s:e.sharedKeyStr===t?n.isStateChanged:(s=Nc(e,t),r.set(t,s),s&&(n.isStateChanged=!0),s)}function br(e,t,n){if(t.includes(n)&&ot(e,n))return!0;let r=!1;for(const s of t)s.startsWith(n)&&ot(e,s)&&(r=!0);return r}function Hc(){const e=ee();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function zt(e=!0){const t=x();t.isIgnore=e}function Se(e,t){const{fnCtx:n,depKeys:r,isIgnore:s}=rt(),o=t.specificCtx||n;if(!o){Bt.current()(e);return}const{DEPKEY_FNKEYS_MAP:c}=x(),{belongCtx:a,sharedKey:u}=t;if(u&&T(o.depSharedKeys,u),n&&a){n.isFirstLevel=!1,a.isAsync&&(n.isAsync=!0);const l=a.fnKey;T(o.prevLevelFnKeys,l),T(a.nextLevelFnKeys,n.fnKey)}const{fnKey:i}=o;e.forEach(l=>{if(Oo===l||s)return;n&&T(r,l);const f=Ye(c,l,[]);T(f,i)})}function Jt(e){e&&e.depKeys.forEach(t=>Se([t],{specificCtx:e}))}function Ir(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=x(),{fnKey:r}=e;t.set(r,e),Er(e,!0);let s=n.get(r);s?s.c=2:(s={c:1,t:Date.now(),prev:0},n.set(r,s));const{c:o}=s;if(o===2){const c=ie(r);Jt(c)}}function wr(e){let t="";return e.depSharedKeys.forEach(n=>{var s;const r=((s=we(n))==null?void 0:s.ver)||0;t+=`${r}_`}),t}function jc(e,t,n){const{DEPKEY_FNKEYS_MAP:r}=x(),s=r.get(t)||[],o=[],c=[];return s.forEach(a=>{const u=ie(a);if(u&&br(e,u.depKeys,t)){u.isFirstLevel&&o.push(a),u.isAsync&&c.push(a);const i=n[a];n[a]=i===void 0?1:i+1}}),{firstLevelFnKeys:o,asyncFnKeys:c}}function Zt(e){Cc(e),Er(e)}function $c(){const{FNKEY_HOOK_CTX_MAP:e}=x();if(e.size>=Vo){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:s,fnKey:o}=n;[Xe,$n].includes(r)&&t-s>jn&&(Zt(n),e.delete(o))})}}function Qt(e,t,n,r,s,o=!1,c=!1){const a=Z();a.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:s,isDerivedResult:o,isDerivedAtom:c}}function Wc(){return Z().latest}function Mr(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=Z();return e?t:n}function Fr(){return Ee("changing shared state is invalid"),!0}function ct(e,t,n,r,s){return r===_e?e?t:!1:r===He?n:s}function qt(e,t,n){e.replaceValue(ct(e.keyPath.length===0,t,n,e.key,e.value))}function Xc(e){let t={};const{rawState:n,sharedKey:r,forAtom:s,onRead:o,isPrimitive:c,stopDepth:a}=e,u=(l,f)=>{const d=H(l,r);Se([d],{sharedKey:r}),Xt([d]),Qt(r,f,t,d,l)};if(Lo)t=(0,G.OA)(n,{customKeys:$e,onOperate:l=>{const{isBuiltInFnKey:f,isCustom:d}=l;if(d)return qt(l,s,r);if(!f){const{fullKeyPath:y}=l,m=st(l,o);u(y,m)}},compareVer:!0});else{const l=(f,d,y)=>be(f,{set:Fr,get:(m,p)=>{const g=m[p];if($e.includes(p))return ct(d===1,s,r,p,g);const v=Me(p,g,{isChanged:!1,parentKeyPath:y});if(d<a&&fe(g))return l(g,d+1,v.fullKeyPath);const S=st(v,o);return u(v.fullKeyPath,S),S}});t=l(n,1,[])}let i=t;return s&&(c?i=n.val:i=ue(n,{set:Fr,get:(l,f)=>t.val[f]})),hc(r,t),{sharedRoot:t,sharedState:i}}var kr=null;function en(){return kr}function zc(e,t){const n=U();let r=n.globalEmpty;if(!r){const{stateRoot:s}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:J.GLOGAL_EMPTY}),o=V(s);n.globalEmpty=s,n.globalEmptyInternal=o}return kr=r,r}function tn(e){const{GID_INSKEYS_MAP:t}=x();return Ye(t,e,[])}function Jc(){return U().globalEmptyInternal}function Cr(e,t){if(!e)return;const n=tn(e);T(n,t)}function Zc(e,t){if(!e)return;const n=tn(e);W(n,t)}var{REACTIVE:Qc}=B,Le=new Map;function qc(e){return!!(e&&!e.expired&&e.modified)}function ea(e){const{sharedKey:t}=e;e.expired=!0,ne.del(e.key);const n=ke.current(t);return ke.del(t),e.finish(null,{desc:n})}function Or(e,t){const n=te(e);return t&&ke.set(n,t),n}function nn(e,t){const n=te(e);Pe(n,t)}function ta(){const e=ne.current();e.isTop&&Pe(e.sharedKey,e.desc)}function Pe(e,t){const n=Le.get(e);qc(n)&&(t&&ke.set(e,t),ea(n))}function na(e){const t=Le.get(e)||et;t.expired=!0}function ra(e,t){const n=Le.get(e)||et;n.modified=!0,n.nextTickFlush(t)}function sa(e,t){const{from:n=Qc,onRead:r}=t,{finish:s,draftRoot:o}=e.setStateFactory({isReactive:!0,from:n,handleCbReturn:!1,enableDep:!0,onRead:r}),c=lr(o,t,s);return c.key=Dc(),c.sharedKey=e.sharedKey,c.nextTickFlush=a=>{const{expired:u,hasFlushTask:i}=c;u||(c.data=[a]),i||(c.hasFlushTask=!0,Promise.resolve().then(()=>{const[l]=c.data;Pe(e.sharedKey,l)}))},c}function Lr(e,t,n){const{sharedKey:r}=e,{insKey:s=0,from:o}=t;let c=Le.get(r)||et;c.expired&&(c=sa(e,{isTop:!0,from:o}),Le.set(r,c),ne.set(c.key,c),ne.markUsing(c.key),c.fnKey=Fe.current()),c.onRead=s?t.onRead:void 0;const{draft:a}=c;return{val:n?a.val:a,meta:c}}function rn(e,t){let n={},r={};const{rawState:s,deep:o,forAtom:c,isPrimitive:a,sharedKey:u}=e;if(At(o)){const i={[He]:u,[_e]:c},l=(d,y,m)=>{const{val:p}=Lr(e,t,d);return p[y]=m,!0},f=(d,y,m)=>{const p=m[y];if(p!==void 0)return p;const{val:g,meta:v}=Lr(e,t,d);return Hn===y?v:g[y]};if(n=new Proxy(s,{set:(d,y,m)=>l(!1,y,m),get:(d,y)=>f(!1,y,i)}),r=n,c){const d=N(b({},i),{[_e]:!1});r=a?s.val:new Proxy(s.val,{set:(y,m,p)=>l(!0,m,p),get:(y,m)=>f(!0,m,d)})}}else n=s,r=s.val;return{draftRoot:n,draft:r}}function oa(e){const{UNMOUNT_INFO_MAP:t}=ar(),{insKey:n,readMap:r,internal:s}=e;s.mapInsCtx(e,n);let o=t.get(n);o?(o.c=2,o.prev=n-1):(o={c:1,t:Date.now(),prev:0},t.set(n,o));const{c}=o;c===2&&Object.keys(r).forEach(a=>{s.recordDep(a,n)})}function Pr(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(s=>r.delDep(s,n)),r.delInsCtx(n)}function ca(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function aa(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function xr(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:s}=n,o=Bc(s);o&&Gc(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,o)}function sn(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:s}=e;return(t?r:n).concat(s)}function ua(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===Xe){Date.now()-r>jn?Pr(e):e.needEFUpdate=!0;return}t()}function Nr(e){const{internal:t,isReactive:n,insKey:r}=e,{rawState:s,isDeep:o,sharedKey:c,onRead:a,forAtom:u}=t;if(o){const i=l=>{const{isBuiltInFnKey:f,key:d}=l;if(f)return;if(vt(d))return qt(l,u,c);const{fullKeyPath:y,keyPath:m,parentType:p}=l,g=st(l,a),S={depKey:H(y,c),keyPath:y,parentKeyPath:m,sharedKey:c};xr(e,S,{parentType:p,rawVal:g})};if(n){const{draft:l,draftRoot:f}=rn(t,{onRead:i,insKey:r});e.proxyState=f,e.proxyStateVal=l}else e.proxyState=(0,G.OA)(s,{onOperate:i,compareVer:!0})}else e.proxyState=ue(s,{set:()=>(Ee("changing shared state is invalid"),!0),get:(i,l)=>{const f=i[l];if(vt(l))return ct(!0,u,c,l,f);const d=st(Me(l,f,{isChanged:!1,parentKeyPath:[]}),a),y=Kt(l,c),m=fe(i)?Ze:Ho;return xr(e,{depKey:y,keyPath:[l],sharedKey:c},{parentType:m,rawVal:d}),d}})}function ia(e){var k;const{updater:t,sharedState:n,id:r="",globalId:s="",collectType:o="every",deps:c,pure:a=!0,arrDep:u=!0,isReactive:i=!1}=e,l=u&&(k=e.arrIndexDep)!=null?k:!0,f=V(n);if(!f)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=Sc(),{rawState:y,isDeep:m,ver:p,ruleConf:g,level1ArrKeys:v,forAtom:S,sharedKey:D,sharedKeyStr:I,snap:R}=f,{stopDepInfo:K}=g,_={readMap:{},delReadMap:{},pure:a,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:m,isReactive:i,insKey:d,internal:f,rawState:y,sharedState:n,sharedKey:D,proxyState:{},proxyStateVal:{},updater:t,mountStatus:Xe,renderStatus:Re,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:p,id:r,globalId:s,collectType:o,canCollect:o!=="no",isFirstRender:!0,subscribe:E=>{E()},extra:{},getDeps:()=>sn(_,!0),renderInfo:{setDraft:f.insSetDraft,time:Date.now(),sn:0,snap:R,insKey:d,getDeps:()=>sn(_,!0),getPrevDeps:()=>sn(_,!1)},recordDep:(E,w,A)=>{let h=E.depKey;Tr(E,{stopDepInfo:K,level1ArrKeys:v,recordCb:Ue=>{h=Ue}});const{renderStatus:O,fixedDepKeys:$}=_;if(O===wt)return;const{readMap:z,insKey:Yf,currentDepKeys:wn,delReadMap:oo}=_;Se([h],{}),Lc()&&(W(wn,h),T(_.fixedDepKeys,h));const co=()=>{z[h]=1,f.recordDep(h,Yf),$.includes(h)||T(wn,h)};if(!z[h]&&!oo[h]){const{parentKeyPath:Ue}=E;if(a&&w===Ze&&Ue){const gt=Ue.length?H(Ue,D):I;z[gt]&&(delete z[gt],oo[gt]=1,W(wn,gt))}const ao=Dr(w);if(ao){l&&co();return}(!A||!ao&&u)&&co()}}};if(s&&Cr(s,d),Nr(_),f.mapInsCtx(_,d),f.recordId(r,d),F(c)){const E=S?_.proxyState.val:_.proxyState,w=Y(c,E),A=_.getDeps().slice();w.includes(E)&&A.push(f.rootValKey),_.fixedDepKeys=A}return _}function Ur(e){const{result:t,forAtom:n}=e;e.proxyResult=ue(t,{set:()=>(Ee("changing derived result is invalid"),!1),get:(r,s)=>je===s?n:(Re===e.renderStatus&&Jt(e),t[s])})}function fa(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:s,isReactive:o}=e,{sharedKey:c,sharedKeyStr:a,insSetState:u,forAtom:i}=n;r.snap=n.snap,r.time=Date.now();const l=i?t.val:t;return e.isFirstRender&&(e.rootVal=l,Gt.set(e.rootVal,e)),!i&&s&&e.recordDep({depKey:a,keyPath:[],sharedKey:c},Ze),[o?t:l,u,r]}function la(e,t){if(t&&!Te(e))throw new Error("useAtom only accept atom")}function da(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,Nr(e))}function pa(e){e.mountStatus=ze;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Cr(n,r),oa(e)}function ya(e){e.mountStatus=$n;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),Zc(n,r),Pr(e)}function ha(e,t){const n=V(t).sharedKey;return e.internal.sharedKey!==n}function at(e,t,n,r){if(U().isRootRender)try{const s=r||n;e.react.useSyncExternalStore(t,n,s)}catch(s){console.error(s)}}var ga=null;function Vr(e,t,n){const{hookImpl:r,react:s}=e,o=r.useForceUpdate(),c=s.useRef({ctx:ga});let a=c.current.ctx;return(!a||ha(a,t))&&(a=ia(b({updater:o,sharedState:t},n)),c.current.ctx=a),a}function Yr(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Gt.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),pa(t),()=>{ya(t)}),[t])}function ma(e,t,n,r){n.renderStatus=Re,aa(n),at(e,n.subscribe,()=>V(t).snap),e.react.useEffect(()=>{n.renderStatus=wt,n.isFirstRender=!1,ca(n)})}function on(e,t,n={}){const r=Vr(e,t,n);return at(e,r.subscribe,()=>V(t).snap),Yr(e,r),r}function ut(e,t,n={}){const{forAtom:r}=n;la(t,r);const s=Vr(e,t,n);return ma(e,t,s,n),Yr(e,s),da(s),{tuple:fa(s),insCtx:s}}function Br(e,t){const{forAtom:n,label:r,strict:s=!1}=t||{};let o;if(typeof e=="number"?o=we(e):o=V(e),!o&&e){const a=e[Hn];o=we(a==null?void 0:a.sharedKey)}let c=r?`[[${r}]] err:`:"err:";if(!o)if(s)oe(`${c} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!o.forAtom&&oe(`${c} expect a shared but recived a atom`,{throwErr:!0}),!n&&o.forAtom&&oe(`${c} expect a atom but recived a shared`,{throwErr:!0})),o}function le(e,t){return Br(e,N(b({},t||{}),{strict:!0}))}var{MUTATE:Ea,LOADING:va}=B,{GLOGAL_LOADING:Sa,PRIVATE_LOADING:Ka}=J,{PRIVATE:Aa,GLOBAL:Da}=bt,Gr={},_a={},Ra={time:0,sn:0,getDeps:me,getPrevDeps:me,insKey:0,setDraft:M},Ta=[de(Gr,_a,Ea),M,Ra];function ba(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:s,moduleName:o}=n,c={};Object.keys(s).forEach(i=>{c[i]={loading:!1,err:null,ok:!0}});const a=o?`${o}@Loading`:"";return e({apiCtx:r,rawState:c,isLoading:!0,stateType:Ka},{moduleName:a}).state}var Hr=null;function Ia(){return Hr}function jr(){return U().globalLoadingInternal}function wa(e,t){const n=U();let r=n.globalLoading;if(!r){const{stateRoot:s}=t({apiCtx:e,rawState:{},stateType:Sa},{moduleName:xo}),o=V(s);n.globalLoadingInternal=o,n.globalLoading=s}return Hr=r,r}function cn(e,t){let n=t;return vt(t)&&(n=t.toString()),`${e}>${n}`}function $r(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(s=>{s[t]=n},{from:va}),n.err&&(nr(e,Tt.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function de(e,t,n){let r=e[n];return r||(r=ue(t,{get(s,o){const c=cn(n,o);return s[c]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function xe(e,t){const{internal:n,from:r}=t,{stateType:s,recordLoading:o}=n,c=J.USER_STATE===s;let a=de(Gr,{},r),u={};if(c)if(Aa===o)u=n.extra.loadingProxy,u||(u=ba(e,t),n.extra.loadingProxy=u,n.loadingInternal=V(u)),a=de(n.extra,u,r);else if(Da===o){const i=jr();u=Ia(),n.loadingInternal=i,a=de(i.extra,u,r)}else u=en();else u=n.sharedState,a=de(n.extra,u,r);return{loadingState:a,loadingProxy:u}}function Wr(e,t){if(!fe(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?N(b({},e),{internal:le(r.__sharedKey)}):e}function Xr(e,t){const{internal:n,from:r,apiCtx:s}=t,{stateType:o}=n,c=J.USER_STATE===o;xe(e,t);let a=()=>Ta;return c&&(a=u=>{const i=Wr(t,u),l=xe(e,i).loadingProxy,{insCtx:{proxyState:f,internal:d,extra:y,renderInfo:m}}=ut(s,l);return[de(y,f,r),d.setState,m]}),{useLoading:a,getLoading:u=>{const i=Wr(t,u);return xe(e,i).loadingState}}}function it(e){const t=dr();return Object.assign(t,e||{})}function pe(){const e=x(),{runningFnKey:t}=e;if(!t)return[];const n=ie(t);let r=[];if(n){const{depKeys:s}=e,{depKeys:o}=n,c={};s.forEach(u=>c[u]=1),s.forEach(u=>{const i=Cn(c,u);i&&i!==u&&delete c[i]}),Object.keys(c).forEach(u=>T(o,u)),r=o.slice()}return e.runningFnKey="",e.depKeys=[],e.runningSharedKey=0,r}function an(e,t){const n=x();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function zr(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:s}=n,o=vr(e,s),c=b({fn:e,fnKey:o},n),a=r?Object.assign(r,c):it(c);return jt(s).set(o,a),a}function un(e){var s;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=x(),{fnKey:r}=e;Zt(e),e.extra.deferedWatch=null,t.delete(r),((s=n.get(r))==null?void 0:s.c)===2&&n.delete(r),$c()}function Jr(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=x(),{prevLevelFnKeys:n,depKeys:r}=e;let s=!1;for(const o of r){const c=t.get(o)||[];if(Ve(c,n)){s=!0;break}}return s}function Ma(e,t=!0,n=ve){return e.map(r=>{const[s,o]=r.split("/"),c=o.split(ve);return`${t?`${we(Number(s)).usefulName}/`:""}${c.join(n)}`})}var ft=new Map,lt={WATCH:"1",MUTATE:"2"},Fa={[lt.WATCH]:"watch",[lt.MUTATE]:"mutate fn or task"};function ka(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function Zr(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function Ca(e){ft.delete(e)}function Oa(e,t,n,r){const s=Fa[r],{desc:o,task:c,fn:a,isFake:u}=t.subFnInfo,i=o?`(${o})`:"",l=`DEAD_CYCLE: found reactive object in ${s}${i} cb is changing module(${e.usefulName})'s some of these dep keys(${Ma(n,!1,".")}), it will cause a infinity loop call!`,f=u?t.fn:c||a;return{err:new Error(`[only-dev-mode alert] ${l}`),tipFn:()=>console.error(` ${l} open the stack to find the below fn: 
`,f)}}function La(e,t,n){if(e&&n){const{usefulName:r}=e,s=Ye(ft,r,ka(t));s.sn!==t&&(s.descs=[],s.errs=[]);const{descs:o}=s;if(o.length>1&&o[0]===n){const c=o.slice();throw s.cycle=c,o.length=0,Zr(r,c,n)}T(o,n)}}function fn(e,t){t.tipFn(),oe(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function ye(e,t,n){const{depKeys:r,subFnInfo:s}=t;let o=t.depKeys,c=n;r.length>n.length&&(o=n,c=r);let a=!1;if(Ve(o,c)){const u=s.desc?lt.MUTATE:lt.WATCH,i=Oa(e,t,n,u);fn(e,i),t.dcErrorInfo=i,a=!0}return a}function Pa(e,t){const n=ft.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function xa(e,t,n=!0){const r=ft.get(e);if(!r)return;const{timer:s,errs:o}=r;o.push(t),s&&clearTimeout(s),r.timer=setTimeout(()=>{let c=null;for(const a of o)c?a.data.length>c.data.length&&(c=a):c=a;c&&oe(c,{alertErr:n}),o.length=0},0)}function ln(e,t=0){const n=ie(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:Na}=Je;function Ua(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:s=0,from:o,internal:c=hr,desc:a,fromFnKey:u}=t;if(e.dcErrorInfo.err){fn(c,e.dcErrorInfo);return}if(e.fnKey===u){ye(c,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:s});if(B.MUTATE===o&&La(c,s,a),e.isRunning&&ye(c,e,t.depKeys||[]))return;const i=ne.current();if(i.fnKey===e.fnKey&&ye(c,e,i.writeKeys)||(Pe(i.sharedKey,i.desc),e.isRunning===!0&&i.isTop&&ye(c,e,i.writeKeys)))return;e.isRunning=!0,Fe.set(e.fnKey);const f=e.fn({isFirstCall:n,triggerReasons:r,sn:s});Fe.del();const d=ne.current();if(!(d.isTop&&d.fnKey===e.fnKey&&ye(c,e,d.writeKeys))&&!(f&&f.task&&d.from===B.MUTATE&&ye(c,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,f}function Ne(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:s=!1,throwErr:o=!1,triggerReasons:c=[],sn:a=0,err:u,unbox:i=!1,internal:l=hr}=t,f=ie(e),d=(A=null)=>{if(A&&o)throw A;const h=f||gr;return i?[h.result.val,A]:[h.result,A]};if(!f)return d(new Error(`not a valid watch or derive cb for key ${e}`));if(f.fnType===Wn)return Ua(f,t);const{isAsync:y,fn:m,task:p,isAsyncTransfer:g,forAtom:v,result:S,depKeys:D}=f;f.remainRunCount>0&&(f.remainRunCount-=1);const I=A=>{const h=v?{val:A}:A;!f.returnUpstreamResult&&h&&Object.assign(f.result,h),f.shouldReplaceResult=!0},R=()=>{f.renderInfo.sn=a,f.updater()},K=A=>{const{data:h,err:O=null}=A;O?f.setLoading(!1,O):(I(h),n?y&&f.status.loading&&!Jr(f)&&f.setLoading(!1,O):f.remainRunCount===0&&f.setLoading(!1,O)),R(),f.nextLevelFnKeys.forEach($=>{Ne($,{isFirstCall:n,sn:a,triggerReasons:c,err:O})})},_=v?S.val:S,k=Y(f.deps),E={isFirstCall:n,prevResult:_,triggerReasons:c,input:k,sn:a};if(!y||r||y&&!p){const A=m(E);return K({data:A}),d()}if(y&&n&&f.nextLevelFnKeys.forEach(A=>ln(A,0)),g)return K({err:u}),d();if(f.asyncType===Na){const A=m(E);return K({data:A}),d()}if(p){let A=yo;return n?(D.forEach(h=>Fc(h,e)),A=()=>D.forEach(h=>kc(h,e))):s&&f.nextLevelFnKeys.forEach(h=>ln(h)),Promise.resolve(()=>{const h=p(E);return St(h)?h:(oe("ERR_NON_FN: derive task arg should be async function!",{throwErr:o}),null)}).then(h=>h()).then(h=>(A(),K({data:h}),d())).catch(h=>{if(A(),K({err:h}),o)throw h;return rr(l,h),d(h)})}return d(u)}function dt(e,t){const n=Oe(e);if(!n)throw new Error("[Helux]: not a derived result");return Ne(n.fnKey,b({},t||{}))}function Va(e,t){return dt(e,{forceFn:!0,throwErr:t})}function Ya(e,t){return Promise.resolve(dt(e,{forceTask:!0,throwErr:t}))}function Ba(e,t){return dt(e,{forceFn:!0,throwErr:t,unbox:!0})}function Ga(e,t){return Promise.resolve(dt(e,{forceTask:!0,throwErr:t,unbox:!0}))}function Ha(e){const t=Oe(e);return t?t.status:{loading:!1,err:null,ok:!0}}function dn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,ua(r))}function ja(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:s,depKeys:o,triggerReasons:c,isFirstCall:a,from:u,sn:i,desc:l,fnKey:f}=t,{key2InsKeys:d,id2InsKeys:y,insCtxMap:m,rootValKey:p}=n;let g=[],v=[],S=[],D=[];const I={};if(a){const K=pe();Ce.set(K)}const R=K=>{if(!ot(n,K))return;const _=d[K]||[],k=[];for(const A of _){if(g.includes(A))continue;const h=m.get(A);if(!h)continue;const O=h.getDeps();if(O[0]===p){ot(n,p)&&k.push(A);continue}br(n,O,K)&&k.push(A)}g=g.concat(k);const{firstLevelFnKeys:E,asyncFnKeys:w}=jc(n,K,I);S=S.concat(E),D=D.concat(w)};if(o.forEach(K=>R(K)),o.includes(p)||R(p),Hc(),r.forEach(K=>{g=g.concat(y[K]||[])}),s.forEach(K=>{tn(K).forEach(_=>T(v,_))}),g=he(g),S=he(S),D=he(D),D.forEach(K=>ln(K,I[K])),S.forEach(K=>Ne(K,{depKeys:o,sn:i,from:u,triggerReasons:c,internal:n,desc:l,isFirstCall:a,fromFnKey:f})),g.forEach(K=>dn(m,K,i)),v.length){const K=Jc().insCtxMap;v.forEach(_=>dn(K,_,i))}}function $a(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:s,isDeep:o,ver:c,snap:a}=n;o?(n.prevSnap=c===0?b({},a):a,n.snap=t,Object.assign(s,t)):n.snap=b({},s),n.ver+=1,n.sn=r.sn,ja(e)}var{MUTATE:Wa}=B;function Qr(e,t){const{writeKey:n,ids:r,internal:s,opParams:o}=t,{snap:c}=s,{fullKeyPath:a,value:u}=o;Object.keys(e).forEach(i=>{n.startsWith(i)&&ce(c,a)!==u&&e[i].forEach(l=>T(r,l))})}function qr(e,t){const{isChanged:n,fullKeyPath:r,keyPath:s,parentType:o,value:c}=e,{internal:a,mutateCtx:u}=t,{arrKeyDict:i,isReactive:l,readKeys:f}=u,{sharedKey:d}=a,y=Dr(o),m=ne.current();if(e.op==="get"){y&&(i[H(s,d)]=1);const h=H(r,d);f[h]=1,u.enableDep&&(u.onRead&&u.onRead(e),m.onRead?m.onRead(e):(rt().fnCtx&&Se([h],{sharedKey:d}),l&&(Xt([h]),Qt(d,c,a.sharedState,h,r))));return}if(!n)return;const{moduleName:p,ruleConf:g,level1ArrKeys:v}=a,{writeKeyPathInfo:S,ids:D,globalIds:I,writeKeys:R}=u,K=H(r,d);if(m.key&&(m.isTop?T(m.writeKeys,K):m.from===Wa&&T($t(m.fnKey).subFnInfo.writeKeys||[],K)),y){const h=H(s,d);S[h]={sharedKey:d,moduleName:p,keyPath:s},R[h]=1}const{hasIds:_,hasGlobalIds:k,stopDepInfo:E}=g;S[K]={sharedKey:d,moduleName:p,keyPath:r};const w=Cn(i,K);w&&(R[w]=1),Tr({sharedKey:d,keyPath:r,depKey:K},{stopDepInfo:E,level1ArrKeys:v,recordCb:h=>{R[h]=1}})||(R[K]=1),_&&Qr(g.idsDict,{ids:D,writeKey:K,internal:a,opParams:e}),k&&Qr(g.globalIdsDict,{ids:I,writeKey:K,internal:a,opParams:e}),l?ra(d,m.desc):na(d)}function es(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function pt(e,t){if(!t)return e;zt(!0);const n=e.val;return zt(!1),n}function ts(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:s}=e;if(!t)return;if(!n){fe(t)&&es(s,t);return}const o=t.val;if(fe(s)){fe(o)?es(s,o):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=o}function Xa(e,t){const{internal:n,mutateCtx:r}=e,s=pt(t,n.forAtom),{from:o,sn:c,desc:a}=r;n.before({from:o,draftRoot:t,draft:s,desc:a,sn:c}),qo(n,t,s,c)}function ns(e,t,n,r){const{mutateCtx:s,internal:o}=e,{writeKeys:c,writeKeyPathInfo:a,handleCbReturn:u}=s,{forAtom:i}=o;u&&ts({partial:r,forAtom:i,draftRoot:t,draftNode:n}),Xa(e,t),s.depKeys=Object.keys(c),nt.del(),Ht.del(),e.state=(0,G._x)(t),e.state!==o.rawState&&(s.triggerReasons=Object.values(a),$a(e),rc(o,s))}function rs(e,t){const{ids:n,globalIds:r,from:s,desc:o,fnKey:c}=t;n&&n.forEach(a=>T(e.ids,a)),r&&r.forEach(a=>T(e.globalIds,a)),s&&(e.from=s),o&&(e.desc=o),c&&(e.fnKey=c)}function za(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:s}=t,o=Ct(n),c=(0,G.P2)(s,{customKeys:$e,onOperate:u=>{if(u.isCustom)return qt(u,r,t.sharedKey);qr(u,{internal:t,mutateCtx:o})}});nt.set(c,r),Ht.set(o);const a=pt(c,r);return r&&(o.readKeys={}),{draftRoot:c,draftNode:a,finishMutate(u,i={}){rs(o,i),ns({state:{},mutateCtx:o,internal:t},c,a,u)}}}function Ja(e){return sr(e),yc(e)}function Za(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function Qa(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=F(n);let s=!1;if(t)n=r?{val:n()}:{val:n},s=!n.val||!kn(n.val);else{if(n=r?n():n,!j(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(te(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:s,rawState:n}}function ss(e,t,n){let r=null,s=t||"";if(F(e)&&e!==M)r={[Gn]:1,fn:e,deps:me,oriDesc:s,onlyDeps:!1,desc:s,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0};else if(j(e)){const{fn:o,desc:c,deps:a,task:u,immediate:i,checkDeadCycle:l,onlyDeps:f=!1}=e,d=t||c||"",y=F(o)?o:void 0,m=F(u)?u:void 0,p=F(a)?a:me;(o||u)&&(r={[Gn]:1,checkDeadCycle:l,fn:y,watchKey:"",desc:d,oriDesc:d,deps:p,task:m,onlyDeps:f,immediate:i,depKeys:[],writeKeys:[],isFake:!1,enabled:!0})}if(r&&n){const{oriDesc:o}=r;(!o||n[o])&&(r.desc=kt(B.MUTATE))}return r}function os(e,t,n=!0){const r={},s=t||{};if(!e)return r;const o=(c,a)=>{const u=ss(c,a,s);u&&(u.enabled=n,r[u.desc]=u,s[u.desc]=u)};if(Array.isArray(e))if(e.length===1){const c=e[0],a=(j(c)?c.desc:"")||We;o(e[0],a)}else e.forEach(c=>o(c));else F(e)?o(e,We):j(e)&&Object.keys(e).forEach(c=>{o(e[c],c)});return r}function qa(e,t={}){var k,E,w,A,h;const{forAtom:n=!1,forGlobal:r=!1,stateType:s=J.USER_STATE}=e,{rawState:o,isPrimitive:c}=Qa(e),a=Ja(o),u=t.moduleName||"",i=(k=t.alertDeadCycleErr)!=null?k:se(),l=(E=t.deep)!=null?E:!0,f=(w=t.checkDeadCycle)!=null?w:!0,d=(A=t.enableMutate)!=null?A:!0,y=t.recordLoading||bt.PRIVATE,m=t.rules||[],p=t.before||M,g=t.mutate||M,v=(h=t.stopArrDep)!=null?h:!0,S=t.stopDepth||No,D=`${a}`,I=n?`${a}/val`:D,R=u||D,K=xc(u),_=os(g,{},d);return{isDestroyed:!1,alertDeadCycleErr:i,checkDeadCycle:f,rawState:o,sharedKey:a,sharedKeyStr:D,rootValKey:I,moduleName:u,usefulName:R,forAtom:n,forGlobal:r,loc:K,deep:l,rules:m,before:p,mutate:g,mutateFnDict:_,onRead:null,enableMutate:d,stateType:s,recordLoading:y,stopArrDep:v,stopDepth:S,isPrimitive:c}}function eu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:s,rules:o,stopDepth:c,stopArrDep:a,forAtom:u}=e,i={},l={},f={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:c,stopArrDep:a},d={},y=At(s);o.forEach(g=>{const v=[],{when:S,ids:D=[],globalIds:I=[],stopDep:R}=g;let K;if(y){let A="";K=(0,G.OA)(t,{onOperate:({fullKeyPath:h,value:O,isBuiltInFnKey:$})=>{if($)return;const z=H(h,n);A&&z.includes(A)&&v.pop(),v.push(z),d[z]=Array.isArray(O),A=z}})}else K=ue(t,{set:Ko,get:(A,h)=>{const O=H([h],n);v.push(O);const $=A[h];return d[O]=Array.isArray($),$}});const _=u?K.val:K,k=Y(S,_),E=(A,h,O)=>{const $=De(A,O,[]);h.forEach(z=>T($,z))},w=A=>{E(i,D,A),E(l,I,A);let h;d[A]?(h=R!=null?R:Uo,f.arrKeyStopDcit[A]=h,f.isArrDict[A]=d[A]):h=R!=null?R:!1,h&&T(f.keys,A)};v.forEach(w),k.includes(_)&&w(r)});const m=Object.keys(i).length>0,p=Object.keys(l).length>0;return{hasIds:m,idsDict:i,hasGlobalIds:p,globalIdsDict:l,stopDepInfo:f}}function tu(e){const{desc:t=We,strict:n=!1,throwErr:r=!1}={};return typeof e=="string"?{desc:e,strict:n,throwErr:r}:N(b({desc:t,strict:n},e),{throwErr:r})}function cs(e,t){var s;let n=M,r=!1;return F(t)?n=t:j(t)&&(n=t.deps||M,r=(s=t.immediate)!=null?s:!1),r=e?!0:r,{immediate:r,deps:n}}function nu(e){return e?typeof e=="boolean"?{enableStatus:e}:j(e)?e:{}:{}}function ru(e){Array.isArray(e)&&e.forEach(t=>{const n=Gt.current(t),r=V(t)||(n==null?void 0:n.internal);if(r){const{depKey:s,sharedKey:o}=Ar(r);Se([s],{sharedKey:o})}n&&n.recordDep(Ar(r))})}function as(e,t,n){const{deps:r,immediate:s}=cs(e,n),o=yt(t,{scopeType:q.STATIC,deps:r,immediate:s});return{run:c=>Ne(o.fnKey,{throwErr:c}),unwatch:()=>Zt(o)}}function yt(e,t){const{scopeType:n,fnCtxBase:r,immediate:s,deps:o=M,label:c="watch",sharedState:a,isSimpleWatch:u}=t;if(!F(e))throw new Error(`ERR_NON_FN: pass an non-function to ${c}!`);const i=zr(e,{specificProps:{scopeType:n,fnType:Wn,isSimpleWatch:u},fnCtxBase:r});an(i.fnKey,te(a));const l=o()||[];return ru(l),s&&e({isFirstCall:!0}),pe(),i}function su(e,t){return as(!1,e,t)}function ou(e,t){return as(!0,e,t)}var us=()=>{},pn=new Map;function is(e,t){const{forAtom:n,rawState:r}=e;return n?Y(t.deps,r.val):Y(t.deps,r)}function cu(e){var t;return(t=pn.get(e))!=null?t:!1}function yn(e,t){const{sn:n,getArgs:r=M,from:s,throwErr:o,isFirstCall:c,fnItem:a,mergeReturn:u}=t,{desc:i="",depKeys:l,task:f=us}=a,d=V(e),{sharedKey:y}=d,m={desc:i,sn:n,from:s},p=cn(s,i),{draft:g,draftRoot:v}=rn(d,{depKeys:l,desc:i,from:s}),S=h=>{Pe(y,h)},D=h=>{S(i);const{finish:O}=d.setStateFactory(m);return O(h)},I=B.MUTATE===s?is(d,a):[],R={isFirstCall:c,desc:i,setState:D,input:I,draft:g,draftRoot:v,flush:S},K=r(R)||[R],_=pn.get(f),k=_===void 0,E=(h,O,$)=>{(k||_)&&$r(d,p,{loading:h,err:O,ok:$})};E(!0,null,!1);const w=h=>{if(Ce.del(),E(!1,h,!1),o)throw h;return{snap:d.snap,err:h,result:null}},A=h=>(u&&h&&D(h),E(!1,null,!0),S(i),{snap:d.snap,err:null,result:h});try{const h=f(...K),O=St(h);return pn.set(f,O),O?Promise.resolve(h).then(A).catch(w):A(h)}catch(h){return w(h)}}function fs(e,t){const{sn:n,getArgs:r=M,from:s,throwErr:o,isFirstCall:c=!1,fnItem:a}=t,{desc:u="",watchKey:i,fn:l=us}=a,f=B.MUTATE===s;f&&Fe.set(i);const d=V(e),{setStateFactory:y,forAtom:m,sharedState:p}=d,v={desc:u,sn:n,from:s,isFirstCall:c,enableDep:f&&c},S=E=>{const{finish:w}=y(v);return w(E)},D=pt(p,m),I=f?is(d,a):[],{draftNode:R,draftRoot:K,finish:_}=y(v),k=r({isFirstCall:c,draft:R,draftRoot:K,setState:S,desc:u,input:I})||[R,{input:I,state:D,draftRoot:K,isFirstCall:c}];try{const E=$t(a.watchKey);if(E.dcErrorInfo.err)return fn(d,E.dcErrorInfo),{snap:d.snap,err:null,result:null};const w=l(...k);return _(w,{fnKey:E.fnKey}),ls(d,a,c),{snap:d.snap,err:null,result:null}}catch(E){if(ls(d,a,c),o)throw E;return{snap:d.snap,err:E,result:null}}}function ls(e,t,n){n&&!t.onlyDeps&&(rt().fnCtx?t.depKeys=pe():t.depKeys=Ce.current(),Ce.del());const r=ne.current();r.isTop&&r.fnKey===t.watchKey&&ye(e,$t(t.watchKey),r.writeKeys),Fe.del()}function au(e,t){var r;ta(),Ce.del(),zt(!1);const n=rt().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=pe())}function hn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const s=V(t),{mutateFnDict:o,usefulName:c,forAtom:a,sharedState:u}=s,i=l=>rr(s,l);r.forEach(l=>{const f=o[l];yt(({sn:d,isFirstCall:y})=>{if(y&&au(s,f),!s.enableMutate)return;const{desc:m,fn:p,task:g,immediate:v}=f,S=Pa(c,m);try{if(S.isIn)throw Zr(c,S.cycle,m);const D={sn:d,throwErr:!0,isFirstCall:y,fnItem:f,from:B.MUTATE};if(p&&(y||!g)&&fs(t,D),g){y&&(f.depKeys=pe());const I=y&&(v!=null?v:!p);(!y||I)&&yn(t,D).catch(i)}return f}catch(D){D.cause==="DeadCycle"&&xa(c,D,s.alertDeadCycleErr),i(D)}},{deps:()=>f.deps?f.deps(pt(u,a))||[]:[],sharedState:t,scopeType:q.STATIC,immediate:!0})})}var{ACTION:ds}=B;function uu(e,t){const{label:n,throwErr:r,desc:s="",task:o,mergeReturn:c=!0}=t,a=le(e,{label:n}),{forAtom:u}=a,i=(l,f)=>{const d=f!=null?f:r,y=Ot({desc:s,task:o,depKeys:[]}),m=(p,g)=>p.__action?p.__action(g):p(g);return yn(e,{fnItem:y,from:ds,mergeReturn:c,throwErr:d,getArgs:({draft:p,draftRoot:g,setState:v,desc:S,flush:D})=>[{draft:p,draftRoot:g,setState:v,desc:S,payload:l,flush:D,merge:R=>{ts({partial:R,forAtom:u,draftRoot:g,draftNode:p})},dispatch:m}]})};return $r(a,cn(ds,s),{loading:!1,ok:!0,err:null}),i.__sharedKey=a.sharedKey,i.__fnName=s,i.__task=o,o.__action=i,i}function ps(e){return t=>(n,r="",s)=>uu(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:s})}var{TASK:ys}=Je,{STATIC:iu,HOOK:fu}=q;function hs(e,t,n){if(!n&&(!j(t)||St(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:s}=e;if(r&&!s){const o=Sr(t),c=te(t);if(o&&e.fnKey!==o||c)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function lu(e,t){const n=ue(e.result,{set:()=>(Ee("changing derived result is invalid"),!1),get:(r,s)=>{if(s===je)return t;const o=r[s];return Se(e.depKeys,{belongCtx:e}),Xt(e.depKeys,n),Qt(0,o,n,"",[s],!0,t),o}});return e.proxyResult=n,n}function gs(e,t){const{result:n,isUpstream:r}=t,s=Oe(n);s&&(e.depKeys=he(e.depKeys.concat(s.depKeys)),T(s.nextLevelFnKeys,e.fnKey),T(e.prevLevelFnKeys,s.fnKey),e.isFirstLevel=!1,r==null||r())}function du(e){var I,R;const{scopeType:t=iu,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:s=ys,returnUpstreamResult:o,runAsync:c=!0,forAtom:a=!1,immediate:u}=e;if(!F(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:i=M,deps:l=M,task:f}=e,d=K=>{const _=Y(l);return K.isFirstCall&&_.forEach(k=>gs(p,{result:k})),i(N(b({},K),{input:_}))},y=(I=e.isAsync)!=null?I:F(f),m=(R=e.showLoading)!=null?R:y,p=zr(d,{specificProps:{forAtom:a,scopeType:t,fnType:Yo,task:f,deps:l,isAsync:y,asyncType:s,isAsyncTransfer:r,showLoading:m},fnCtxBase:n});an(p.fnKey,0);let g=d({isFirstCall:!0,prevResult:null,triggerReasons:[]});pe();const v=Oe(g);a&&!v&&(g={val:g,z__is_atom_result__:!0});const S=p.fnKey;hs(p,g),gs(p,{result:g,isUpstream:()=>{p.returnUpstreamResult=o!=null?o:!y}}),Jt(p),p.returnUpstreamResult||vr(g,t,S);const D=c&&s===ys&&(u!=null?u:!e.fn);return f&&D&&Ne(S,{isFirstCall:!0,sn:p.renderInfo.sn+1}).then(K=>{hs(p,K[0],a)}).catch(K=>oe(K)),p.result=g,t===fu&&Jr(p)&&p.setLoading(!0),p.returnUpstreamResult?p.proxyResult=g:lu(p,a),p}function gn(e,t){const n=F(e)?{fn:e}:e||{};return du(b(b({},t||{}),n))}function ms(e){return gn(e,{forAtom:!0}).proxyResult}function pu(e){return gn(e).proxyResult}function yu(e){return t=>N(b({},t),{deps:e})}function hu(e){return e}var ht=e=>[e.snap,e.err];function mn(e){const{target:t,desc:n="",forTask:r=!1,throwErr:s}=e,{mutateFnDict:o,snap:c}=V(t),a=n||We,u=o[a];if(!u)return{snap:c,err:new Error(`mutate fn ${a} not defined`),result:null};if(r&&!u.task)return{snap:c,err:new Error(`mutate task ${a} not defined`),result:null};const i={sn:0,fnItem:u,from:B.MUTATE,throwErr:s};return r?yn(t,i):fs(t,i)}function Es(e,t,n,r){return{run:s=>{const o=mn({target:e,desc:t,throwErr:s});return ht(o)},runTask:s=>Promise.resolve(mn({target:e,desc:t,forTask:!0,throwErr:s})).then(ht),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function gu(e){const{target:t,fnItem:n,label:r}=e,s=le(t,{label:r}),o=ss(n,"",s.mutateFnDict);if(!o)throw new Error("not a fn or fnItem { fn }");s.mutateFnDict[o.desc]=o,o.enabled=s.enableMutate;const c={[o.desc]:o};return s.enableMutate&&hn({target:t,dict:c}),Es(t,o.desc,o.oriDesc,s)}function mu(e){const{target:t,fnDict:n,label:r}=e,s=le(t,{label:r}),o=os(n,s.mutateFnDict,s.enableMutate);s.enableMutate&&hn({target:t,dict:o});const c={};return Object.keys(o).forEach(a=>{c[a]=Es(t,a,a,s)}),c}function Eu(e,t){const{label:n,descOrOptions:r,forTask:s=!1}=t,{desc:o,strict:c,throwErr:a}=tu(r);return o?Br(e,{label:n,strict:c})?{ok:!0,desc:o,forTask:s,throwErr:a,err:null}:{ok:!1,desc:o,forTask:s,throwErr:a,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:o,forTask:s,throwErr:a,err:new Error("miss desc")}}function vs(e,t){const{ok:n,desc:r,forTask:s,err:o,throwErr:c}=Eu(e,t);if(!n){if(c)throw o;return s?Promise.resolve([e,o]):[e,o]}const a=mn({target:e,desc:r,forTask:s,throwErr:c});return s?Promise.resolve(a).then(ht):ht(a)}function Ss(e,t){return vs(e,{descOrOptions:t,label:"runMutate"})}function Ks(e,t){return vs(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function As(e){return t=>gu({target:e,fnItem:t,label:"mutate"})}function En(e){return t=>mu({target:e,fnDict:t,label:"mutateDict"})}function Ds(e,t,n={}){const{tuple:r}=ut(e,t,n);return r}function _s(e,t,n={}){const{tuple:r}=ut(e,t,n),[s,o,c]=r;return N(b({},c),{state:s,setState:o})}var vu="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",Su="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function Ku(e,t,n){return e.isExpired?(e.isExpired=!1,!0):F(n)?!1:n!==t}function Au(e){un(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function Du(e,t){const{result:n,forAtom:r,showLoading:s}=t,{fnCtx:o,input:c,deriveFn:a}=e;let u=!1;if(a)if(Ku(o,c,n))u=!0,Au(o);else return;e.input=n;const i=Oe(n);if(!i)throw new Error(vu);if(r&&!ae(n))throw new Error(Su);e.deriveFn=()=>i.result,gn({fn:()=>i.result,deps:()=>[],task:()=>po(this,null,function*(){return i.result})},{isAsync:i.isAsync,scopeType:q.HOOK,fnCtxBase:o,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:Je.MAY_TRANSFER,showLoading:s}),Ur(o),u&&o.updater()}function Rs(e,t){const{result:n,forAtom:r}=t,{hookImpl:s,react:o}=e,c=s.useForceUpdate(),{current:a}=o.useRef({input:n,deriveFn:null,fnCtx:null});a.fnCtx||(a.fnCtx=it({updater:c,scopeType:q.HOOK,forAtom:r}));const u=a.fnCtx;return u.renderStatus=Re,Du(a,t),u}function _u(e,t){t.shouldReplaceResult&&(Ur(t),t.shouldReplaceResult=!1),at(e,t.subscribe,()=>wr(t)),e.react.useEffect(()=>{t.renderStatus=wt})}function Ts(e,t){e.react.useEffect(()=>(t.mountStatus=ze,Ir(t),()=>{un(t)}),[t])}function vn(e,t){const n=Rs(e,t);return at(e,n.subscribe,()=>wr(n)),Ts(e,n),n}function Ru(e,t){const n=Rs(e,t);return _u(e,n),Ts(e,n),n}function Sn(e,t,n){const r=Ru(e,b({result:t},n||{})),{proxyResult:s,status:o,renderInfo:c}=r;return[ae(t)?s.val:s,o,c]}function bs(e,t,n){if(t===null)return n;if(!F(t))return null;const{sharedState:r,forAtom:s}=e,o=s?r.val:r,c={};Bt.set(u=>c[u[0]]=1);const a=Y(t,o);return Bt.del(),a.includes(o)?e.key2InsKeys:c}function Is(e,t,n){const r=le(t),[s]=e.react.useState(()=>bs(r,n,null));return o=>{const{insCtxMap:c,key2InsKeys:a}=r,u=bs(r,o,a)||s||a,i={};if(Object.keys(u).forEach(f=>{(a[f]||[]).forEach(y=>i[y]=1)}),Object.keys(i).length){r.sn+=1;const f=r.sn;Object.keys(i).forEach(d=>{dn(c,Number(d),f)})}}}function Tu(e,t){_n(e);const n=en();return on(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:ws,MUTATE:Ms}=B;function Kn(e,t){_n(e);const{target:n,from:r="Mutate"}=t||{};let s=jr();n&&(s=le(n));const{loadingProxy:o,loadingState:c}=xe(re,{apiCtx:e,internal:s,from:r});return{loadingProxy:o,loadingState:c,internal:s,from:r}}function Fs(e,t){const{loadingProxy:n,internal:r,from:s}=Kn(e,t),{proxyState:o,extra:c,renderInfo:a}=on(e,n);return[de(c,o,s),r.setState,a]}function bu(e,t){const{loadingProxy:n}=Kn(e,{target:t,from:Ms});return n}function Iu(e,t){return Fs(e,{target:t,from:Ms})}function wu(e,t){const{loadingProxy:n}=Kn(e,{target:t,from:ws});return n}function Mu(e,t){return Fs(e,{target:t,from:ws})}function ks(e){return e.hookImpl.useForceUpdate()}function Cs(e,t){const n=(r,s)=>{let o=null;if(F(r)){const c=(0,G.P2)(s),a=r(c);o=(0,G._x)(c),j(a)&&Object.assign(o,a)}else j(r)&&(o=b(b({},s),r));return o};return e.hookImpl.useObjectLogic(t,n,!0)}function Fu(e,t,n){const{useRef:r,useMemo:s,useEffect:o}=e.react,c=r({fn:n,wrap:null});c.current.fn=s(()=>n,[n]),c.current.wrap||(c.current.wrap=(...a)=>{c.current.fn(...a)}),o(()=>{const a=oc(),u=c.current.wrap;return a.on(t,u),()=>a.off(t,u)},[t,c])}function An(e,t,n={}){const r=Te(t),{insCtx:s}=ut(e,t,N(b({},n),{forAtom:r,isReactive:!0}));return[s.proxyStateVal,s.proxyState,s.renderInfo]}function Os(e,t,n={}){const[r,s,o]=An(e,t,n);return N(b({},o),{state:r,stateRoot:s})}function ku(e,t,n){const r=j(n)?n:{};e.react.useEffect(()=>{const{srvRef:s}=r;F(s)&&s(t)},[])}function Cu(e,t,n){const r=e.hookImpl.useStable(t);return ku(e,r,n),r}function Ou(e){return t=>e.current=t}var{HOOK:Ls}=q;function Ps(e,t){e(()=>{var n,r;return t.mountStatus=ze,Ir(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{un(t)}},[t])}function xs(e,t){const{useRef:n,useState:r,useMemo:s,useEffect:o}=e.react,{label:c,forEffect:a,watchFn:u,watchOptions:i}=t,l=n({fn:u,wrap:null,fnKey:"",isDeferMarked:!1}),[f]=r(()=>it());if(l.current.fn=s(()=>u,[u]),!l.current.wrap){const{deps:d,immediate:y}=cs(a,i);l.current.wrap=p=>{if(f.mountStatus===ze){l.current.fn(p);return}f.extra.deferedWatch=()=>{if(l.current.isDeferMarked){l.current.fn(p);return}l.current.isDeferMarked=!0,an(l.current.fnKey,0),l.current.fn(p),pe()}};const{fnKey:m}=yt(l.current.wrap,{scopeType:Ls,fnCtxBase:f,deps:d,immediate:y,label:c});l.current.fnKey=m}Ps(o,f)}function Lu(e,t,n){const{useState:r,useEffect:s}=e.react,[o]=r(()=>it());if(o.fn===M){const{manualDepKeys:c=[]}=n;yt(t,{scopeType:Ls,fnCtxBase:o,deps:()=>c.map(u=>{const{sharedKey:i,keyPath:l}=Kr(u),f=gc(i);return ce(f,l)}),isSimpleWatch:!0})}Ps(s,o)}function Pu(e,t,n){xs(e,{label:"useWatch",forEffect:!1,watchFn:t,watchOptions:n})}function xu(e,t,n){xs(e,{label:"useWatchEffect",forEffect:!0,watchFn:t,watchOptions:n})}function Nu(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:s,stopDepth:o,sharedKey:c}=t,a=Ct(n),u=b({},r),i=(y,m,p,g)=>{const v=Me(m,p,{parentType:_r(y),parentKeyPath:g});qr(v,{internal:t,mutateCtx:a}),Ln(u,v.fullKeyPath,p)},l=(y,m,p)=>be(y,{set:(g,v,S)=>(i(g,v,S,p),!0),get:(g,v)=>{const S=g[v];if($e.includes(v))return ct(m===1,s,c,v,S);const D=Me(v,S,{isChanged:!1,parentKeyPath:p,op:"get",parentType:_r(g)});return m<o&&fe(S)?l(S,m+1,D.fullKeyPath):ce(u,D.fullKeyPath)}}),f=l(u,1,[]);nt.set(f,s),Ht.set(a);const d=s?f.val:f;return{draftRoot:f,draftNode:d,finishMutate(y,m={}){rs(a,m);const p=b({state:{},mutateCtx:a},e);ns(p,f,d,y)}}}function Uu(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function Vu(e){let t=[];return{target:Uc(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function Ns(e,t,n){return s=>{let o=Uu(s);e(c=>{const{isAtom:a,draftRoot:u}=nt.current(),i={draft:c,draftRoot:u,path:t,isAtom:a,UNDEFINED:Po},l=n==null?void 0:n(o,i);Ln(u,t,l!==void 0?l:o)},{from:B.SYNC})}}function Dn(e,t){const{sharedKey:n,innerSetState:r}=t;let s=H(e,n),o=Us.get(s);return o||(o=Ns(r,e),Us.set(s,o)),o}var Us=new Map;function Vs(e){const{forAtom:t,rawState:n}=e;return t?kn(n.val)?be(n.val,{get:(r,s)=>Dn(["val",s],e)}):Dn(["val"],e):be(n,{get:(r,s)=>Dn([s],e)})}var Ys=new Map;function Bs(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:s}=e,o=Vu(s);return(c,a)=>{let u=[];if(Array.isArray(c))u=t?["val",...c]:c;else{const{target:f,getPath:d}=o;c(t?f.val:f),u=d()}let i=H(u,n);a&&(i+=`${a.toString()}`);let l=Ys.get(i);return l||(l=Ns(r,u,a),Ys.set(i,l)),l}}function Yu(e,t){const{deep:n,forAtom:r,sharedKey:s}=t,o=eu(t),c=At(n),a=(g={})=>{const v={internal:p,setFactoryOpts:g},{finishMutate:S,draftRoot:D,draftNode:I}=c?za(v):Nu(v);return{finish:(R,K={})=>{const _=p.snap;if(R===_)return _;const k=Yc(r,R,I);return S(k,K),p.snap},draftRoot:D,draftNode:I}},u=(g={})=>a(g),i=(g,v={})=>a().finish(g,v),l=(g,v)=>{const[S,D,I]=v;return nn(e,ke.current(s)),a({handleCbReturn:S,enableDep:D}).finish(g,Za(I))},p=fr(t,{sharedState:e,setState:(g,v)=>l(g,[!0,!0,v]),setDraft:(g,v)=>l(g,[!1,!0,v]),insSetState:(g,v)=>l(g,[!0,!1,v]),insSetDraft:(g,v)=>l(g,[!1,!1,v]),setStateFactory:u,innerSetState:i,ruleConf:o,isDeep:c});return p.sync=Bs(p),p.syncer=Vs(p),dc(e,p),p}function Bu(e,t){const n=qa(e,t),{sharedRoot:r,sharedState:s}=Xc(n),o=Yu(r,n);mc(r,n),Oc(),hn({target:r,dict:n.mutateFnDict});const{draft:c,draftRoot:a}=rn(o,{isTop:!0});return o.reactive=c,o.reactiveRoot=a,lc(n.moduleName,o.loc),Ca(o.usefulName),sc(o),{sharedRoot:r,sharedState:s,internal:o,parsedOptions:n}}var{USER_STATE:Gs}=J,{MUTATE:Gu,ACTION:Hs}=B;function _n(e,t){Gs===(t||Gs)&&!en()&&(zc(e,re),wa(e,re))}function js(e,t){const{createFn:n,ldAction:r,actionDict:s,actionCreator:o,internal:c,apiCtx:a,forTp:u=!1}=e;xe(n,{internal:c,from:Hs,apiCtx:a});const i={},l={};return Object.keys(s).forEach(f=>{const d=s[f],y=u?d.__task:d,m=o(!1)(y,f,t);m.__fnName=f,l[f]=m;const p=(...g)=>{const v=m(...g);return cu(y)?Promise.resolve(v).then(S=>S.result):v.result};p.__fnName=f,i[f]=p}),{actions:i,eActions:l,getLoading:()=>r.getLoading(i),useLoading:()=>r.useLoading(i)[0],useLoadingInfo:()=>r.useLoading(i)}}function $s(e){const{state:t,ldMutate:n,mutateFnDict:r}=e,s=En(t)(r);return{witnessDict:s,getLoading:()=>n.getLoading(s),useLoading:()=>n.useLoading(s)[0],useLoadingInfo:()=>n.useLoading(s)}}function Hu(e){const{apiCtx:t,ldMutate:n,inital:r,mutateFnDict:s}=e,[o,,c]=Rn(t,r),a=$s({state:o,ldMutate:n,mutateFnDict:s});return b({derivedState:o,useDerivedState:i=>{const[l,,f]=c.useState(i);return[l,f]}},a)}function ju(e){const{apiCtx:t,deriveFnDict:n,throwErr:r}=e,s={},o={};return Object.keys(n).forEach(a=>{const u=ms(n[a]);s[a]=u,o[a]={runDerive:i=>Ba(u,i!=null?i:r),runDeriveTask:i=>Ga(u,i!=null?i:r),useDerived:i=>Sn(t,u,i)[0],useDerivedInfo:i=>Sn(t,u,i)}}),{result:new Proxy(s,{get:(a,u)=>s[u].val}),helper:o}}function $u(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(s=>{const o=n[s];o.enabled||(o.enabled=!0,r[s]=o)}),En(t.sharedState)(r)}}function Wu(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:s,stopArrDep:o,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:s,stopArrDep:o,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:u}}function re(e,t){const{stateType:n,apiCtx:r}=e;_n(r,n);const{sharedRoot:s,sharedState:o,internal:c}=Bu(e,t),{syncer:a,sync:u,forAtom:i,setState:l,setDraft:f,sharedKey:d,sharedKeyStr:y,rootValKey:m,reactive:p,reactiveRoot:g}=c,v=ps(s),S=v(),D={internal:c,from:Gu,apiCtx:r},I=re,R=Xr(I,N(b({},D),{from:Hs})),K=Xr(I,D),_={createFn:I,internal:c,apiCtx:r},k=N(b({},_),{ldAction:R,actionCreator:v});return{state:s,stateRoot:s,stateVal:o,setState:l,setDraft:f,setEnableMutate:E=>$u(E,c),getOptions:()=>Wu(c),setOnReadHook:E=>c.onRead=E,defineActions:E=>w=>js(N(b({},k),{actionDict:w}),E),defineTpActions:E=>w=>js(N(b({},k),{actionDict:w,forTp:!0}),E),defineMutateDerive:E=>w=>Hu(N(b({},_),{ldMutate:K,inital:E,mutateFnDict:w})),defineMutateSelf:()=>E=>$s({ldMutate:K,state:s,mutateFnDict:E}),defineFullDerive:E=>w=>ju({apiCtx:r,deriveFnDict:w,throwErr:E}),mutate:As(s),runMutate:E=>Ss(s,E),runMutateTask:E=>Ks(s,E),action:v,call:(E,w,A,h)=>S(E,A,h)(w),useState:E=>Ds(r,s,E),useStateX:E=>_s(r,s,E),useForceUpdate:E=>Is(r,s,E),useLocalState:E=>Cs(r,E),useLocalForceUpdate:()=>ks(r),getMutateLoading:K.getLoading,useMutateLoading:K.useLoading,getActionLoading:R.getLoading,useActionLoading:R.useLoading,getSnap:E=>ir(s,E),sync:u,syncer:a,sharedKey:d,sharedKeyStr:y,rootValKey:m,reactive:p,reactiveRoot:g,reactiveDesc:E=>Or(s,E),useReactive:E=>An(r,s,E),useReactiveX:E=>Os(r,s,E),flush:E=>nn(s,E),isAtom:i}}function Rn(e,t,n){const r=re({apiCtx:e,rawState:t},n);return[r.state,r.setState,r]}function Xu(e,t,n){return re({apiCtx:e,rawState:t},n)}function zu(e,t,n){const r=re({apiCtx:e,rawState:t,forAtom:!0},n);return[r.state,r.setState,r]}function Ju(e,t,n){return re({apiCtx:e,rawState:t,forAtom:!0},n)}function Ws(e,t){const{label:n,isSyncer:r}=t,s=le(e,{label:n});return(r?Vs:Bs)(s)}function Zu(e){return Ws(e,{label:"sync"})}function Qu(e){return Ws(e,{label:"syncer",isSyncer:!0})}var qu=100,ei=5e3;function ti(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function ni(e,t=!1){const n=Z();e&&(n.initCount+=1);const r=Kc(),s=ti(r,t);return Mr(e).set(r,s),s}function ri(e){const t=Z();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function si(e,t){const n=Z(),r=Mr(t);if(r.delete(e),t&&r.size===qu&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const s=Date.now();r.forEach((o,c)=>{!o.mounted&&s-o.time>ei&&r.delete(c)})}}function oi(e,t){const n=Z();n.runningKey=e.key,n.isDynamic=t}function ci(e){const t=Z();t.runningKey="",t.isDynamic=!1,e.collected=!0}function ai(e,t,n){Lu(e,n,{manualDepKeys:t.depKeys})}function Xs(e,t,n){let r={loading:!1,err:null,ok:!0};return ai(e,t,n),t.results.forEach(s=>{const o=vn(e,{result:s,forAtom:ae(s),showLoading:t.enableStatus});o.status.ok||(r=o.status)}),r}function zs(e,t,n){e.react.useEffect(()=>(t.mounted||ri(t),()=>{si(t.key,n)}),[t])}var ui=()=>!0,Tn=e=>e;function ii(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function bn(e,t,n,r,s){const o=t;return o.displayName=n,r?e.react.memo(o,s):o}function Js(e,t){const{sharedState:n,depKey:r,keyPath:s,compare:o,sharedKey:c,format:a=Tn}=t;return bn(e,function(){const i=on(e,n,{arrDep:!0});i.isFirstRender&&(s.length>=2?ii(s).forEach(d=>{i.recordDep({sharedKey:c,depKey:H(d,c),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},Ze)}):i.recordDep({sharedKey:c,depKey:r,keyPath:s}));const l=ce(i.internal.rawState,s);return a(l)},"HeluxSignal",!0,o)}function In(e,t){return bn(e,function(){const{result:r,format:s=Tn}=t,o=vn(e,{result:r,forAtom:!0});return s(o.proxyResult.val)},"HeluxDerivedAtomSignal",!0,t.compare)}function fi(e,t){return bn(e,function(){const{result:r,keyPath:s,format:o=Tn}=t;return vn(e,{result:r,forAtom:!1}),o(ce(r,s))},"HeluxDerivedSignal",!0,t.compare)}function Zs(e,t){const{isDynamic:n,cb:r,props:s,ref:o}=t,{collected:c,status:a}=e;c||oi(e,n);const i=r(s,{props:s,status:a,read:ho,ref:o})||"";return c||ci(e),i}function Qs(e,t,n){const r=ae(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const s=In(e,{result:n});return e.react.createElement(s,{status:{loading:!1,err:null,ok:!0}})}return Xn(n)}function qs(e,t,n,r){const{memo:s=!0,compare:o}=r||{},{key:c}=t,{react:a}=e,u=a.forwardRef||M,i=n();let l=u(i);se()&&(i.displayName="HeluxKeyedBlockForHMR",l=u((d,y)=>(y&&So(y,"current")&&(t.ref=y),a.createElement(i,N(b({},d),{key:c})))));const f=s?a.memo(l,o):l;return f.displayName="HeluxBlock",f[It]=!0,f}function li(e,t){const{cb:n,isDynamic:r,apiCtx:s,blockCtx:o}=e,{useForceUpdate:c}=s.hookImpl,a=r?zs:M;return qs(s,o,()=>(u,i)=>{const l=o.ref||i,f=Zs(o,{isDynamic:r,cb:n,props:u,ref:l}),d=c();return Xs(s,o,d),a(s,o,r),Qs(s,o,f)},t)}function di(e,t){const{cb:n,isDynamic:r,apiCtx:s,blockCtx:o}=e,c=r?zs:M,{useForceUpdate:a}=s.hookImpl,{useEffect:u}=s.react;return qs(s,o,()=>(i,l)=>{const f=o.ref||l,d=Zs(o,{isDynamic:r,cb:n,props:i,ref:f}),y=a(),m=Xs(s,o,y);c(s,o,r);const p=o.status.loading,g=m.loading;return u(()=>{p!==g&&y()},[p,g]),o.status=m,Qs(s,o,d)},t)}function eo(e,t){const n=nu(t),{enableStatus:r}=n,s=N(b({},e),{blockCtx:ni(e.isDynamic,r)});return r?di(s,n):li(s,n)}function pi(e,t,n){return eo({apiCtx:e,isDynamic:!1,cb:t},n)}function to(e,t,n){return eo({apiCtx:e,isDynamic:!0,cb:t},n)}function no(e,t,n){const{react:r}=e;if(t&&t[It])return r.createElement(t);const s=ui;if(F(t)){const d=to(e,t,{compare:s});return r.createElement(d)}if(ae(t)){const d=In(e,{result:t,compare:s,format:n});return r.createElement(d)}if(Te(t)){const d=te(t),y=Kt("val",d),p=Js(e,{sharedKey:d,sharedState:t,depKey:y,keyPath:["val"],compare:s,format:n});return r.createElement(p)}const o=Wc(),{sharedKey:c,val:a,stateOrResult:u,depKey:i,keyPath:l,isDerivedResult:f}=o;if(t===a&&u){if(o.isDerivedAtom){const y=In(e,{result:u,compare:s,format:n});return r.createElement(y)}if(f){const y=fi(e,{result:u,keyPath:l,compare:s,format:n});return r.createElement(y)}const d=Js(e,{sharedKey:c,sharedState:u,depKey:i,keyPath:l,compare:s,format:n});return r.createElement(d)}return t}var{shallowCompare:yi,isDiff:hi}=G.limuUtils,gi=Rn,mi=no,Ei={EVENT_NAME:Tt,RECORD_LOADING:bt,VER:Vn,LIMU_VER:ko};function ro(e,t,n){return t(e,n)}function vi(e,t){return ro(e,t)}function Si(e,t){return{build:n=>ro(e,t,n)}}var Ki=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function Ai(e){return e.startsWith("use")||Ki.includes(e)}function Di(e){return Object.assign({useSyncExternalStore:M},e)}function _i(e,t){const n=wo(e),r=b({},n),s={react:Di(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,a]=e.useState({});return()=>t(()=>a({}))});const o=Un;return Object.keys(o).forEach(a=>{const u=o[a];Ai(a)?r[a]=u.bind(null,s):r[a]=u}),Object.assign({model:a=>vi(r,a),modelFactory:a=>Si(r,a)},r)}function Ri(e){const{inited:t,API:n}=Jo();if(t)return n;const{heluxCtxKey:r,standalone:s,transfer:o,reactLib:c,act:a}=e,u=X[r],i=(l,f)=>{const d=f||Jn(),y=_i(c,a);return er({ROOT:d,inited:!0,api:y}),X[l]=d,y};if(!u)return i(r);if(s)return i(`${String(r)}_${Date.now()}`);if(o){const l=Jn();er({ROOT:l,inited:!0}),o(u,l)}return i(r,u)}var Ti=C(70079),bi=C.t(Ti,2),so=Ri({heluxCtxKey:"__HELUX__",reactLib:bi}),Ii=so.share,{atom:wi,atomx:Mi,share:Fi,sharex:ki,derive:Ci,deriveDict:Oi,defineDeriveTask:Li,defineDeriveFnItem:Pi,runDerive:xi,runDeriveTask:Ni,watch:Ui,watchEffect:Vi,useAtom:Yi,useAtomX:Bi,useReactive:Gi,useReactiveX:Hi,useDerived:ji,useWatch:$i,useWatchEffect:Wi,useGlobalId:Xi,useService:zi,useOnEvent:Ji,useMutable:Zi,useMutateLoading:Qi,useActionLoading:qi,useEffect:ef,useLayoutEffect:tf,useStable:nf,useObject:rf,useLocalForceUpdate:sf,useGlobalForceUpdate:of,action:cf,signal:af,block:uf,dynamicBlock:ff,$:lf,mutate:df,mutateDict:pf,runMutate:yf,runMutateTask:hf,sync:gf,syncer:mf,model:Ef,modelFactory:vf,emit:Sf,on:Kf,init:Af,reactiveDesc:Df,flush:_f,isAtom:Rf,isDerivedAtom:Tf,storeSrv:bf,shallowCompare:If,markRaw:wf,isDiff:Mf,produce:Ff,getMutateLoading:kf,getActionLoading:Cf,getDeriveLoading:Of,getRawState:Lf,getSnap:Pf,getAtom:xf,addMiddleware:Nf,addPlugin:Uf,cst:Vf}=so}}]);
}());